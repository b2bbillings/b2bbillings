import axios from "axios";
import apiConfig from "../config/api";

// Create axios instance with your API configuration
const apiClient = axios.create({
  baseURL: apiConfig.baseURL,
  timeout: apiConfig.timeout,
  headers: {
    "Content-Type": "application/json",
  },
});

// Request interceptor to add auth token
apiClient.interceptors.request.use(
  (config) => {
    const token =
      localStorage.getItem("token") || localStorage.getItem("authToken");
    if (token) {
      config.headers.Authorization = `Bearer ${token}`;
    }

    // ‚úÖ ADD: Company ID header if provided in params
    if (config.params?.companyId) {
      config.headers["x-company-id"] = config.params.companyId;
    }

    return config;
  },
  (error) => {
    return Promise.reject(error);
  }
);

// Response interceptor for error handling
apiClient.interceptors.response.use(
  (response) => {
    return response;
  },
  (error) => {
    if (error.response?.status === 401) {
      localStorage.removeItem("token");
      localStorage.removeItem("authToken");
      // ‚úÖ ADD: Redirect to login if needed
      if (window.location.pathname !== "/login") {
        console.warn("üîí Authentication expired, token removed");
      }
    }
    return Promise.reject(error);
  }
);

class SaleOrderService {
  // ==================== BASIC CRUD OPERATIONS ====================

  /**
   * ‚úÖ ENHANCED: Create a new sales order/quotation/proforma invoice with comprehensive tracking
   */
  async createSalesOrder(orderData) {
    try {
      // ‚úÖ VALIDATE: Ensure company ID is provided
      if (!orderData.companyId) {
        throw new Error("Company ID is required");
      }

      // ‚úÖ ENHANCED: Validate and prepare order data with source company tracking
      const enhancedOrderData = {
        ...orderData,

        // ‚úÖ NEW: Enhanced bidirectional tracking fields
        sourceOrderId: orderData.sourceOrderId || null,
        sourceOrderNumber: orderData.sourceOrderNumber || null,
        sourceOrderType: orderData.sourceOrderType || null,
        sourceCompanyId: orderData.sourceCompanyId || null,
        isAutoGenerated: orderData.isAutoGenerated || false,
        generatedFrom: orderData.generatedFrom || "manual",
        generatedBy: orderData.generatedBy || null,
        targetCompanyId: orderData.targetCompanyId || null,
        autoCreateCorrespondingPO: orderData.autoCreateCorrespondingPO || false,
        autoDetectSourceCompany: orderData.autoDetectSourceCompany ?? true,

        // ‚úÖ NEW: Enhanced creation context
        purchaseOrderId: orderData.purchaseOrderId || null,
        preserveItemDetails: orderData.preserveItemDetails ?? true,
        preservePricing: orderData.preservePricing ?? true,
        preserveTerms: orderData.preserveTerms ?? true,
        autoAcceptOrder: orderData.autoAcceptOrder || false,
        generationNotes: orderData.generationNotes || "",
        autoLinkCustomer: orderData.autoLinkCustomer ?? true,
        validateBidirectionalSetup:
          orderData.validateBidirectionalSetup ?? true,

        // ‚úÖ Enhanced customer handling
        customerName: orderData.customerName || null,
        customerMobile: orderData.customerMobile || null,
        customer: orderData.customer || null,

        // ‚úÖ Enhanced order settings
        orderType: orderData.orderType || "quotation",
        gstEnabled: orderData.gstEnabled ?? true,
        gstType:
          orderData.gstType || (orderData.gstEnabled ? "gst" : "non-gst"),
        taxMode: orderData.taxMode || "without-tax",
        priceIncludesTax: orderData.priceIncludesTax || false,
        status: orderData.status || "draft",
        priority: orderData.priority || "normal",
        roundOffEnabled: orderData.roundOffEnabled || false,
        roundOff: orderData.roundOff || 0,

        // ‚úÖ Enhanced metadata
        createdBy: orderData.createdBy || orderData.employeeName || null,
        lastModifiedBy: orderData.lastModifiedBy || orderData.createdBy || null,
        employeeName: orderData.employeeName || null,
        employeeId: orderData.employeeId || null,
      };

      console.log(
        "üì• ENHANCED: Creating sales order with comprehensive tracking:",
        {
          companyId: enhancedOrderData.companyId,
          orderType: enhancedOrderData.orderType,
          customerName: enhancedOrderData.customerName,
          sourceCompanyId: enhancedOrderData.sourceCompanyId,
          autoDetectSourceCompany: enhancedOrderData.autoDetectSourceCompany,
          isAutoGenerated: enhancedOrderData.isAutoGenerated,
          purchaseOrderId: enhancedOrderData.purchaseOrderId,
          preservationSettings: {
            items: enhancedOrderData.preserveItemDetails,
            pricing: enhancedOrderData.preservePricing,
            terms: enhancedOrderData.preserveTerms,
          },
          autoSettings: {
            linkCustomer: enhancedOrderData.autoLinkCustomer,
            validateSetup: enhancedOrderData.validateBidirectionalSetup,
          },
        }
      );

      // ‚úÖ ENHANCED: Pre-validate if this is a PO ‚Üí SO generation
      if (enhancedOrderData.purchaseOrderId) {
        console.log(
          "üîÑ ENHANCED: Preparing PO ‚Üí SO generation with validation"
        );

        // Validate PO exists and get details
        try {
          const poResponse = await apiClient.get(
            `/api/purchase-orders/${enhancedOrderData.purchaseOrderId}`
          );
          const purchaseOrder =
            poResponse.data?.data?.purchaseOrder ||
            poResponse.data?.purchaseOrder ||
            poResponse.data?.data ||
            poResponse.data;

          if (!purchaseOrder) {
            throw new Error("Purchase order not found");
          }

          console.log("‚úÖ ENHANCED: Source PO validated:", {
            poNumber: purchaseOrder.orderNumber,
            poCompanyId: purchaseOrder.companyId,
            poSupplierId: purchaseOrder.supplier,
            hasSupplier: !!purchaseOrder.supplier,
            alreadyGenerated: purchaseOrder.autoGeneratedSalesOrder,
          });

          // Check if SO already generated
          if (purchaseOrder.autoGeneratedSalesOrder) {
            throw new Error(
              `Sales order already generated from purchase order ${purchaseOrder.orderNumber}. ` +
                `Existing SO: ${purchaseOrder.salesOrderNumber || "Unknown"}`
            );
          }

          // Auto-set source tracking if not provided
          if (!enhancedOrderData.sourceOrderId) {
            enhancedOrderData.sourceOrderId = enhancedOrderData.purchaseOrderId;
            enhancedOrderData.sourceOrderNumber = purchaseOrder.orderNumber;
            enhancedOrderData.sourceOrderType = "purchase_order";
            enhancedOrderData.isAutoGenerated = true;
            enhancedOrderData.generatedFrom = "purchase_order";
          }
        } catch (poError) {
          console.error("‚ùå ENHANCED: PO validation failed:", poError);
          throw new Error(
            `Purchase order validation failed: ${poError.message}`
          );
        }
      }

      // ‚úÖ ENHANCED: Client-side data validation
      const validation = this.validateEnhancedOrderData(enhancedOrderData);
      if (!validation.isValid) {
        throw new Error(`Validation failed: ${validation.errors.join(", ")}`);
      }

      const response = await apiClient.post(
        "/api/sales-orders",
        enhancedOrderData
      );

      console.log("‚úÖ ENHANCED: Sales order creation response:", {
        success: response.data.success,
        orderNumber: response.data.data?.salesOrder?.orderNumber,
        sourceCompanyTracking: response.data.data?.sourceCompanyTracking,
        customerInfo: response.data.data?.customerInfo,
        bidirectionalSetup: response.data.data?.purchaseOrderSourceTracking,
      });

      return {
        success: true,
        data: response.data,
        message: response.data.message || "Sales order created successfully",

        // ‚úÖ ENHANCED: Include tracking summary in response
        trackingSummary: {
          hasSourceCompany:
            !!response.data.data?.sourceCompanyTracking?.detected,
          sourceCompanyDetectionMethod:
            response.data.data?.sourceCompanyTracking?.detectionMethod,
          customerAutoCreated: response.data.data?.customerInfo?.wasCreated,
          preservationApplied:
            response.data.data?.purchaseOrderSourceTracking
              ?.preservationApplied,
          bidirectionalValidated:
            response.data.data?.sourceCompanyTracking?.enabled,
        },
      };
    } catch (error) {
      console.error("‚ùå ENHANCED: Error creating sales order:", error);

      // ‚úÖ ENHANCED: Better error categorization
      let errorCategory = "GENERAL_ERROR";
      let errorMessage = "Failed to create sales order";

      if (error.message?.includes("Company ID is required")) {
        errorCategory = "MISSING_COMPANY_ID";
        errorMessage = "Company ID is required";
      } else if (error.message?.includes("Validation failed")) {
        errorCategory = "VALIDATION_ERROR";
        errorMessage = error.message;
      } else if (error.message?.includes("Purchase order validation failed")) {
        errorCategory = "SOURCE_PO_ERROR";
        errorMessage = error.message;
      } else if (error.message?.includes("already generated")) {
        errorCategory = "DUPLICATE_GENERATION";
        errorMessage = error.message;
      } else if (error.response?.status === 400) {
        errorCategory = "BAD_REQUEST";
        errorMessage = error.response.data?.message || "Invalid request data";
      } else if (error.response?.status === 401) {
        errorCategory = "AUTH_ERROR";
        errorMessage = "Authentication failed. Please login again.";
      } else if (error.response?.status === 403) {
        errorCategory = "PERMISSION_ERROR";
        errorMessage =
          "Access denied. You may not have permission to create sales orders.";
      } else if (error.response?.data?.message) {
        errorMessage = error.response.data.message;
      } else if (error.message) {
        errorMessage = error.message;
      }

      return {
        success: false,
        message: errorMessage,
        error: error.response?.data?.error || error.message,
        errorCategory,
        details: {
          originalError: error.message,
          response: error.response?.data,
          status: error.response?.status,
          validationErrors: error.response?.data?.validationErrors,
        },
      };
    }
  }
  √ü;

  /**
   * ‚úÖ FIXED: Enhanced order data validation with source company tracking (removed async)
   */
  validateEnhancedOrderData(orderData) {
    const errors = [];

    // Basic validation
    if (!orderData.companyId) {
      errors.push("Company ID is required");
    }

    if (
      !orderData.customerName &&
      !orderData.customer &&
      !orderData.customerMobile
    ) {
      errors.push("Customer information is required (name, ID, or mobile)");
    }

    if (
      !orderData.items ||
      !Array.isArray(orderData.items) ||
      orderData.items.length === 0
    ) {
      errors.push("At least one item is required");
    }

    // Enhanced item validation
    if (orderData.items) {
      orderData.items.forEach((item, index) => {
        if (!item.itemName && !item.productName) {
          errors.push(`Item ${index + 1}: Name is required`);
        }
        if (!item.quantity || item.quantity <= 0) {
          errors.push(`Item ${index + 1}: Valid quantity is required`);
        }
        if (
          (!item.pricePerUnit && !item.price) ||
          (item.pricePerUnit || item.price) < 0
        ) {
          errors.push(`Item ${index + 1}: Valid price is required`);
        }
      });
    }

    // Order type validation
    if (
      orderData.orderType &&
      !["quotation", "sales_order", "proforma_invoice"].includes(
        orderData.orderType
      )
    ) {
      errors.push("Invalid order type");
    }

    // ‚úÖ NEW: Enhanced bidirectional validation
    if (
      orderData.sourceOrderId &&
      !orderData.sourceOrderId.match(/^[a-fA-F0-9]{24}$/)
    ) {
      errors.push("Invalid source order ID format");
    }

    if (
      orderData.targetCompanyId &&
      !orderData.targetCompanyId.match(/^[a-fA-F0-9]{24}$/)
    ) {
      errors.push("Invalid target company ID format");
    }

    if (
      orderData.sourceCompanyId &&
      !orderData.sourceCompanyId.match(/^[a-fA-F0-9]{24}$/)
    ) {
      errors.push("Invalid source company ID format");
    }

    // ‚úÖ NEW: PO ‚Üí SO specific validation
    if (orderData.purchaseOrderId) {
      if (!orderData.purchaseOrderId.match(/^[a-fA-F0-9]{24}$/)) {
        errors.push("Invalid purchase order ID format");
      }

      if (orderData.validateBidirectionalSetup && !orderData.autoLinkCustomer) {
        errors.push(
          "Auto-link customer should be enabled when validating bidirectional setup"
        );
      }
    }

    // ‚úÖ NEW: Circular reference validation
    if (
      orderData.sourceCompanyId &&
      orderData.companyId &&
      orderData.sourceCompanyId === orderData.companyId
    ) {
      errors.push("Source company cannot be the same as target company");
    }

    return {
      isValid: errors.length === 0,
      errors,
    };
  }
  /**
   * ‚úÖ ENHANCED: Generate sales order from purchase order with comprehensive tracking
   */
  async generateFromPurchaseOrder(purchaseOrderId, conversionData = {}) {
    try {
      // ‚úÖ STEP 1: Enhanced validation with better error messages
      if (!purchaseOrderId) {
        throw new Error("Purchase Order ID is required");
      }

      if (!purchaseOrderId.match(/^[a-fA-F0-9]{24}$/)) {
        throw new Error("Invalid Purchase Order ID format");
      }

      console.log(
        "üîÑ ENHANCED: Starting PO ‚Üí SO generation with comprehensive tracking:",
        {
          purchaseOrderId,
          conversionData: {
            targetCompanyId: conversionData.targetCompanyId,
            autoLinkCustomer: conversionData.autoLinkCustomer,
            preserveItemDetails: conversionData.preserveItemDetails,
            preservePricing: conversionData.preservePricing,
            preserveTerms: conversionData.preserveTerms,
            validateBidirectionalSetup:
              conversionData.validateBidirectionalSetup,
          },
        }
      );

      // ‚úÖ STEP 2: Get purchase order with comprehensive population
      const poResponse = await apiClient.get(
        `/api/purchase-orders/${purchaseOrderId}?populate=supplier,companyId,supplier.linkedCompanyId`
      );

      if (!poResponse.data) {
        throw new Error("Failed to fetch purchase order data");
      }

      const poData = poResponse.data;
      const purchaseOrder =
        poData.data?.purchaseOrder ||
        poData.purchaseOrder ||
        poData.data ||
        poData;

      if (!purchaseOrder) {
        throw new Error("Purchase order not found");
      }

      console.log("‚úÖ ENHANCED: Purchase order fetched with population:", {
        orderId: purchaseOrder._id,
        orderNumber: purchaseOrder.orderNumber,
        hasSupplier: !!purchaseOrder.supplier,
        supplierType: typeof purchaseOrder.supplier,
        supplierLinkedCompany: purchaseOrder.supplier?.linkedCompanyId,
        hasCompanyId: !!purchaseOrder.companyId,
        companyType: typeof purchaseOrder.companyId,
        alreadyGenerated: purchaseOrder.autoGeneratedSalesOrder,
      });

      // ‚úÖ STEP 3: Enhanced pre-generation validation
      if (purchaseOrder.autoGeneratedSalesOrder) {
        throw new Error(
          `Sales order already generated from purchase order ${purchaseOrder.orderNumber}. ` +
            `Existing sales order: ${
              purchaseOrder.salesOrderNumber || "Unknown"
            } (ID: ${purchaseOrder.salesOrderRef || "Unknown"})`
        );
      }

      if (!purchaseOrder.supplier) {
        throw new Error("Purchase order has no supplier information");
      }

      // ‚úÖ STEP 4: Enhanced supplier validation and company detection
      let supplierId;
      let supplierDetails;

      if (
        typeof purchaseOrder.supplier === "object" &&
        purchaseOrder.supplier._id
      ) {
        supplierId = purchaseOrder.supplier._id;
        supplierDetails = purchaseOrder.supplier;
      } else if (typeof purchaseOrder.supplier === "string") {
        supplierId = purchaseOrder.supplier;

        // Fetch supplier details if not populated
        try {
          const supplierResponse = await apiClient.get(
            `/api/parties/${supplierId}?populate=linkedCompanyId`
          );
          supplierDetails =
            supplierResponse.data?.data?.party ||
            supplierResponse.data?.party ||
            supplierResponse.data?.data ||
            supplierResponse.data;
        } catch (supplierError) {
          console.warn(
            "‚ö†Ô∏è Could not fetch supplier details:",
            supplierError.message
          );
          supplierDetails = null;
        }
      }

      if (!supplierDetails) {
        throw new Error(
          `Invalid supplier data in purchase order. Supplier field: ${JSON.stringify(
            purchaseOrder.supplier
          )}`
        );
      }

      console.log("üîç ENHANCED: Supplier analysis:", {
        supplierId,
        supplierName: supplierDetails.name,
        hasLinkedCompany: !!supplierDetails.linkedCompanyId,
        linkedCompanyType: typeof supplierDetails.linkedCompanyId,
        linkedCompanyId:
          supplierDetails.linkedCompanyId?._id ||
          supplierDetails.linkedCompanyId,
        linkedCompanyName: supplierDetails.linkedCompanyId?.businessName,
        isLinkedSupplier: supplierDetails.isLinkedSupplier,
        enableBidirectionalOrders: supplierDetails.enableBidirectionalOrders,
      });

      // ‚úÖ STEP 5: Enhanced target company detection with multiple methods
      let targetCompanyId = conversionData.targetCompanyId;
      let targetCompanyDetails = null;
      let detectionMethod = "manual";

      // Priority 1: Use supplier's linkedCompanyId
      if (!targetCompanyId && supplierDetails.linkedCompanyId) {
        if (
          typeof supplierDetails.linkedCompanyId === "object" &&
          supplierDetails.linkedCompanyId._id
        ) {
          targetCompanyId = supplierDetails.linkedCompanyId._id;
          targetCompanyDetails = supplierDetails.linkedCompanyId;
          detectionMethod = "supplier_linked_company";
        } else if (typeof supplierDetails.linkedCompanyId === "string") {
          targetCompanyId = supplierDetails.linkedCompanyId;
          detectionMethod = "supplier_linked_company";

          // Fetch company details
          try {
            const companyResponse = await apiClient.get(
              `/api/companies/${targetCompanyId}`
            );
            targetCompanyDetails =
              companyResponse.data?.data?.company ||
              companyResponse.data?.company ||
              companyResponse.data?.data ||
              companyResponse.data;
          } catch (companyError) {
            console.warn(
              "‚ö†Ô∏è Could not fetch target company details:",
              companyError.message
            );
          }
        }
      }

      // Priority 2: Auto-detect by supplier details
      if (!targetCompanyId) {
        detectionMethod = "supplier_details_matching";
        console.log(
          "üîç ENHANCED: Attempting company detection by supplier details..."
        );

        try {
          const companiesResponse = await apiClient.get("/api/companies");
          const companiesData = companiesResponse.data;
          const companies =
            companiesData.data?.companies ||
            companiesData.companies ||
            companiesData.data ||
            [];

          const buyerCompanyId =
            purchaseOrder.companyId?._id || purchaseOrder.companyId;

          // Match by GST, phone, or email
          const matchingCompany = companies.find(
            (company) =>
              company._id.toString() !== buyerCompanyId.toString() &&
              ((supplierDetails.gstNumber &&
                company.gstin === supplierDetails.gstNumber) ||
                (supplierDetails.phoneNumber &&
                  company.phoneNumber === supplierDetails.phoneNumber) ||
                (supplierDetails.email &&
                  company.email === supplierDetails.email) ||
                (supplierDetails.name &&
                  company.businessName &&
                  company.businessName.toLowerCase() ===
                    supplierDetails.name.toLowerCase()))
          );

          if (matchingCompany) {
            targetCompanyId = matchingCompany._id;
            targetCompanyDetails = matchingCompany;
            console.log(
              "‚úÖ ENHANCED: Found matching company by supplier details:",
              {
                companyId: matchingCompany._id,
                companyName: matchingCompany.businessName,
                matchedBy:
                  supplierDetails.gstNumber === matchingCompany.gstin
                    ? "GST"
                    : supplierDetails.phoneNumber ===
                      matchingCompany.phoneNumber
                    ? "Phone"
                    : supplierDetails.email === matchingCompany.email
                    ? "Email"
                    : "Name",
              }
            );
          }
        } catch (companiesError) {
          console.warn(
            "‚ö†Ô∏è ENHANCED: Company detection by supplier details failed:",
            companiesError.message
          );
        }
      }

      if (!targetCompanyId) {
        throw new Error(
          `üö® ENHANCED ERROR: Cannot determine target company for sales order generation.\n\n` +
            `The supplier "${supplierDetails.name}" must have:\n` +
            `1. A linkedCompanyId pointing to their company, OR\n` +
            `2. Matching GST/phone/email with an existing company, OR\n` +
            `3. Manual targetCompanyId provided in conversion data.\n\n` +
            `Current supplier data:\n` +
            `- Name: ${supplierDetails.name}\n` +
            `- LinkedCompanyId: ${
              supplierDetails.linkedCompanyId || "None"
            }\n` +
            `- GST: ${supplierDetails.gstNumber || "None"}\n` +
            `- Phone: ${supplierDetails.phoneNumber || "None"}\n` +
            `- Email: ${supplierDetails.email || "None"}\n\n` +
            `Please link the supplier to a company first or provide targetCompanyId manually.`
        );
      }

      // ‚úÖ STEP 6: Enhanced circular reference validation
      const buyerCompanyId =
        purchaseOrder.companyId?._id || purchaseOrder.companyId;

      if (targetCompanyId.toString() === buyerCompanyId.toString()) {
        throw new Error(
          `üö® ENHANCED CIRCULAR REFERENCE ERROR:\n\n` +
            `The supplier's target company (${targetCompanyId}) cannot be the same as the buyer company (${buyerCompanyId}).\n\n` +
            `This would create a circular reference where a company would generate a sales order to sell to itself.\n\n` +
            `Current setup:\n` +
            `- Purchase Order: Created by Company ${buyerCompanyId}\n` +
            `- Supplier: ${supplierDetails.name}\n` +
            `- Supplier's Linked Company: ${targetCompanyId}\n` +
            `- Detection Method: ${detectionMethod}\n\n` +
            `Solution: The supplier should be linked to a DIFFERENT company that will create the sales order.\n` +
            `The flow should be: Company A creates PO ‚Üí Supplier (linked to Company B) ‚Üí Company B creates SO to sell back to Company A.`
        );
      }

      console.log("‚úÖ ENHANCED: Target company validation passed:", {
        buyerCompanyId,
        targetCompanyId,
        targetCompanyName: targetCompanyDetails?.businessName || "Unknown",
        detectionMethod,
        supplierName: supplierDetails.name,
      });

      // ‚úÖ STEP 7: Prepare enhanced request payload
      const enhancedPayload = {
        purchaseOrderId,

        // ‚úÖ Enhanced targeting
        targetCompanyId,
        sourceCompanyId: buyerCompanyId,

        // ‚úÖ Enhanced conversion options
        autoLinkCustomer: conversionData.autoLinkCustomer ?? true,
        validateBidirectionalSetup:
          conversionData.validateBidirectionalSetup ?? true,
        preserveItemDetails: conversionData.preserveItemDetails ?? true,
        preservePricing: conversionData.preservePricing ?? true,
        preserveTerms: conversionData.preserveTerms ?? true,
        autoAcceptOrder: conversionData.autoAcceptOrder ?? false,

        // ‚úÖ Enhanced metadata
        generationNotes:
          conversionData.generationNotes ||
          `Auto-generated from PO ${purchaseOrder.orderNumber} via enhanced bidirectional flow (${detectionMethod})`,
        convertedBy: conversionData.convertedBy || null,

        // ‚úÖ Enhanced tracking context
        enhancedTracking: {
          detectionMethod,
          supplierDetails: {
            id: supplierDetails._id,
            name: supplierDetails.name,
            linkedCompanyId: supplierDetails.linkedCompanyId,
          },
          targetCompanyDetails: {
            id: targetCompanyId,
            name: targetCompanyDetails?.businessName || "Unknown",
          },
          sourceCompanyDetails: {
            id: buyerCompanyId,
            name: purchaseOrder.companyId?.businessName || "Buyer Company",
          },
        },
      };

      console.log("üì¶ ENHANCED: Final request payload prepared:", {
        purchaseOrderId: enhancedPayload.purchaseOrderId,
        targetCompanyId: enhancedPayload.targetCompanyId,
        sourceCompanyId: enhancedPayload.sourceCompanyId,
        detectionMethod,
        preservationSettings: {
          items: enhancedPayload.preserveItemDetails,
          pricing: enhancedPayload.preservePricing,
          terms: enhancedPayload.preserveTerms,
        },
        autoSettings: {
          linkCustomer: enhancedPayload.autoLinkCustomer,
          validateSetup: enhancedPayload.validateBidirectionalSetup,
          autoAccept: enhancedPayload.autoAcceptOrder,
        },
      });

      // ‚úÖ STEP 8: Make the enhanced API call
      const response = await apiClient.post(
        `/api/sales-orders/generate-from-purchase/${purchaseOrderId}`,
        enhancedPayload
      );

      console.log(
        "‚úÖ ENHANCED: Sales order generation completed successfully:",
        {
          success: response.data.success,
          salesOrderId: response.data.data?.salesOrder?._id,
          salesOrderNumber: response.data.data?.salesOrder?.orderNumber,
          customerCreated: response.data.data?.customerCreated,
          customerLinked: response.data.data?.customerLinked,
          sourceCompanyTracking: response.data.data?.sourceCompanyTracking,
          bidirectionalTracking: response.data.data?.bidirectionalTracking,
        }
      );

      return {
        success: true,
        data: {
          salesOrder: response.data.data?.salesOrder,
          purchaseOrder: response.data.data?.purchaseOrder,
          customer: response.data.data?.customer,

          // ‚úÖ Enhanced tracking information
          enhancedTracking: {
            detectionMethod,
            targetCompanyId,
            sourceCompanyId: buyerCompanyId,
            supplierDetails,
            targetCompanyDetails,
            customerCreated: response.data.data?.customerCreated,
            customerLinked: response.data.data?.customerLinked,
            preservationApplied: {
              items: enhancedPayload.preserveItemDetails,
              pricing: enhancedPayload.preservePricing,
              terms: enhancedPayload.preserveTerms,
            },
            validationResults: response.data.data?.bidirectionalTracking,
          },

          // ‚úÖ Enhanced conversion summary
          conversionSummary: {
            originalPurchaseOrder: purchaseOrder.orderNumber,
            generatedSalesOrder: response.data.data?.salesOrder?.orderNumber,
            buyerCompany:
              purchaseOrder.companyId?.businessName || "Buyer Company",
            supplierCompany:
              targetCompanyDetails?.businessName || "Supplier Company",
            supplier: supplierDetails.name,
            detectionMethod,
            itemsConverted: response.data.data?.salesOrder?.items?.length || 0,
            totalAmount:
              response.data.data?.salesOrder?.totals?.finalTotal || 0,
            preservationStatus: {
              itemsPreserved: enhancedPayload.preserveItemDetails,
              pricingPreserved: enhancedPayload.preservePricing,
              termsPreserved: enhancedPayload.preserveTerms,
            },
          },
        },
        message:
          response.data.message ||
          "Sales order generated from purchase order successfully with enhanced tracking",
      };
    } catch (error) {
      console.error("‚ùå ENHANCED: PO ‚Üí SO generation failed:", {
        error: error.message,
        stack: error.stack,
        response: error.response?.data,
        status: error.response?.status,
      });

      // ‚úÖ Enhanced error categorization and messages
      let errorMessage = "Failed to generate sales order from purchase order";
      let errorCategory = "GENERAL_ERROR";

      if (
        error.message?.includes("same as the buyer company") ||
        error.message?.includes("CIRCULAR REFERENCE")
      ) {
        errorCategory = "CIRCULAR_REFERENCE";
        errorMessage = error.message; // Use the detailed circular reference error
      } else if (
        error.message?.includes("Cannot determine target company") ||
        error.message?.includes("ENHANCED ERROR")
      ) {
        errorCategory = "TARGET_COMPANY_DETECTION";
        errorMessage = error.message; // Use the detailed target company error
      } else if (error.message?.includes("already generated")) {
        errorCategory = "DUPLICATE_GENERATION";
        errorMessage = error.message; // Use the duplicate generation error
      } else if (
        error.message?.includes("no supplier") ||
        error.message?.includes("Invalid supplier")
      ) {
        errorCategory = "SUPPLIER_VALIDATION";
        errorMessage = error.message; // Use the supplier validation error
      } else if (error.message?.includes("Purchase Order ID is required")) {
        errorCategory = "MISSING_PURCHASE_ORDER_ID";
        errorMessage = "Purchase Order ID is required";
      } else if (error.message?.includes("Invalid Purchase Order ID format")) {
        errorCategory = "INVALID_PURCHASE_ORDER_ID";
        errorMessage = "Invalid Purchase Order ID format";
      } else if (error.message?.includes("Purchase order not found")) {
        errorCategory = "PURCHASE_ORDER_NOT_FOUND";
        errorMessage = "Purchase order not found";
      } else if (error.response?.status === 400) {
        errorCategory = "BAD_REQUEST";
        errorMessage =
          error.response.data?.message ||
          "Invalid purchase order for conversion";
      } else if (error.response?.status === 404) {
        errorCategory = "NOT_FOUND";
        errorMessage = "Purchase order not found";
      } else if (error.response?.status === 403) {
        errorCategory = "PERMISSION_DENIED";
        errorMessage =
          "Access denied. You may not have permission to generate sales orders.";
      } else if (error.response?.data?.message) {
        errorMessage = error.response.data.message;
      } else if (error.message) {
        errorMessage = error.message;
      }

      return {
        success: false,
        message: errorMessage,
        errorCategory,
        error: {
          originalError: error.message,
          response: error.response?.data,
          status: error.response?.status,
          details: error.response?.data?.details,
        },
        data: null,
      };
    }
  }

  /**
   * ‚úÖ NEW: Enhanced source company validation
   */
  async validateSourceCompanySetup(companyId, customerId) {
    try {
      // Get customer details to check linking
      const customerResponse = await apiClient.get(
        `/api/parties/${customerId}?populate=linkedCompanyId`
      );

      if (!customerResponse.data) {
        throw new Error("Failed to fetch customer details");
      }

      const customerData = customerResponse.data;
      const customer =
        customerData.data?.party ||
        customerData.party ||
        customerData.data ||
        customerData;

      const validation = {
        isValid: true,
        warnings: [],
        errors: [],
        recommendations: [],
        customer: {
          id: customer._id,
          name: customer.name,
          linkedCompanyId: customer.linkedCompanyId,
          isLinkedCustomer: customer.isLinkedCustomer,
          enableBidirectionalOrders: customer.enableBidirectionalOrders,
        },
        sourceCompany: null,
      };

      // Check for bidirectional readiness
      if (!customer.linkedCompanyId) {
        validation.warnings.push("Customer does not have a linked company ID");
        validation.recommendations.push(
          "Link this customer to their company account for automatic bidirectional order flow"
        );
      } else {
        // Get source company details
        try {
          const sourceCompanyResponse = await apiClient.get(
            `/api/companies/${customer.linkedCompanyId}`
          );
          const sourceCompany =
            sourceCompanyResponse.data?.data?.company ||
            sourceCompanyResponse.data?.company ||
            sourceCompanyResponse.data?.data ||
            sourceCompanyResponse.data;

          if (sourceCompany) {
            validation.sourceCompany = {
              id: sourceCompany._id,
              name: sourceCompany.businessName,
              isActive: sourceCompany.isActive,
              gstin: sourceCompany.gstin,
              email: sourceCompany.email,
              phoneNumber: sourceCompany.phoneNumber,
            };

            if (!sourceCompany.isActive) {
              validation.errors.push("Customer's linked company is inactive");
              validation.isValid = false;
            }
          }
        } catch (companyError) {
          validation.errors.push(
            "Failed to fetch customer's linked company details"
          );
          validation.isValid = false;
        }
      }

      if (!customer.isLinkedCustomer) {
        validation.warnings.push("Customer is not marked as a linked customer");
        validation.recommendations.push(
          "Enable 'isLinkedCustomer' flag for better tracking"
        );
      }

      if (!customer.enableBidirectionalOrders) {
        validation.errors.push(
          "Bidirectional orders are not enabled for this customer"
        );
        validation.isValid = false;
        validation.recommendations.push(
          "Enable bidirectional orders in customer settings"
        );
      }

      if (customer.linkedCompanyId?.toString() === companyId.toString()) {
        validation.errors.push(
          "Customer's linked company cannot be the same as source company"
        );
        validation.isValid = false;
        validation.recommendations.push(
          "Customer should be linked to a different company"
        );
      }

      return {
        success: true,
        data: validation,
        message: validation.isValid
          ? "Source company setup is valid"
          : "Source company setup has issues",
      };
    } catch (error) {
      return {
        success: false,
        message: error.message || "Failed to validate source company setup",
        data: {
          isValid: false,
          errors: [error.message],
          warnings: [],
          recommendations: ["Check customer and company data integrity"],
        },
      };
    }
  }

  /**
   * ‚úÖ NEW: Get enhanced bidirectional flow analytics
   */
  async getEnhancedBidirectionalAnalytics(companyId, filters = {}) {
    try {
      const params = {companyId, ...filters};
      const response = await apiClient.get(
        "/api/sales-orders/analytics/enhanced-bidirectional",
        {params}
      );

      return {
        success: true,
        data: response.data,
        message: "Enhanced bidirectional analytics fetched successfully",
      };
    } catch (error) {
      return {
        success: false,
        message:
          error.response?.data?.message ||
          error.message ||
          "Failed to fetch enhanced bidirectional analytics",
        data: null,
      };
    }
  }

  /**
   * ‚úÖ IMPROVED: Get all sales orders with enhanced endpoint handling
   */
  async getSalesOrders(companyId, options = {}) {
    try {
      const params = new URLSearchParams({
        companyId: companyId,
        populate: "customer", // ‚úÖ ADD: Populate customer data
        ...options,
      });

      const response = await apiClient.get(`/api/sales-orders?${params}`);

      if (response.data.success) {
        return {
          success: true,
          data: response.data.data,
          message: response.data.message,
        };
      } else {
        throw new Error(
          response.data.message || "Failed to fetch sales orders"
        );
      }
    } catch (error) {
      console.error("‚ùå Error fetching sales orders:", error);
      throw error;
    }
  }
  /**
   * ‚úÖ NEW: Get sales (alias for getSalesOrders for backward compatibility with PayIn)
   */
  async getSales(companyId, filters = {}) {
    console.log("üîÑ getSales called - redirecting to getSalesOrders");
    return this.getSalesOrders(companyId, filters);
  }

  /**
   * ‚úÖ IMPROVED: Get pending sales orders for payment (specific for PayIn component)
   */
  async getPendingSalesForPayment(companyId, customerId, customerName = null) {
    try {
      console.log("üí∞ Loading pending sales for payment:", {
        companyId,
        customerId,
        customerName,
      });

      if (!companyId) {
        throw new Error("Company ID is required");
      }

      if (!customerId && !customerName) {
        throw new Error("Customer ID or name is required");
      }

      const filters = {
        customerId: customerId,
        customerName: customerName,
        status: "sent,confirmed,delivered,pending", // Orders that can receive payments
        orderType: "sales_order", // Only sales orders, not quotations
        limit: 100,
        page: 1,
        // Add date range to limit results (last 2 years)
        dateFrom: new Date(Date.now() - 2 * 365 * 24 * 60 * 60 * 1000)
          .toISOString()
          .split("T")[0],
        dateTo: new Date().toISOString().split("T")[0],
      };

      const response = await this.getSalesOrders(companyId, filters);

      if (response.success) {
        const allOrders =
          response.data.salesOrders ||
          response.data.orders ||
          response.data.data ||
          [];
        console.log("üìã Total orders fetched:", allOrders.length);

        // ‚úÖ IMPROVED: Better customer matching
        const ordersWithPending = allOrders.filter((order) => {
          if (!order) return false;

          // Verify customer match (more flexible matching)
          const orderCustomerId =
            order.customerId || order.customer?._id || order.customer?.id;
          const orderCustomerName =
            order.customerName ||
            order.customer?.name ||
            order.customer?.businessName ||
            order.partyName;
          const orderCustomerPhone =
            order.customerPhone ||
            order.mobileNumber ||
            order.customer?.phone ||
            order.customer?.mobile;

          const partyId = customerId;
          const partyName = customerName;

          const isCustomerMatch =
            (orderCustomerId && orderCustomerId === partyId) ||
            (orderCustomerName &&
              orderCustomerName.toLowerCase() === partyName?.toLowerCase()) ||
            (orderCustomerPhone && orderCustomerPhone === partyName); // Phone match as fallback

          if (!isCustomerMatch) {
            console.log("‚ùå Customer mismatch for order:", order.orderNumber, {
              orderCustomerId,
              orderCustomerName,
              orderCustomerPhone,
              partyId,
              partyName,
            });
            return false;
          }

          // Check pending amount
          const totalAmount = parseFloat(
            order.totalAmount ||
              order.amount ||
              order.finalTotal ||
              order.grandTotal ||
              0
          );
          const paidAmount = parseFloat(
            order.paidAmount || order.amountPaid || order.receivedAmount || 0
          );
          const pendingAmount = totalAmount - paidAmount;

          console.log(
            `üí∏ Order ${order.orderNumber || order._id} payment status:`,
            {
              totalAmount,
              paidAmount,
              pendingAmount,
              hasPending: pendingAmount > 0.01,
            }
          );

          return pendingAmount > 0.01; // At least 1 paisa pending
        });

        console.log(
          "‚úÖ Orders with pending amounts:",
          ordersWithPending.length
        );

        // Sort by order date (newest first)
        ordersWithPending.sort((a, b) => {
          const dateA = new Date(
            a.orderDate || a.saleDate || a.quotationDate || a.createdAt
          );
          const dateB = new Date(
            b.orderDate || b.saleDate || b.quotationDate || b.createdAt
          );
          return dateB - dateA;
        });

        const totalPending = ordersWithPending.reduce((sum, order) => {
          const total = parseFloat(
            order.totalAmount || order.amount || order.finalTotal || 0
          );
          const paid = parseFloat(order.paidAmount || order.amountPaid || 0);
          return sum + (total - paid);
        }, 0);

        return {
          success: true,
          data: {
            salesOrders: ordersWithPending,
            orders: ordersWithPending,
            data: ordersWithPending,
            count: ordersWithPending.length,
            totalPending: totalPending,
          },
          message: `Found ${ordersWithPending.length} pending sales orders`,
        };
      }

      return response;
    } catch (error) {
      console.error("‚ùå Error in getPendingSalesForPayment:", error);
      return {
        success: false,
        message:
          error.response?.data?.message ||
          error.message ||
          "Failed to fetch pending sales orders",
        data: {
          salesOrders: [],
          orders: [],
          data: [],
          count: 0,
          totalPending: 0,
        },
      };
    }
  }

  /**
   * ‚úÖ NEW: Get customer's sales order summary for payment
   */
  async getCustomerOrderSummary(companyId, customerId, customerName = null) {
    try {
      const response = await this.getPendingSalesForPayment(
        companyId,
        customerId,
        customerName
      );

      if (response.success) {
        const orders = response.data.salesOrders || [];

        const summary = {
          totalOrders: orders.length,
          totalPendingAmount: response.data.totalPending || 0,
          oldestPendingOrder:
            orders.length > 0 ? orders[orders.length - 1] : null,
          newestOrder: orders.length > 0 ? orders[0] : null,
          ordersByStatus: {},
        };

        // Group by status
        orders.forEach((order) => {
          const status = order.status || "pending";
          if (!summary.ordersByStatus[status]) {
            summary.ordersByStatus[status] = 0;
          }
          summary.ordersByStatus[status]++;
        });

        return {
          success: true,
          data: summary,
          message: "Customer order summary fetched successfully",
        };
      }

      return response;
    } catch (error) {
      return {
        success: false,
        message: error.message || "Failed to fetch customer order summary",
        data: null,
      };
    }
  }

  /**
   * Get sales order by ID with full details
   */
  async getSalesOrderById(orderId) {
    try {
      if (!orderId) {
        throw new Error("Order ID is required");
      }

      const response = await apiClient.get(`/api/sales-orders/${orderId}`);
      return {
        success: true,
        data: response.data,
        message: "Sales order fetched successfully",
      };
    } catch (error) {
      return {
        success: false,
        message:
          error.response?.data?.message ||
          error.message ||
          "Failed to fetch sales order",
      };
    }
  }

  /**
   * ‚úÖ NEW: Get sales orders by source purchase order
   */
  async getSalesOrdersBySourcePurchaseOrder(purchaseOrderId, companyId = null) {
    try {
      if (!purchaseOrderId) {
        console.error("‚ùå Purchase Order ID is required but not provided");
        throw new Error("Purchase Order ID is required");
      }

      // ‚úÖ FIX: Get company ID from multiple sources
      const resolvedCompanyId =
        companyId ||
        localStorage.getItem("currentCompanyId") ||
        localStorage.getItem("companyId");

      if (!resolvedCompanyId) {
        console.error("‚ùå Company ID is required but not provided");
        throw new Error("Company ID is required");
      }

      const params = {
        companyId: resolvedCompanyId, // ‚úÖ ADD: Include company ID
        sourceOrderId: purchaseOrderId,
        sourceOrderType: "purchase_order",
        isAutoGenerated: true,
      };

      // ‚úÖ Fix the timer issue
      const timerLabel = `API_REQUEST_DURATION_${Date.now()}`;
      console.time(timerLabel);

      const response = await apiClient.get("/api/sales-orders", {params});

      const rawData = response.data;
      let salesOrders = [];

      if (rawData.success && rawData.data) {
        salesOrders = rawData.data.salesOrders || rawData.data.orders || [];
      } else if (Array.isArray(rawData)) {
        salesOrders = rawData;
      }

      const result = {
        success: true,
        data: {
          salesOrders,
          count: salesOrders.length,
        },
        message: `Found ${salesOrders.length} sales orders from purchase order`,
      };

      return result;
    } catch (error) {
      console.error("‚ùå Error in getSalesOrdersBySourcePurchaseOrder:");

      // ‚úÖ Enhanced error logging to see backend response
      if (error.response) {
        console.error("üîç Backend Error Response:", {
          status: error.response.status,
          statusText: error.response.statusText,
          data: error.response.data,
          headers: error.response.headers,
        });

        // Log the specific error message from backend
        if (error.response.data) {
          console.error("üìã Backend Error Details:", error.response.data);
        }
      }

      const errorResult = {
        success: false,
        message:
          error.response?.data?.message ||
          error.message ||
          "Failed to fetch sales orders by source purchase order",
        data: {
          salesOrders: [],
          count: 0,
        },
        error: {
          originalError: error.message,
          response: error.response?.data,
          status: error.response?.status,
        },
      };

      console.log("üí• Error result:", errorResult);
      return errorResult;
    }
  }

  /**
   * Update sales order
   */
  async updateSalesOrder(orderId, orderData) {
    try {
      const response = await apiClient.put(
        `/api/sales-orders/${orderId}`,
        orderData
      );
      return {
        success: true,
        data: response.data,
        message: "Sales order updated successfully",
      };
    } catch (error) {
      return {
        success: false,
        message:
          error.response?.data?.message ||
          error.message ||
          "Failed to update sales order",
      };
    }
  }

  /**
   * Delete/Cancel sales order
   */
  async deleteSalesOrder(orderId) {
    try {
      const response = await apiClient.delete(`/api/sales-orders/${orderId}`);
      return {
        success: true,
        data: response.data,
        message: "Sales order cancelled successfully",
      };
    } catch (error) {
      return {
        success: false,
        message:
          error.response?.data?.message ||
          error.message ||
          "Failed to delete sales order",
      };
    }
  }

  // ==================== UTILITY FUNCTIONS ====================

  /**
   * Enhanced client-side fallback generation with better logic
   */
  generateFallbackOrderNumber(
    companyId,
    orderType = "quotation",
    userId = null
  ) {
    const date = new Date();
    const year = date.getFullYear();
    const month = (date.getMonth() + 1).toString().padStart(2, "0");
    const day = date.getDate().toString().padStart(2, "0");
    const hours = date.getHours().toString().padStart(2, "0");
    const minutes = date.getMinutes().toString().padStart(2, "0");

    // Use company ID and user ID for uniqueness
    const companyHash = companyId ? companyId.slice(-3) : "001";
    const userHash = userId ? userId.slice(-2) : "01";
    const random = Math.floor(100 + Math.random() * 900);

    let prefix = "DOC";
    switch (orderType) {
      case "quotation":
        prefix = "QUO";
        break;
      case "sales_order":
        prefix = "SO";
        break;
      case "proforma_invoice":
        prefix = "PI";
        break;
      default:
        prefix = "QUO";
    }

    return `${prefix}-${year}${month}${day}${hours}${minutes}-${companyHash}${userHash}${random}`;
  }

  /**
   * Generate order number with exact route matching
   */
  async generateOrderNumber(companyId, orderType = "quotation", userId = null) {
    // Always provide fallback first for immediate response
    const fallbackNumber = this.generateFallbackOrderNumber(
      companyId,
      orderType,
      userId
    );

    // Try the exact endpoints that exist in your backend routes
    const endpointsToTry = [
      "/api/sales-orders/generate-number",
      "/api/sales-orders/next-order-number",
      "/api/sales-orders/next-number",
    ];

    for (const endpoint of endpointsToTry) {
      try {
        const params = {
          companyId,
          orderType,
          type: orderType,
        };

        const response = await apiClient.get(endpoint, {params});

        if (response.data) {
          const serverNumber =
            response.data.nextOrderNumber ||
            response.data.orderNumber ||
            response.data.number ||
            response.data.quotationNumber ||
            response.data.data?.nextOrderNumber;

          if (serverNumber) {
            return {
              success: true,
              data: {nextOrderNumber: serverNumber},
              message: "Order number generated successfully",
              source: "server",
            };
          }
        }
      } catch (error) {
        continue;
      }
    }

    // All endpoints failed, use fallback
    return {
      success: true,
      data: {nextOrderNumber: fallbackNumber},
      message: "Order number generated (fallback)",
      source: "fallback",
    };
  }

  /**
   * Get next order number (alternative method)
   */
  async getNextOrderNumber(companyId, orderType = "quotation", userId = null) {
    return this.generateOrderNumber(companyId, orderType, userId);
  }

  // ==================== FILTERING AND SEARCH ====================

  /**
   * Get quotations
   */
  async getQuotations(companyId, filters = {}) {
    try {
      const params = new URLSearchParams({
        companyId,
        orderType: "quotation",
        page: filters.page || 1,
        limit: filters.limit || 50,
      });

      // Add date filters if provided
      if (filters.dateFrom) params.append("dateFrom", filters.dateFrom);
      if (filters.dateTo) params.append("dateTo", filters.dateTo);
      if (filters.status) params.append("status", filters.status);
      if (filters.search) params.append("search", filters.search);

      const response = await apiClient.get(
        `/api/sales-orders/quotations?${params.toString()}`
      );

      // Flatten the nested response structure
      const rawData = response.data.data || response.data;

      // Handle nested quotations structure
      let quotationsArray = [];

      if (rawData.quotations && rawData.quotations.salesOrders) {
        quotationsArray = rawData.quotations.salesOrders;
      } else if (rawData.salesOrders) {
        quotationsArray = rawData.salesOrders;
      } else if (rawData.quotations && Array.isArray(rawData.quotations)) {
        quotationsArray = rawData.quotations;
      } else if (Array.isArray(rawData)) {
        quotationsArray = rawData;
      }

      // Ensure we always return an array
      const finalArray = Array.isArray(quotationsArray) ? quotationsArray : [];

      return {
        success: true,
        data: {
          quotations: finalArray,
          salesOrders: finalArray,
          pagination:
            rawData.quotations?.pagination || rawData.pagination || {},
          summary: rawData.quotations?.summary || rawData.summary || {},
        },
        message: response.data.message || "Quotations fetched successfully",
      };
    } catch (error) {
      if (error.response?.status === 404) {
        return {
          success: true,
          data: {
            quotations: [],
            salesOrders: [],
          },
          message: "No quotations found",
        };
      }

      return {
        success: false,
        error:
          error.response?.data?.message ||
          error.message ||
          "Failed to fetch quotations",
        data: {
          quotations: [],
          salesOrders: [],
        },
      };
    }
  }

  async checkGenerationEligibility(orderId, orderType = "sales") {
    try {
      const order = await this.getSalesOrderById(orderId);

      if (!order.success) {
        throw new Error("Order not found");
      }

      const orderData = order.data.data || order.data;

      const eligibility = {
        canGenerate: true,
        reasons: [],
        warnings: [],
        orderStatus: orderData.status,
        alreadyGenerated: false,
      };

      // Check if already generated
      if (orderType === "purchase" && orderData.autoGeneratedPurchaseOrder) {
        eligibility.canGenerate = false;
        eligibility.alreadyGenerated = true;
        eligibility.reasons.push(
          "Purchase order already generated from this sales order"
        );
      }

      // Check order status
      if (["cancelled", "deleted", "expired"].includes(orderData.status)) {
        eligibility.canGenerate = false;
        eligibility.reasons.push(
          `Cannot generate from ${orderData.status} order`
        );
      }

      // Check customer linking (for PO generation)
      if (orderType === "purchase" && !orderData.customer?.linkedCompanyId) {
        eligibility.warnings.push(
          "Customer is not linked to a company - manual target company may be required"
        );
      }

      return {
        success: true,
        data: eligibility,
        message: eligibility.canGenerate
          ? "Order is eligible for generation"
          : "Order is not eligible for generation",
      };
    } catch (error) {
      return {
        success: false,
        message: error.message || "Failed to check generation eligibility",
        data: {
          canGenerate: false,
          reasons: [error.message],
          warnings: [],
        },
      };
    }
  }

  async validateBidirectionalSetup(companyId, customerId) {
    try {
      // Get customer details to check linking
      const customerResponse = await fetch(
        `${apiConfig.baseURL}/api/parties/${customerId}`,
        {
          headers: {
            Authorization: `Bearer ${
              localStorage.getItem("token") || localStorage.getItem("authToken")
            }`,
            "Content-Type": "application/json",
          },
        }
      );

      if (!customerResponse.ok) {
        throw new Error("Failed to fetch customer details");
      }

      const customerData = await customerResponse.json();
      const customer =
        customerData.data?.party ||
        customerData.party ||
        customerData.data ||
        customerData;

      const validation = {
        isValid: true,
        warnings: [],
        errors: [],
        customer: {
          id: customer._id,
          name: customer.name,
          linkedCompanyId: customer.linkedCompanyId,
          isLinkedCustomer: customer.isLinkedCustomer,
          enableBidirectionalOrders: customer.enableBidirectionalOrders,
        },
      };

      // Check for bidirectional readiness
      if (!customer.linkedCompanyId) {
        validation.warnings.push("Customer does not have a linked company ID");
      }

      if (!customer.isLinkedCustomer) {
        validation.warnings.push("Customer is not marked as a linked customer");
      }

      if (!customer.enableBidirectionalOrders) {
        validation.errors.push(
          "Bidirectional orders are not enabled for this customer"
        );
        validation.isValid = false;
      }

      if (customer.linkedCompanyId?.toString() === companyId.toString()) {
        validation.errors.push(
          "Customer's linked company cannot be the same as source company"
        );
        validation.isValid = false;
      }

      return {
        success: true,
        data: validation,
        message: validation.isValid
          ? "Bidirectional setup is valid"
          : "Bidirectional setup has issues",
      };
    } catch (error) {
      return {
        success: false,
        message: error.message || "Failed to validate bidirectional setup",
        data: {
          isValid: false,
          errors: [error.message],
          warnings: [],
        },
      };
    }
  }
  /**
   * Get sales orders
   */
  async getOrders(companyId, filters = {}) {
    try {
      const params = {companyId, ...filters};
      const response = await apiClient.get("/api/sales-orders/orders", {
        params,
      });
      return {
        success: true,
        data: response.data,
        message: "Sales orders fetched successfully",
      };
    } catch (error) {
      return {
        success: false,
        message:
          error.response?.data?.message ||
          error.message ||
          "Failed to fetch sales orders",
      };
    }
  }
  /**
   * ‚úÖ NEW: Get bidirectional flow summary for an order
   */
  async getBidirectionalFlowSummary(orderId) {
    try {
      const [trackingResult, orderResult] = await Promise.all([
        this.getTrackingChain(orderId),
        this.getSalesOrderById(orderId),
      ]);

      const tracking = trackingResult.success ? trackingResult.data : null;
      const order = orderResult.success ? orderResult.data : null;

      const summary = {
        orderId,
        orderNumber: order?.data?.orderNumber || "Unknown",
        flowType: order?.data?.isAutoGenerated ? "incoming" : "outgoing",
        hasUpstream: !!order?.data?.sourceOrderId,
        hasDownstream:
          !!order?.data?.autoGeneratedPurchaseOrder ||
          !!order?.data?.convertedToInvoice,
        trackingChain: tracking?.data?.trackingChain || [],
        totalSteps: tracking?.data?.trackingChain?.length || 1,
      };

      return {
        success: true,
        data: summary,
        message: "Bidirectional flow summary retrieved successfully",
      };
    } catch (error) {
      return {
        success: false,
        message: error.message || "Failed to get bidirectional flow summary",
        data: null,
      };
    }
  }

  /**
   * ‚úÖ NEW: Format order for bidirectional display
   */
  formatOrderForBidirectional(order) {
    return {
      id: order._id || order.id,
      orderNumber: order.orderNumber,
      orderType: order.orderType,
      orderDate: order.orderDate,
      status: order.status,
      totalAmount: order.totals?.finalTotal || order.totalAmount || 0,
      isAutoGenerated: order.isAutoGenerated || false,
      sourceOrderType: order.sourceOrderType,
      sourceOrderNumber: order.sourceOrderNumber,
      hasGeneratedPO: order.autoGeneratedPurchaseOrder || false,
      hasGeneratedSO: order.autoGeneratedSalesOrder || false,
      bidirectionalReady: order.customer?.enableBidirectionalOrders || false,
      customerLinked: !!order.customer?.linkedCompanyId,
      displayText: `${order.orderNumber} - ‚Çπ${(
        order.totals?.finalTotal || 0
      ).toLocaleString("en-IN")} - ${order.status}${
        order.isAutoGenerated ? " (Auto)" : ""
      }`,
    };
  }
  /**
   * Get proforma invoices
   */
  async getProformaInvoices(companyId, filters = {}) {
    try {
      const params = {companyId, ...filters};
      const response = await apiClient.get("/api/sales-orders/proforma", {
        params,
      });
      return {
        success: true,
        data: response.data,
        message: "Proforma invoices fetched successfully",
      };
    } catch (error) {
      return {
        success: false,
        message:
          error.response?.data?.message ||
          error.message ||
          "Failed to fetch proforma invoices",
      };
    }
  }

  // In saleOrderService.js, replace the generatePurchaseOrder method with this enhanced version:
  /**
   * ‚úÖ FIXED: Generate purchase order from sales order (SO ‚Üí PO) with proper error handling
   */
  async generatePurchaseOrder(salesOrderId, conversionData = {}) {
    console.log("üîÑ START: generatePurchaseOrder called with:", {
      salesOrderId,
      conversionData,
      timestamp: new Date().toISOString(),
    });

    try {
      // ‚úÖ STEP 1: Validate inputs
      if (!salesOrderId) {
        console.error("‚ùå STEP 1 FAILED: Sales Order ID is required");
        throw new Error("Sales Order ID is required");
      }

      console.log("‚úÖ STEP 1: Input validation passed");

      // ‚úÖ STEP 2: Prepare request payload
      const requestPayload = {
        targetCompanyId: conversionData.targetCompanyId,
        targetSupplierId: conversionData.targetSupplierId,
        targetSupplierName: conversionData.targetSupplierName,
        targetSupplierMobile: conversionData.targetSupplierMobile,
        targetSupplierEmail: conversionData.targetSupplierEmail,
        convertedBy: conversionData.convertedBy,
        convertedByName: conversionData.convertedByName,
        notes: conversionData.notes || "",
        deliveryDate: conversionData.deliveryDate,
        validUntil: conversionData.validUntil,
        priority: conversionData.priority || "normal",
        terms: conversionData.terms || conversionData.termsAndConditions || "",
        orderType: conversionData.orderType || "purchase_order",
        autoLinkSupplier: conversionData.autoLinkSupplier ?? true,
        validateBidirectionalSetup:
          conversionData.validateBidirectionalSetup ?? true,
        conversionReason:
          conversionData.conversionReason || "sales_order_to_purchase_order",
        sourceOrderId: conversionData.sourceOrderId || salesOrderId,
        sourceOrderNumber: conversionData.sourceOrderNumber,
        sourceOrderType: conversionData.sourceOrderType || "sales_order",
        sourceCompanyId: conversionData.sourceCompanyId,
      };

      console.log("‚úÖ STEP 2: Request payload prepared:", {
        targetCompanyId: requestPayload.targetCompanyId,
        hasTargetSupplierId: !!requestPayload.targetSupplierId,
        hasTargetSupplierName: !!requestPayload.targetSupplierName,
        payloadSize: JSON.stringify(requestPayload).length,
      });

      // ‚úÖ STEP 3: Check authentication token
      const token =
        localStorage.getItem("token") || localStorage.getItem("authToken");
      if (!token) {
        console.error("‚ùå STEP 3 FAILED: No authentication token found");
        throw new Error("Authentication token not found. Please login again.");
      }

      console.log("‚úÖ STEP 3: Authentication token found");

      // ‚úÖ STEP 4: Make API call using apiClient (with proper interceptors)
      console.log("üîÑ STEP 4: Making API call to generate purchase order...");

      const response = await apiClient.post(
        `/api/sales-orders/${salesOrderId}/generate-purchase-order`,
        requestPayload,
        {
          timeout: 30000, // 30 second timeout
          headers: {
            "Content-Type": "application/json",
          },
        }
      );

      console.log("‚úÖ STEP 4: API call completed successfully:", {
        status: response.status,
        statusText: response.statusText,
        hasData: !!response.data,
      });

      // ‚úÖ STEP 5: Process response
      console.log("üîÑ STEP 5: Processing API response...");

      if (!response.data) {
        throw new Error("No response data received from server");
      }

      const responseData = response.data;

      console.log("‚úÖ STEP 5: Response processed successfully:", {
        success: responseData.success,
        hasData: !!responseData.data,
        message: responseData.message,
      });

      // ‚úÖ Check if response indicates success
      if (responseData.success === false) {
        throw new Error(
          responseData.message || "Server returned unsuccessful response"
        );
      }

      // ‚úÖ STEP 6: Return success result
      console.log("‚úÖ SUCCESS: Purchase order generation completed:", {
        success: true,
        purchaseOrderId: responseData.data?.purchaseOrder?._id,
        purchaseOrderNumber: responseData.data?.purchaseOrder?.orderNumber,
        message: responseData.message,
      });

      return {
        success: true,
        data: responseData.data || responseData,
        message:
          responseData.message ||
          "Purchase order generated from sales order successfully",
      };
    } catch (error) {
      console.error("‚ùå FINAL ERROR in generatePurchaseOrder:", {
        error: error.message,
        name: error.name,
        code: error.code,
        status: error.response?.status,
        response: error.response?.data,
        timestamp: new Date().toISOString(),
      });

      // Enhanced error handling
      let errorMessage = "Failed to generate purchase order from sales order";
      let errorCategory = "GENERAL_ERROR";

      if (error.code === "ECONNABORTED" || error.message?.includes("timeout")) {
        errorCategory = "TIMEOUT_ERROR";
        errorMessage =
          "Request timed out. The server is taking too long to respond.";
      } else if (error.response?.status === 401) {
        errorCategory = "AUTH_ERROR";
        errorMessage = "Authentication failed. Please login again.";
      } else if (error.response?.status === 404) {
        errorCategory = "NOT_FOUND_ERROR";
        errorMessage = "Sales order not found or API endpoint not available.";
      } else if (error.response?.status === 400) {
        errorCategory = "VALIDATION_ERROR";
        errorMessage = error.response?.data?.message || "Invalid request data.";
      } else if (error.response?.status === 500) {
        errorCategory = "SERVER_ERROR";
        errorMessage = "Internal server error. Please try again later.";
      } else if (error.response?.data?.message) {
        errorMessage = error.response.data.message;
      } else if (error.message) {
        errorMessage = error.message;
      }

      return {
        success: false,
        message: errorMessage,
        errorCategory,
        error: error.message,
        details: {
          status: error.response?.status,
          response: error.response?.data,
          originalError: error.message,
        },
        timestamp: new Date().toISOString(),
      };
    }
  }
  /**
   * ‚úÖ DEBUG: Test the purchase order generation endpoint
   */
  async debugGeneratePurchaseOrder(salesOrderId) {
    console.log("üî¨ DEBUG: Testing purchase order generation endpoint...");

    try {
      // Test 1: Check if sales order exists
      const salesOrderResponse = await apiClient.get(
        `/api/sales-orders/${salesOrderId}`
      );
      console.log("‚úÖ Sales order found:", {
        id: salesOrderResponse.data.data?.salesOrder?._id,
        orderNumber: salesOrderResponse.data.data?.salesOrder?.orderNumber,
        status: salesOrderResponse.data.data?.salesOrder?.status,
      });

      // Test 2: Simple ping to generation endpoint
      const pingResponse = await fetch(
        `${apiConfig.baseURL}/api/sales-orders/${salesOrderId}/generate-purchase-order`,
        {
          method: "OPTIONS", // OPTIONS request to test endpoint availability
          headers: {
            Authorization: `Bearer ${localStorage.getItem("token")}`,
            "Content-Type": "application/json",
          },
        }
      );

      console.log("‚úÖ Endpoint ping result:", {
        status: pingResponse.status,
        statusText: pingResponse.statusText,
        ok: pingResponse.ok,
      });

      // Test 3: Minimal payload test
      const minimalPayload = {
        notes: "Debug test",
      };

      console.log("üîÑ Testing with minimal payload...");
      const testResponse = await fetch(
        `${apiConfig.baseURL}/api/sales-orders/${salesOrderId}/generate-purchase-order`,
        {
          method: "POST",
          headers: {
            Authorization: `Bearer ${localStorage.getItem("token")}`,
            "Content-Type": "application/json",
          },
          body: JSON.stringify(minimalPayload),
        }
      );

      const testResult = await testResponse.json();
      console.log("‚úÖ Minimal test result:", {
        status: testResponse.status,
        success: testResult.success,
        message: testResult.message,
      });

      return {
        success: true,
        message: "Debug test completed - check console for details",
      };
    } catch (error) {
      console.error("‚ùå Debug test failed:", error);
      return {
        success: false,
        message: `Debug test failed: ${error.message}`,
      };
    }
  }
  /**
   * ‚úÖ NEW: Bulk generate purchase orders from multiple sales orders
   */
  async bulkGeneratePurchaseOrders(salesOrderIds, conversionData = {}) {
    try {
      const response = await apiClient.post(
        "/api/sales-orders/bulk/generate-purchase-orders",
        {
          salesOrderIds,
          ...conversionData,
        }
      );
      return {
        success: true,
        data: response.data,
        message: "Purchase orders generated from sales orders successfully",
      };
    } catch (error) {
      return {
        success: false,
        message:
          error.response?.data?.message ||
          error.message ||
          "Failed to bulk generate purchase orders",
      };
    }
  }

  /**
   * ‚úÖ NEW: Get sales orders that have generated purchase orders
   */
  async getSalesOrdersWithGeneratedPO(companyId, filters = {}) {
    try {
      const params = {companyId, ...filters};
      const response = await apiClient.get(
        "/api/sales-orders/with-generated-po",
        {params}
      );
      return {
        success: true,
        data: response.data,
        message:
          "Sales orders with generated purchase orders fetched successfully",
      };
    } catch (error) {
      return {
        success: false,
        message:
          error.response?.data?.message ||
          error.message ||
          "Failed to fetch sales orders with generated purchase orders",
      };
    }
  }

  /**
   * ‚úÖ NEW: Get purchase order generation status for a sales order
   */
  async getPurchaseOrderGenerationStatus(companyId, salesOrderId) {
    try {
      const params = {companyId, salesOrderId};
      const response = await apiClient.get(
        "/api/sales-orders/generation-status",
        {params}
      );
      return {
        success: true,
        data: response.data,
        message: "Purchase order generation status fetched successfully",
      };
    } catch (error) {
      return {
        success: false,
        message:
          error.response?.data?.message ||
          error.message ||
          "Failed to fetch purchase order generation status",
      };
    }
  }

  /**
   * ‚úÖ NEW: Get sales order source tracking information
   */
  async getSalesOrderSourceTracking(salesOrderId) {
    try {
      const response = await apiClient.get(
        `/api/sales-orders/source-tracking/${salesOrderId}`
      );
      return {
        success: true,
        data: response.data,
        message: "Sales order source tracking information fetched successfully",
      };
    } catch (error) {
      return {
        success: false,
        message:
          error.response?.data?.message ||
          error.message ||
          "Failed to fetch sales order source tracking information",
      };
    }
  }

  /**
   * ‚úÖ NEW: Get auto-generated sales orders (from purchase orders)
   */
  async getAutoGeneratedSalesOrders(companyId, filters = {}) {
    try {
      const params = {companyId, ...filters};
      const response = await apiClient.get("/api/sales-orders/auto-generated", {
        params,
      });
      return {
        success: true,
        data: response.data,
        message: "Auto-generated sales orders fetched successfully",
      };
    } catch (error) {
      return {
        success: false,
        message:
          error.response?.data?.message ||
          error.message ||
          "Failed to fetch auto-generated sales orders",
      };
    }
  }

  /**
   * ‚úÖ NEW: Get sales orders created from specific purchase order
   */
  async getSalesOrdersFromPurchaseOrder(purchaseOrderId) {
    try {
      const response = await apiClient.get(
        `/api/sales-orders/from-purchase-order/${purchaseOrderId}`
      );
      return {
        success: true,
        data: response.data,
        message: "Sales orders from purchase order fetched successfully",
      };
    } catch (error) {
      return {
        success: false,
        message:
          error.response?.data?.message ||
          error.message ||
          "Failed to fetch sales orders from purchase order",
      };
    }
  }

  /**
   * ‚úÖ NEW: Get sales orders created from purchase orders
   */
  async getSalesOrdersFromPurchaseOrders(companyId, filters = {}) {
    try {
      const params = {companyId, ...filters};
      const response = await apiClient.get(
        "/api/sales-orders/from-purchase-orders",
        {params}
      );
      return {
        success: true,
        data: response.data,
        message: "Sales orders from purchase orders fetched successfully",
      };
    } catch (error) {
      return {
        success: false,
        message:
          error.response?.data?.message ||
          error.message ||
          "Failed to fetch sales orders from purchase orders",
      };
    }
  }

  /**
   * ‚úÖ NEW: Get bidirectional sales analytics
   */
  async getBidirectionalSalesAnalytics(companyId, filters = {}) {
    try {
      const params = {companyId, ...filters};
      const response = await apiClient.get(
        "/api/sales-orders/analytics/bidirectional-sales",
        {params}
      );
      return {
        success: true,
        data: response.data,
        message: "Bidirectional sales analytics fetched successfully",
      };
    } catch (error) {
      return {
        success: false,
        message:
          error.response?.data?.message ||
          error.message ||
          "Failed to fetch bidirectional sales analytics",
      };
    }
  }

  // ==================== ‚úÖ NEW TRACKING FUNCTIONS ====================

  /**
   * ‚úÖ NEW: Get complete tracking chain for a sales order
   */
  async getTrackingChain(salesOrderId) {
    try {
      const response = await apiClient.get(
        `/api/sales-orders/${salesOrderId}/tracking-chain`
      );
      return {
        success: true,
        data: response.data,
        message: "Tracking chain retrieved successfully",
      };
    } catch (error) {
      return {
        success: false,
        message:
          error.response?.data?.message ||
          error.message ||
          "Failed to get tracking chain",
      };
    }
  }

  // ==================== ‚úÖ NEW BULK OPERATIONS ====================

  /**
   * ‚úÖ NEW: Bulk send multiple orders
   */
  async bulkSendOrders(orderIds, sendMethod = "email") {
    try {
      const response = await apiClient.patch("/api/sales-orders/bulk/send", {
        orderIds,
        sendMethod,
      });
      return {
        success: true,
        data: response.data,
        message: `${
          response.data.data?.modifiedCount || 0
        } orders sent successfully`,
      };
    } catch (error) {
      return {
        success: false,
        message:
          error.response?.data?.message ||
          error.message ||
          "Failed to bulk send orders",
      };
    }
  }

  // ==================== ‚úÖ NEW ENHANCED REPORTING ====================

  /**
   * ‚úÖ NEW: Get customer performance analysis
   */
  async getCustomerPerformanceAnalysis(companyId, filters = {}) {
    try {
      const params = {companyId, ...filters};
      const response = await apiClient.get(
        "/api/sales-orders/reports/customer-performance",
        {params}
      );
      return {
        success: true,
        data: response.data,
        message: "Customer performance analysis fetched successfully",
      };
    } catch (error) {
      return {
        success: false,
        message:
          error.response?.data?.message ||
          error.message ||
          "Failed to fetch customer performance analysis",
      };
    }
  }

  /**
   * ‚úÖ NEW: Get bidirectional integration summary report
   */
  async getBidirectionalSummaryReport(companyId, filters = {}) {
    try {
      const params = {companyId, ...filters};
      const response = await apiClient.get(
        "/api/sales-orders/reports/bidirectional-summary",
        {params}
      );
      return {
        success: true,
        data: response.data,
        message: "Bidirectional summary report fetched successfully",
      };
    } catch (error) {
      return {
        success: false,
        message:
          error.response?.data?.message ||
          error.message ||
          "Failed to fetch bidirectional summary report",
      };
    }
  }

  /**
   * ‚úÖ NEW: Get summary report for date range
   */
  async getSummaryReport(companyId, filters = {}) {
    try {
      const params = {companyId, ...filters};
      const response = await apiClient.get(
        "/api/sales-orders/reports/summary",
        {
          params,
        }
      );
      return {
        success: true,
        data: response.data,
        message: "Summary report fetched successfully",
      };
    } catch (error) {
      return {
        success: false,
        message:
          error.response?.data?.message ||
          error.message ||
          "Failed to fetch summary report",
      };
    }
  }
  /**
   * Get orders by status
   */
  async getOrdersByStatus(companyId, status, filters = {}) {
    try {
      const params = {companyId, ...filters};
      const response = await apiClient.get(
        `/api/sales-orders/by-status/${status}`,
        {params}
      );
      return {
        success: true,
        data: response.data,
        message: `${status} orders fetched successfully`,
      };
    } catch (error) {
      return {
        success: false,
        message:
          error.response?.data?.message ||
          error.message ||
          `Failed to fetch ${status} orders`,
      };
    }
  }

  /**
   * Get draft orders
   */
  async getDraftOrders(companyId, filters = {}) {
    return this.getOrdersByStatus(companyId, "draft", filters);
  }

  /**
   * Get pending orders (draft + sent)
   */
  async getPendingOrders(companyId, filters = {}) {
    try {
      const params = {companyId, ...filters};
      const response = await apiClient.get("/api/sales-orders/pending", {
        params,
      });
      return {
        success: true,
        data: response.data,
        message: "Pending orders fetched successfully",
      };
    } catch (error) {
      return {
        success: false,
        message:
          error.response?.data?.message ||
          error.message ||
          "Failed to fetch pending orders",
      };
    }
  }

  /**
   * Get active orders
   */
  async getActiveOrders(companyId, filters = {}) {
    try {
      const params = {companyId, ...filters};
      const response = await apiClient.get("/api/sales-orders/active", {
        params,
      });
      return {
        success: true,
        data: response.data,
        message: "Active orders fetched successfully",
      };
    } catch (error) {
      return {
        success: false,
        message:
          error.response?.data?.message ||
          error.message ||
          "Failed to fetch active orders",
      };
    }
  }

  /**
   * ‚úÖ FIXED: Get expired orders
   */
  async getExpiredOrders(companyId, filters = {}) {
    try {
      const params = {companyId, ...filters};
      // ‚úÖ Use the correct dedicated endpoint
      const response = await apiClient.get("/api/sales-orders/expired", {
        params,
      });
      return {
        success: true,
        data: response.data,
        message: "Expired orders fetched successfully",
      };
    } catch (error) {
      return {
        success: false,
        message:
          error.response?.data?.message ||
          error.message ||
          "Failed to fetch expired orders",
      };
    }
  }

  /**
   * ‚úÖ FIXED: Search orders
   */
  async searchOrders(companyId, searchTerm, filters = {}) {
    try {
      const params = {
        companyId,
        search: searchTerm, // ‚úÖ Use 'search' instead of 'q'
        ...filters,
      };
      const response = await apiClient.get("/api/sales-orders/search", {
        params,
      });
      return {
        success: true,
        data: response.data,
        message: "Search completed successfully",
      };
    } catch (error) {
      return {
        success: false,
        message:
          error.response?.data?.message || error.message || "Search failed",
      };
    }
  }

  // ==================== STATUS MANAGEMENT ====================

  /**
   * Update order status
   */
  async updateOrderStatus(orderId, status, reason = "") {
    try {
      const response = await apiClient.patch(
        `/api/sales-orders/${orderId}/status`,
        {
          status,
          reason,
        }
      );
      return {
        success: true,
        data: response.data,
        message: `Order status updated to ${status}`,
      };
    } catch (error) {
      return {
        success: false,
        message:
          error.response?.data?.message ||
          error.message ||
          "Failed to update order status",
      };
    }
  }

  /**
   * Accept order
   */
  async acceptOrder(orderId, reason = "") {
    try {
      const response = await apiClient.patch(
        `/api/sales-orders/${orderId}/accept`,
        {reason}
      );
      return {
        success: true,
        data: response.data,
        message: "Order accepted successfully",
      };
    } catch (error) {
      return {
        success: false,
        message:
          error.response?.data?.message ||
          error.message ||
          "Failed to accept order",
      };
    }
  }

  /**
   * Cancel order
   */
  async cancelOrder(orderId) {
    try {
      const response = await apiClient.patch(
        `/api/sales-orders/${orderId}/cancel`
      );
      return {
        success: true,
        data: response.data,
        message: "Order cancelled successfully",
      };
    } catch (error) {
      return {
        success: false,
        message:
          error.response?.data?.message ||
          error.message ||
          "Failed to cancel order",
      };
    }
  }

  /**
   * ‚úÖ NEW: Mark order as sent
   */
  async sendOrder(orderId, reason = "") {
    try {
      const response = await apiClient.patch(
        `/api/sales-orders/${orderId}/send`,
        {reason}
      );
      return {
        success: true,
        data: response.data,
        message: "Order marked as sent successfully",
      };
    } catch (error) {
      return {
        success: false,
        message:
          error.response?.data?.message ||
          error.message ||
          "Failed to mark order as sent",
      };
    }
  }

  /**
   * ‚úÖ NEW: Reject order
   */
  async rejectOrder(orderId, reason = "") {
    try {
      const response = await apiClient.patch(
        `/api/sales-orders/${orderId}/reject`,
        {reason}
      );
      return {
        success: true,
        data: response.data,
        message: "Order rejected successfully",
      };
    } catch (error) {
      return {
        success: false,
        message:
          error.response?.data?.message ||
          error.message ||
          "Failed to reject order",
      };
    }
  }

  /**
   * ‚úÖ NEW: Mark order as expired
   */
  async expireOrder(orderId, reason = "") {
    try {
      const response = await apiClient.patch(
        `/api/sales-orders/${orderId}/expire`,
        {reason}
      );
      return {
        success: true,
        data: response.data,
        message: "Order marked as expired successfully",
      };
    } catch (error) {
      return {
        success: false,
        message:
          error.response?.data?.message ||
          error.message ||
          "Failed to mark order as expired",
      };
    }
  }

  // ==================== ORDER CONVERSION ====================

  /**
   * Convert sales order to invoice
   */
  async convertToInvoice(orderId, conversionData = {}) {
    try {
      const response = await apiClient.post(
        `/api/sales-orders/${orderId}/convert-to-invoice`,
        {
          ...conversionData,
          convertedAt: new Date().toISOString(),
          convertedBy: conversionData.userId || "system",
        }
      );

      return {
        success: true,
        data: {
          order: response.data.data?.order || response.data.order,
          invoice: response.data.data?.invoice || response.data.invoice,
          conversion:
            response.data.data?.conversion || response.data.conversion,
        },
        message:
          response.data.message ||
          "Sales order converted to invoice successfully",
      };
    } catch (error) {
      let errorMessage = "Failed to convert sales order to invoice";

      if (error.response?.status === 400) {
        errorMessage =
          error.response.data?.message || "Sales order cannot be converted";
      } else if (error.response?.status === 404) {
        errorMessage = "Sales order not found";
      } else if (error.response?.data?.message) {
        errorMessage = error.response.data.message;
      } else if (error.message) {
        errorMessage = error.message;
      }

      return {
        success: false,
        error: errorMessage,
        data: null,
      };
    }
  }

  // ==================== ‚úÖ NEW: MISSING METHODS FROM ROUTES ====================

  /**
   * Get customer's pending documents for payment allocation
   */
  async getCustomerPendingDocuments(
    companyId,
    customerId,
    customerName = null
  ) {
    try {
      const params = {companyId};

      // Add customer identifier
      if (customerId) {
        params.customerId = customerId;
      }
      if (customerName) {
        params.customerName = customerName;
      }

      const response = await apiClient.get(
        `/api/sales-orders/customer/${customerId || "pending-documents"}`,
        {params}
      );

      return {
        success: true,
        data: response.data,
        message: "Customer pending documents fetched successfully",
      };
    } catch (error) {
      return {
        success: false,
        message:
          error.response?.data?.message ||
          error.message ||
          "Failed to fetch customer pending documents",
        data: {orders: [], invoices: []},
      };
    }
  }

  /**
   * Get expiring soon orders
   */
  async getExpiringSoonOrders(companyId, filters = {}) {
    try {
      const params = {companyId, ...filters};
      const response = await apiClient.get("/api/sales-orders/expiring-soon", {
        params,
      });
      return {
        success: true,
        data: response.data,
        message: "Expiring orders fetched successfully",
      };
    } catch (error) {
      return {
        success: false,
        message:
          error.response?.data?.message ||
          error.message ||
          "Failed to fetch expiring orders",
      };
    }
  }

  /**
   * Get converted orders
   */
  async getConvertedOrders(companyId, filters = {}) {
    try {
      const params = {companyId, ...filters};
      const response = await apiClient.get("/api/sales-orders/converted", {
        params,
      });
      return {
        success: true,
        data: response.data,
        message: "Converted orders fetched successfully",
      };
    } catch (error) {
      return {
        success: false,
        message:
          error.response?.data?.message ||
          error.message ||
          "Failed to fetch converted orders",
      };
    }
  }

  /**
   * Get orders pending payment
   */
  async getPendingOrdersForPayment(companyId, filters = {}) {
    try {
      const params = {companyId, ...filters};
      const response = await apiClient.get(
        "/api/sales-orders/pending-payment",
        {params}
      );
      return {
        success: true,
        data: response.data,
        message: "Orders pending payment fetched successfully",
      };
    } catch (error) {
      return {
        success: false,
        message:
          error.response?.data?.message ||
          error.message ||
          "Failed to fetch orders pending payment",
      };
    }
  }

  // ==================== PAYMENT METHODS ====================

  /**
   * Add payment to a sales order
   */
  async addPayment(orderId, paymentData) {
    try {
      const response = await apiClient.post(
        `/api/sales-orders/${orderId}/payment`,
        paymentData
      );
      return {
        success: true,
        data: response.data,
        message: "Payment added successfully",
      };
    } catch (error) {
      return {
        success: false,
        message:
          error.response?.data?.message ||
          error.message ||
          "Failed to add payment",
      };
    }
  }

  /**
   * Add advance payment to a sales order
   */
  async addAdvancePayment(orderId, paymentData) {
    try {
      const response = await apiClient.post(
        `/api/sales-orders/${orderId}/advance-payment`,
        {
          ...paymentData,
          isAdvancePayment: true,
        }
      );
      return {
        success: true,
        data: response.data,
        message: "Advance payment added successfully",
      };
    } catch (error) {
      return {
        success: false,
        message:
          error.response?.data?.message ||
          error.message ||
          "Failed to add advance payment",
      };
    }
  }

  // ==================== BULK OPERATIONS ====================

  /**
   * Bulk update status for multiple orders
   */
  async bulkUpdateStatus(orderIds, status, reason = "") {
    try {
      const response = await apiClient.patch("/api/sales-orders/bulk/status", {
        orderIds,
        status,
        reason,
      });
      return {
        success: true,
        data: response.data,
        message: `${
          response.data.data?.modifiedCount || 0
        } orders updated to ${status}`,
      };
    } catch (error) {
      return {
        success: false,
        message:
          error.response?.data?.message ||
          error.message ||
          "Failed to bulk update status",
      };
    }
  }

  /**
   * Bulk convert multiple orders to invoices
   */
  async bulkConvertToInvoices(orderIds) {
    try {
      const response = await apiClient.post("/api/sales-orders/bulk/convert", {
        orderIds,
      });
      return {
        success: true,
        data: response.data,
        message: `${
          response.data.data?.successCount || 0
        } orders converted successfully`,
      };
    } catch (error) {
      return {
        success: false,
        message:
          error.response?.data?.message ||
          error.message ||
          "Failed to bulk convert orders",
      };
    }
  }

  // ==================== BIDIRECTIONAL FUNCTIONALITY ====================

  /**
   * ‚úÖ ENHANCED: Generate sales order from purchase order with bidirectional tracking
   */
  async generateFromPurchaseOrder(purchaseOrderId, conversionData = {}) {
    try {
      // ‚úÖ STEP 1: Validate required parameters
      if (!purchaseOrderId) {
        throw new Error("Purchase Order ID is required");
      }

      // ‚úÖ STEP 2: Get purchase order with full supplier details - ENHANCED WITH POPULATION
      const poResponse = await fetch(
        `${apiConfig.baseURL}/api/purchase-orders/${purchaseOrderId}?populate=supplier,companyId`,
        {
          headers: {
            Authorization: `Bearer ${
              localStorage.getItem("token") || localStorage.getItem("authToken")
            }`,
            "Content-Type": "application/json",
          },
        }
      );

      if (!poResponse.ok) {
        throw new Error(
          `Failed to fetch purchase order: ${poResponse.statusText}`
        );
      }

      const poData = await poResponse.json();
      const purchaseOrder =
        poData.data?.purchaseOrder ||
        poData.purchaseOrder ||
        poData.data ||
        poData;

      if (!purchaseOrder) {
        throw new Error("Purchase order not found");
      }

      console.log("üîç Purchase order data:", {
        orderId: purchaseOrder._id,
        orderNumber: purchaseOrder.orderNumber,
        hasSupplier: !!purchaseOrder.supplier,
        supplierType: typeof purchaseOrder.supplier,
        supplierId: purchaseOrder.supplier?._id || purchaseOrder.supplier,
        hasCompanyId: !!purchaseOrder.companyId,
        companyIdType: typeof purchaseOrder.companyId,
      });

      // ‚úÖ STEP 3: ENHANCED - Validate and get supplier ID
      let supplierId = null;

      if (
        typeof purchaseOrder.supplier === "object" &&
        purchaseOrder.supplier?._id
      ) {
        // Supplier is already populated
        supplierId = purchaseOrder.supplier._id;
        console.log(
          "‚úÖ Supplier already populated:",
          purchaseOrder.supplier.name
        );
      } else if (
        typeof purchaseOrder.supplier === "string" &&
        purchaseOrder.supplier
      ) {
        // Supplier is just an ID
        supplierId = purchaseOrder.supplier;
        console.log("üîç Supplier ID found:", supplierId);
      } else {
        throw new Error(
          `Purchase order has no valid supplier. Supplier field: ${JSON.stringify(
            purchaseOrder.supplier
          )}`
        );
      }

      // ‚úÖ STEP 4: Get supplier details with populated linkedCompanyId - ONLY IF NOT ALREADY POPULATED
      let supplier = null;

      if (
        typeof purchaseOrder.supplier === "object" &&
        purchaseOrder.supplier?.name
      ) {
        // Supplier is already populated, but we need to check if linkedCompanyId is populated
        supplier = purchaseOrder.supplier;

        // If linkedCompanyId is not populated (just an ID), fetch it separately
        if (
          supplier.linkedCompanyId &&
          typeof supplier.linkedCompanyId === "string"
        ) {
          try {
            const linkedCompanyResponse = await fetch(
              `${apiConfig.baseURL}/api/companies/${supplier.linkedCompanyId}`,
              {
                headers: {
                  Authorization: `Bearer ${
                    localStorage.getItem("token") ||
                    localStorage.getItem("authToken")
                  }`,
                  "Content-Type": "application/json",
                },
              }
            );

            if (linkedCompanyResponse.ok) {
              const linkedCompanyData = await linkedCompanyResponse.json();
              const linkedCompany =
                linkedCompanyData.data?.company ||
                linkedCompanyData.company ||
                linkedCompanyData.data ||
                linkedCompanyData;
              if (linkedCompany) {
                supplier.linkedCompanyId = linkedCompany;
                console.log(
                  "‚úÖ Populated linkedCompanyId:",
                  linkedCompany.businessName
                );
              }
            }
          } catch (linkedCompanyError) {
            console.warn(
              "‚ö†Ô∏è Could not populate linkedCompanyId:",
              linkedCompanyError.message
            );
          }
        }
      } else {
        // Need to fetch supplier details
        const supplierResponse = await fetch(
          `${apiConfig.baseURL}/api/parties/${supplierId}?populate=linkedCompanyId`,
          {
            headers: {
              Authorization: `Bearer ${
                localStorage.getItem("token") ||
                localStorage.getItem("authToken")
              }`,
              "Content-Type": "application/json",
            },
          }
        );

        if (!supplierResponse.ok) {
          throw new Error(
            `Failed to fetch supplier details: ${supplierResponse.statusText}`
          );
        }

        const supplierData = await supplierResponse.json();
        supplier =
          supplierData.data?.party ||
          supplierData.party ||
          supplierData.data ||
          supplierData;

        if (!supplier) {
          throw new Error("Supplier not found");
        }
      }

      console.log("üîç ENHANCED SUPPLIER ANALYSIS:", {
        supplier: {
          id: supplier._id,
          name: supplier.name,
          linkedCompanyId: supplier.linkedCompanyId,
          linkedCompanyType: typeof supplier.linkedCompanyId,
          linkedCompanyName:
            supplier.linkedCompanyId?.businessName ||
            supplier.linkedCompanyId?.name,
          isLinkedSupplier: supplier.isLinkedSupplier,
          enableBidirectionalOrders: supplier.enableBidirectionalOrders,
          autoLinkByGST: supplier.autoLinkByGST,
          autoLinkByPhone: supplier.autoLinkByPhone,
          autoLinkByEmail: supplier.autoLinkByEmail,
          gstNumber: supplier.gstNumber,
          phoneNumber: supplier.phoneNumber,
          email: supplier.email,
        },
        buyerCompany: {
          id: purchaseOrder.companyId?._id || purchaseOrder.companyId,
          name:
            purchaseOrder.companyId?.businessName ||
            "Company making the purchase (buyer)",
        },
      });

      let targetCompanyId;
      let sourceCompanyDetails = null;

      // ‚úÖ PRIORITY 1: Auto-detect from supplier's linkedCompanyId FIRST
      if (supplier.linkedCompanyId) {
        // Use supplier's linkedCompanyId as target
        if (
          typeof supplier.linkedCompanyId === "object" &&
          supplier.linkedCompanyId._id
        ) {
          targetCompanyId = supplier.linkedCompanyId._id;
          sourceCompanyDetails = supplier.linkedCompanyId;
        } else if (typeof supplier.linkedCompanyId === "string") {
          targetCompanyId = supplier.linkedCompanyId;
        }
        console.log(
          "üîç Auto-detected target company from supplier's linkedCompanyId:",
          targetCompanyId
        );
      }
      // ‚úÖ PRIORITY 2: Manual target company provided (only if no linkedCompanyId)
      else if (conversionData.targetCompanyId) {
        targetCompanyId = conversionData.targetCompanyId;
        console.log(
          "üéØ Using manual target company (no linkedCompanyId):",
          targetCompanyId
        );
      }
      // ‚úÖ PRIORITY 3: Fallback - try to detect by matching supplier details
      else {
        console.log(
          "‚ö†Ô∏è No linkedCompanyId found, attempting company detection by supplier details..."
        );

        try {
          const companiesResponse = await fetch(
            `${apiConfig.baseURL}/api/companies`,
            {
              headers: {
                Authorization: `Bearer ${
                  localStorage.getItem("token") ||
                  localStorage.getItem("authToken")
                }`,
                "Content-Type": "application/json",
              },
            }
          );

          if (companiesResponse.ok) {
            const companiesData = await companiesResponse.json();
            const companies =
              companiesData.data?.companies ||
              companiesData.companies ||
              companiesData.data ||
              [];

            // Get buyer company ID
            const buyerCompanyId =
              purchaseOrder.companyId?._id || purchaseOrder.companyId;

            // Try to match by GST, phone, or email
            const matchingCompany = companies.find(
              (company) =>
                company._id.toString() !== buyerCompanyId.toString() &&
                ((supplier.gstNumber && company.gstin === supplier.gstNumber) ||
                  (supplier.phoneNumber &&
                    company.phoneNumber === supplier.phoneNumber) ||
                  (supplier.email && company.email === supplier.email))
            );

            if (matchingCompany) {
              targetCompanyId = matchingCompany._id;
              sourceCompanyDetails = matchingCompany;
              console.log("‚úÖ Found matching company by supplier details:", {
                companyId: matchingCompany._id,
                companyName: matchingCompany.businessName,
                matchedBy:
                  supplier.gstNumber === matchingCompany.gstin
                    ? "GST"
                    : supplier.phoneNumber === matchingCompany.phoneNumber
                    ? "Phone"
                    : "Email",
              });
            }
          }
        } catch (error) {
          console.warn("‚ö†Ô∏è Company detection failed:", error.message);
        }
      }

      if (!targetCompanyId) {
        throw new Error(
          "üö® Cannot determine target company for sales order generation. " +
            "The supplier must have a linkedCompanyId or matching company details. " +
            "Please link the supplier to a company first or provide targetCompanyId manually."
        );
      }

      // ‚úÖ STEP 6: CRITICAL VALIDATION - Ensure target is different from buyer
      const buyerCompanyId =
        purchaseOrder.companyId?._id || purchaseOrder.companyId;

      if (targetCompanyId.toString() === buyerCompanyId.toString()) {
        throw new Error(
          `üö® CRITICAL ERROR: Supplier's linkedCompanyId (${targetCompanyId}) cannot be the same as buyer company (${buyerCompanyId}). ` +
            `The supplier should be linked to a DIFFERENT company to enable bidirectional orders. ` +
            `Current setup: Supplier "${supplier.name}" is linked to the same company that's making the purchase.`
        );
      }

      console.log("‚úÖ CORRECTED COMPANY MAPPING:", {
        purchaseOrderCompany: buyerCompanyId, // Company making the purchase (buyer)
        salesOrderCompany: targetCompanyId, // Company creating the sales order (supplier's company)
        supplierLinkedCompany: supplier.linkedCompanyId,
        logic:
          "PO in buyer company ‚Üí SO in supplier's company selling TO buyer company",
        flow: `${supplier.name} (supplier) ‚Üí creates SO in Company(${targetCompanyId}) ‚Üí selling to Company(${buyerCompanyId})`,
      });

      // ‚úÖ STEP 7: Get buyer company details for customer creation
      const buyerCompanyResponse = await fetch(
        `${apiConfig.baseURL}/api/companies/${buyerCompanyId}`,
        {
          headers: {
            Authorization: `Bearer ${
              localStorage.getItem("token") || localStorage.getItem("authToken")
            }`,
            "Content-Type": "application/json",
          },
        }
      );

      let buyerCompanyDetails = null;
      if (buyerCompanyResponse.ok) {
        const buyerData = await buyerCompanyResponse.json();
        buyerCompanyDetails =
          buyerData.data?.company ||
          buyerData.company ||
          buyerData.data ||
          buyerData;
      }

      // ‚úÖ STEP 8: Prepare the request payload
      const requestPayload = {
        purchaseOrderId,
        targetCompanyId,
        autoLinkCustomer: conversionData.autoLinkCustomer ?? true,
        validateBidirectionalSetup:
          conversionData.validateBidirectionalSetup ?? true,
        preserveItemDetails: conversionData.preserveItemDetails ?? true,
        preservePricing: conversionData.preservePricing ?? true,
        preserveTerms: conversionData.preserveTerms ?? true,
        autoAcceptOrder: conversionData.autoAcceptOrder ?? false,
        generationNotes:
          conversionData.generationNotes ||
          "Auto-generated from purchase order via bidirectional flow",

        // ‚úÖ NEW: Enhanced tracking data
        sourceCompanyDetails: {
          id: buyerCompanyId,
          name: buyerCompanyDetails?.businessName || "Buyer Company",
          details: buyerCompanyDetails,
        },
        targetCompanyDetails: {
          id: targetCompanyId,
          name: sourceCompanyDetails?.businessName || "Supplier Company",
          details: sourceCompanyDetails,
        },
        supplierDetails: {
          id: supplier._id,
          name: supplier.name,
          linkedCompanyId: supplier.linkedCompanyId,
          details: supplier,
        },
      };

      console.log("üì¶ Final request payload:", {
        purchaseOrderId: requestPayload.purchaseOrderId,
        targetCompanyId: requestPayload.targetCompanyId,
        autoLinkCustomer: requestPayload.autoLinkCustomer,
        sourceCompany: requestPayload.sourceCompanyDetails?.name,
        targetCompany: requestPayload.targetCompanyDetails?.name,
        supplier: requestPayload.supplierDetails?.name,
      });

      // ‚úÖ STEP 9: Make the API call
      const response = await apiClient.post(
        `/api/sales-orders/generate-from-purchase/${purchaseOrderId}`,
        requestPayload
      );

      console.log("‚úÖ BIDIRECTIONAL SALES ORDER GENERATION SUCCESS:", {
        success: response.data.success,
        salesOrderId: response.data.data?.salesOrder?._id,
        salesOrderNumber: response.data.data?.salesOrder?.orderNumber,
        targetCompanyId: response.data.data?.targetCompanyId,
        customerCreated: response.data.data?.customerCreated,
        customerLinked: response.data.data?.customerLinked,
        bidirectionalTracking: response.data.data?.bidirectionalTracking,
        message: response.data.message,
      });

      return {
        success: true,
        data: {
          salesOrder: response.data.data?.salesOrder,
          purchaseOrder: response.data.data?.purchaseOrder,
          customer: response.data.data?.customer,
          bidirectionalTracking: response.data.data?.bidirectionalTracking,
          targetCompanyId: response.data.data?.targetCompanyId,
          sourceCompanyId: buyerCompanyId,
          supplierDetails: requestPayload.supplierDetails,
          conversionSummary: {
            originalPurchaseOrder: purchaseOrder.orderNumber,
            generatedSalesOrder: response.data.data?.salesOrder?.orderNumber,
            buyerCompany: buyerCompanyDetails?.businessName,
            supplierCompany:
              sourceCompanyDetails?.businessName || "Supplier Company",
            customerCreated: response.data.data?.customerCreated,
            customerLinked: response.data.data?.customerLinked,
            itemsConverted: response.data.data?.salesOrder?.items?.length || 0,
            totalAmount:
              response.data.data?.salesOrder?.totals?.finalTotal || 0,
          },
        },
        message:
          response.data.message ||
          "Sales order generated from purchase order successfully",
      };
    } catch (error) {
      console.error("‚ùå BIDIRECTIONAL GENERATION FAILED:", {
        error: error.message,
        stack: error.stack,
        response: error.response?.data,
        status: error.response?.status,
      });

      // ‚úÖ Enhanced error messages
      let errorMessage = "Failed to generate sales order from purchase order";

      if (error.message?.includes("same as buyer company")) {
        errorMessage = error.message; // Use the detailed circular reference error
      } else if (error.message?.includes("Cannot determine target company")) {
        errorMessage = error.message; // Use the detailed target company error
      } else if (error.message?.includes("no valid supplier")) {
        errorMessage = error.message; // Use the supplier validation error
      } else if (error.response?.status === 400) {
        errorMessage =
          error.response.data?.message ||
          "Invalid purchase order for conversion";
      } else if (error.response?.status === 404) {
        errorMessage = "Purchase order not found";
      } else if (error.response?.status === 403) {
        errorMessage =
          "Access denied. You may not have permission to generate sales orders.";
      } else if (error.response?.data?.message) {
        errorMessage = error.response.data.message;
      } else if (error.message) {
        errorMessage = error.message;
      }

      return {
        success: false,
        message: errorMessage,
        error: {
          originalError: error.message,
          response: error.response?.data,
          status: error.response?.status,
          details: error.response?.data?.details,
        },
        data: null,
      };
    }
  }
  /**
   * Bulk generate sales orders from multiple purchase orders
   */
  async bulkGenerateFromPurchaseOrders(purchaseOrderIds, conversionData = {}) {
    try {
      const response = await apiClient.post(
        "/api/sales-orders/bulk/generate-from-purchase",
        {
          purchaseOrderIds,
          ...conversionData,
        }
      );
      return {
        success: true,
        data: response.data,
        message: "Sales orders generated from purchase orders successfully",
      };
    } catch (error) {
      return {
        success: false,
        message:
          error.response?.data?.message ||
          error.message ||
          "Failed to bulk generate sales orders",
      };
    }
  }

  /**
   * Get purchase orders that have generated sales orders
   */
  async getPurchaseOrdersWithSalesOrders(companyId, filters = {}) {
    try {
      const params = {companyId, ...filters};
      const response = await apiClient.get(
        "/api/sales-orders/purchase-orders-with-sales",
        {params}
      );
      return {
        success: true,
        data: response.data,
        message: "Purchase orders with sales orders fetched successfully",
      };
    } catch (error) {
      return {
        success: false,
        message:
          error.response?.data?.message ||
          error.message ||
          "Failed to fetch purchase orders with sales orders",
      };
    }
  }

  /**
   * Get bidirectional purchase analytics
   */
  async getBidirectionalPurchaseAnalytics(companyId, filters = {}) {
    try {
      const params = {companyId, ...filters};
      const response = await apiClient.get(
        "/api/sales-orders/analytics/bidirectional",
        {params}
      );
      return {
        success: true,
        data: response.data,
        message: "Bidirectional purchase analytics fetched successfully",
      };
    } catch (error) {
      return {
        success: false,
        message:
          error.response?.data?.message ||
          error.message ||
          "Failed to fetch bidirectional analytics",
      };
    }
  }

  /**
   * Get sales order generation status for a purchase order
   */
  // ‚úÖ CORRECT - Should be:
  async getSalesOrderGenerationStatus(companyId, purchaseOrderId) {
    const params = {companyId, purchaseOrderId};
    const response = await apiClient.get(
      "/api/sales-orders/sales-generation-status",
      {params}
    );
    return {
      success: true,
      data: response.data,
      message: "Sales order generation status fetched successfully",
    };
  }
  /**
   * Get purchase order source tracking information
   */

  // ‚úÖ CORRECT - Should be:
  async getPurchaseOrderSourceTracking(purchaseOrderId) {
    try {
      const response = await apiClient.get(
        `/api/sales-orders/purchase-order-tracking/${purchaseOrderId}`
      );
      return {
        success: true,
        data: response.data,
        message:
          "Purchase order source tracking information fetched successfully",
      };
    } catch (error) {
      return {
        success: false,
        message:
          error.response?.data?.message ||
          error.message ||
          "Failed to fetch purchase order source tracking information",
      };
    }
  }

  // ==================== ADDITIONAL REPORTING ====================

  /**
   * Get conversion rate analysis
   */
  async getConversionRateAnalysis(companyId, filters = {}) {
    try {
      const params = {companyId, ...filters};
      const response = await apiClient.get(
        "/api/sales-orders/reports/conversion-rate",
        {params}
      );
      return {
        success: true,
        data: response.data,
        message: "Conversion rate analysis fetched successfully",
      };
    } catch (error) {
      return {
        success: false,
        message:
          error.response?.data?.message ||
          error.message ||
          "Failed to fetch conversion rate analysis",
      };
    }
  }

  /**
   * Get aging report
   */
  async getAgingReport(companyId, filters = {}) {
    try {
      const params = {companyId, ...filters};
      const response = await apiClient.get("/api/sales-orders/reports/aging", {
        params,
      });
      return {
        success: true,
        data: response.data,
        message: "Aging report fetched successfully",
      };
    } catch (error) {
      return {
        success: false,
        message:
          error.response?.data?.message ||
          error.message ||
          "Failed to fetch aging report",
      };
    }
  }

  // ==================== EXPORT FUNCTIONS ====================

  /**
   * Export orders to CSV
   */
  async exportToCSV(companyId, filters = {}) {
    try {
      const params = {companyId, ...filters};
      const response = await apiClient.get("/api/sales-orders/export/csv", {
        params,
        responseType: "blob",
      });

      // Create download link
      const url = window.URL.createObjectURL(new Blob([response.data]));
      const link = document.createElement("a");
      link.href = url;
      link.setAttribute("download", `sales-orders-${Date.now()}.csv`);
      document.body.appendChild(link);
      link.click();
      link.remove();
      window.URL.revokeObjectURL(url);

      return {
        success: true,
        message: "Export completed successfully",
      };
    } catch (error) {
      return {
        success: false,
        message:
          error.response?.data?.message || error.message || "Export failed",
      };
    }
  }

  // ==================== REPORTING AND ANALYTICS ====================

  /**
   * Get dashboard summary
   */
  async getDashboardSummary(companyId) {
    try {
      const params = {companyId};
      const response = await apiClient.get(
        "/api/sales-orders/reports/dashboard",
        {params}
      );
      return {
        success: true,
        data: response.data,
        message: "Dashboard summary fetched successfully",
      };
    } catch (error) {
      return {
        success: false,
        message:
          error.response?.data?.message ||
          error.message ||
          "Failed to fetch dashboard summary",
      };
    }
  }

  // ==================== ‚úÖ DEBUG AND TESTING ====================

  /**
   * Test API connectivity and endpoints
   */
  async testConnection(companyId) {
    try {
      console.log("üî¨ Testing API connection...");

      const endpoints = [
        "/api/health",
        "/api/sales-orders/test",
        `/api/companies/${companyId}/test`,
        "/api/sales-orders",
      ];

      const results = {};

      for (const endpoint of endpoints) {
        try {
          const response = await apiClient.get(endpoint, {
            params: {companyId},
            timeout: 5000,
          });
          results[endpoint] = {
            status: "success",
            statusCode: response.status,
            data: response.data,
          };
        } catch (error) {
          results[endpoint] = {
            status: "failed",
            statusCode: error.response?.status,
            error: error.message,
          };
        }
      }

      console.log("üî¨ Connection test results:", results);
      return results;
    } catch (error) {
      console.error("‚ùå Connection test failed:", error);
      return {
        error: error.message,
        message: "Failed to test API connection",
      };
    }
  }

  // ==================== HELPER METHODS ====================

  /**
   * Validate order data before submission
   */
  validateOrderData(orderData) {
    const errors = [];

    if (!orderData.companyId) {
      errors.push("Company ID is required");
    }

    if (!orderData.customerName && !orderData.customer) {
      errors.push("Customer name or ID is required");
    }

    if (
      !orderData.items ||
      !Array.isArray(orderData.items) ||
      orderData.items.length === 0
    ) {
      errors.push("At least one item is required");
    }

    if (orderData.items) {
      orderData.items.forEach((item, index) => {
        if (!item.itemName) {
          errors.push(`Item ${index + 1}: Name is required`);
        }
        if (!item.quantity || item.quantity <= 0) {
          errors.push(`Item ${index + 1}: Valid quantity is required`);
        }
        if (!item.pricePerUnit || item.pricePerUnit < 0) {
          errors.push(`Item ${index + 1}: Valid price is required`);
        }
      });
    }

    if (
      orderData.orderType &&
      !["quotation", "sales_order", "proforma_invoice"].includes(
        orderData.orderType
      )
    ) {
      errors.push("Invalid order type");
    }

    return {
      isValid: errors.length === 0,
      errors,
    };
  }

  /**
   * Format order data for API submission
   */
  formatOrderData(orderData) {
    return {
      ...orderData,
      orderType: orderData.orderType || "quotation",
      gstEnabled: orderData.gstEnabled ?? true,
      taxMode: orderData.taxMode || "without-tax",
      priceIncludesTax: orderData.priceIncludesTax ?? false,
      status: orderData.status || "draft",
      priority: orderData.priority || "normal",
      items:
        orderData.items?.map((item, index) => ({
          ...item,
          lineNumber: index + 1,
          taxRate: item.taxRate || 18,
          unit: item.unit || "PCS",
          discountPercent: item.discountPercent || 0,
          discountAmount: item.discountAmount || 0,
        })) || [],
    };
  }

  // ==================== ‚úÖ PAYIN SPECIFIC HELPER METHODS ====================

  /**
   * ‚úÖ Calculate pending amount for an order
   */
  calculatePendingAmount(order) {
    const totalAmount = parseFloat(
      order.totalAmount ||
        order.amount ||
        order.finalTotal ||
        order.grandTotal ||
        0
    );
    const paidAmount = parseFloat(
      order.paidAmount || order.amountPaid || order.receivedAmount || 0
    );
    return Math.max(0, totalAmount - paidAmount);
  }

  /**
   * ‚úÖ Format order for PayIn dropdown display
   */
  formatOrderForPayment(order) {
    const totalAmount = parseFloat(
      order.totalAmount || order.amount || order.finalTotal || 0
    );
    const paidAmount = parseFloat(order.paidAmount || order.amountPaid || 0);
    const pendingAmount = totalAmount - paidAmount;
    const orderNumber =
      order.orderNumber ||
      order.saleNumber ||
      order.quotationNumber ||
      order._id;
    const orderDate =
      order.orderDate ||
      order.saleDate ||
      order.quotationDate ||
      order.createdAt;

    return {
      id: order._id || order.id,
      orderNumber,
      orderDate,
      totalAmount,
      paidAmount,
      pendingAmount,
      displayText: `#${orderNumber} - ‚Çπ${totalAmount.toLocaleString(
        "en-IN"
      )} (Pending: ‚Çπ${pendingAmount.toLocaleString("en-IN")}) - ${new Date(
        orderDate
      ).toLocaleDateString("en-IN")}`,
      order: order,
    };
  }

  /**
   * ‚úÖ Get payment types for PayIn (only 2 options as requested)
   */
  getPaymentTypes() {
    return [
      {
        value: "advance",
        label: "Advance Payment",
        description: "Payment received in advance without specific order",
        icon: "faMoneyBillWave",
      },
      {
        value: "pending",
        label: "Order Payment",
        description: "Payment against a specific sales order",
        icon: "faFileInvoice",
      },
    ];
  }
}

// ‚úÖ Export as singleton instance
export default new SaleOrderService();
