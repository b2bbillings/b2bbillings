import React, {useState, useEffect, useCallback, useMemo} from "react";
import {useParams, useNavigate, useLocation} from "react-router-dom";
import {
  Container,
  Row,
  Col,
  Alert,
  Card,
  Button,
  Tab,
  Nav,
  Badge,
} from "react-bootstrap";
import {FontAwesomeIcon} from "@fortawesome/react-fontawesome";
import {
  faSync,
  faExclamationTriangle,
  faClipboardList,
  faBuilding,
  faFileImport,
  faFileExport,
  faExchangeAlt,
} from "@fortawesome/free-solid-svg-icons";

import SalesOrderTable from "./Sales/SalesOrder/SalesOrderTable";
import SalesInvoicesHeader from "./Sales/SalesInvoice/SalesInvoicesHeader";
import SalesInvoicesPageTitle from "./Sales/SalesInvoice/SalesInvoicesPageTitle";
import SalesInvoicesFilter from "./Sales/SalesInvoice/SalesInvoicesFilter";
import SalesInvoicesSummary from "./Sales/SalesInvoice/SalesInvoicesSummary";
import salesOrderServiceImport from "../../services/saleOrderService";

function Quotations({
  view = "quotations",
  onNavigate,
  currentCompany,
  currentUser,
  isOnline = true,
  addToast,
  companyId: propCompanyId,
  saleOrderService: propSaleOrderService,
}) {
  const {companyId: urlCompanyId} = useParams();
  const navigate = useNavigate();
  const location = useLocation();

  const saleOrderService = propSaleOrderService || salesOrderServiceImport;
  const companyId = propCompanyId || urlCompanyId;

  // State Management
  const [quotations, setQuotations] = useState([]);
  const [ordersFromPO, setOrdersFromPO] = useState([]);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState(null);
  const [searchTerm, setSearchTerm] = useState("");
  const [sortBy, setSortBy] = useState("date");
  const [sortOrder, setSortOrder] = useState("desc");
  const [selectedQuotations, setSelectedQuotations] = useState([]);
  const [filterStatus, setFilterStatus] = useState("");
  const [bidirectionalOrders, setBidirectionalOrders] = useState([]);
  const [showBidirectionalAnalytics, setShowBidirectionalAnalytics] =
    useState(false);
  const [activeTab, setActiveTab] = useState("quotations");

  // Filter states
  const [dateRange, setDateRange] = useState("This Month");
  const [startDate, setStartDate] = useState(
    new Date(new Date().getFullYear(), new Date().getMonth(), 1)
  );
  const [endDate, setEndDate] = useState(new Date());
  const [selectedFirm, setSelectedFirm] = useState("All Companies");

  // Summary state
  const [summary, setSummary] = useState({
    totalQuotations: 0,
    quotationValue: 0,
    approvedValue: 0,
    pendingValue: 0,
    todaysAmount: 0,
    avgValue: 0,
    growthPercentage: 0,
    approvedDocuments: 0,
    pendingDocuments: 0,
    convertedQuotations: 0,
    conversionRate: 0,
    bidirectionalCount: 0,
    autoGeneratedCount: 0,
    sourceCompanyLinkedCount: 0,
  });

  // Date range options
  const dateRangeOptions = [
    "Today",
    "Yesterday",
    "This Week",
    "Last Week",
    "This Month",
    "Last Month",
    "This Quarter",
    "Last Quarter",
    "This Year",
    "Last Year",
    "All Time",
    "Custom Range",
  ];

  const firmOptions = [
    "All Companies",
    currentCompany?.name || "Current Company",
    "Branch Office 1",
    "Branch Office 2",
  ];

  // Combined quotations for display
  const allQuotations = useMemo(() => {
    const combined = [...quotations, ...ordersFromPO];
    const uniqueOrders = combined.filter(
      (order, index, self) =>
        index ===
        self.findIndex((o) => (o._id || o.id) === (order._id || order.id))
    );
    return uniqueOrders;
  }, [quotations, ordersFromPO]);

  // Service validation
  const validateService = useCallback(() => {
    if (!saleOrderService) return false;
    if (typeof saleOrderService.getSalesOrders !== "function") return false;
    return true;
  }, [saleOrderService]);

  // Load quotations with error handling
  const loadQuotations = useCallback(async () => {
    if (!companyId || !validateService()) return;

    try {
      setIsLoading(true);
      setError(null);

      const response = await saleOrderService.getSalesOrders(companyId, {
        orderType: "quotation",
        search: searchTerm || undefined,
        status: filterStatus || undefined,
        sortBy: sortBy || "date",
        sortOrder: sortOrder || "desc",
        startDate: startDate?.toISOString(),
        endDate: endDate?.toISOString(),
        includeCustomer: true,
        includeItems: true,
      });

      if (response.success && response.data) {
        let quotationData = [];

        if (Array.isArray(response.data)) {
          quotationData = response.data;
        } else if (response.data.salesOrders) {
          quotationData = response.data.salesOrders;
        } else if (response.data.quotations) {
          quotationData = response.data.quotations;
        } else if (response.data.orders) {
          quotationData = response.data.orders;
        } else if (response.data.data) {
          if (Array.isArray(response.data.data)) {
            quotationData = response.data.data;
          } else if (response.data.data.salesOrders) {
            quotationData = response.data.data.salesOrders;
          } else if (response.data.data.quotations) {
            quotationData = response.data.data.quotations;
          }
        }

        if (!Array.isArray(quotationData)) {
          quotationData = [];
        }

        setQuotations(quotationData);

        // Calculate summary
        const total = quotationData.length;
        const totalValue = quotationData.reduce((sum, q) => {
          const amount = parseFloat(
            q.amount ||
              q.totalAmount ||
              q.totals?.finalTotal ||
              q.totals?.grandTotal ||
              q.grandTotal ||
              0
          );
          return sum + (isNaN(amount) ? 0 : amount);
        }, 0);

        const approved = quotationData.filter(
          (q) => q.status === "approved" || q.status === "accepted"
        ).length;

        const pending = quotationData.filter(
          (q) =>
            q.status === "pending" ||
            q.status === "draft" ||
            q.status === "sent"
        ).length;

        const approvedValue = quotationData
          .filter((q) => q.status === "approved" || q.status === "accepted")
          .reduce((sum, q) => {
            const amount = parseFloat(
              q.amount ||
                q.totalAmount ||
                q.totals?.finalTotal ||
                q.totals?.grandTotal ||
                q.grandTotal ||
                0
            );
            return sum + (isNaN(amount) ? 0 : amount);
          }, 0);

        const pendingValue = quotationData
          .filter(
            (q) =>
              q.status === "pending" ||
              q.status === "draft" ||
              q.status === "sent"
          )
          .reduce((sum, q) => {
            const amount = parseFloat(
              q.amount ||
                q.totalAmount ||
                q.totals?.finalTotal ||
                q.totals?.grandTotal ||
                q.grandTotal ||
                0
            );
            return sum + (isNaN(amount) ? 0 : amount);
          }, 0);

        setSummary((prev) => ({
          ...prev,
          totalQuotations: total,
          quotationValue: totalValue,
          approvedDocuments: approved,
          pendingDocuments: pending,
          approvedValue: approvedValue,
          pendingValue: pendingValue,
          avgValue: total > 0 ? totalValue / total : 0,
        }));
      } else {
        setQuotations([]);
      }
    } catch (error) {
      setError(error.message);
      addToast?.("Failed to load quotations", "error");
      setQuotations([]);
    } finally {
      setIsLoading(false);
    }
  }, [
    companyId,
    searchTerm,
    filterStatus,
    sortBy,
    sortOrder,
    startDate,
    endDate,
    saleOrderService,
    addToast,
    validateService,
  ]);

  // Load orders from purchase orders
  const loadOrdersFromPO = useCallback(async () => {
    if (!companyId || !validateService()) return;

    try {
      const response = await saleOrderService.getSalesOrders(companyId, {
        isAutoGenerated: true,
        sourceOrderType: "purchase_order",
        orderType: "quotation",
        includeCustomer: true,
      });

      if (response.success && response.data) {
        let ordersData = [];

        if (Array.isArray(response.data)) {
          ordersData = response.data;
        } else if (response.data.salesOrders) {
          ordersData = response.data.salesOrders;
        } else if (response.data.orders) {
          ordersData = response.data.orders;
        } else if (response.data.data) {
          if (Array.isArray(response.data.data)) {
            ordersData = response.data.data;
          } else if (response.data.data.salesOrders) {
            ordersData = response.data.data.salesOrders;
          }
        }

        if (!Array.isArray(ordersData)) {
          ordersData = [];
        }

        setOrdersFromPO(ordersData);
        setSummary((prev) => ({
          ...prev,
          autoGeneratedCount: ordersData.length,
        }));
      }
    } catch (error) {
      setOrdersFromPO([]);
    }
  }, [companyId, saleOrderService, validateService]);

  // Load bidirectional analytics
  const loadBidirectionalAnalytics = useCallback(async () => {
    if (!companyId || !validateService()) return;

    try {
      const response = await saleOrderService.getSalesOrders(companyId, {
        hasBidirectionalTracking: true,
        orderType: "quotation",
        includeTracking: true,
      });

      if (response.success && response.data) {
        const bidirectionalData = Array.isArray(response.data)
          ? response.data
          : response.data.salesOrders || [];
        setBidirectionalOrders(bidirectionalData);

        setSummary((prev) => ({
          ...prev,
          bidirectionalCount: bidirectionalData.length,
          sourceCompanyLinkedCount: bidirectionalData.filter(
            (o) => o.sourceCompanyId
          ).length,
        }));
      }
    } catch (error) {
      // Silent fail for optional feature
    }
  }, [companyId, saleOrderService, validateService]);

  // Effects
  useEffect(() => {
    loadQuotations();
    loadOrdersFromPO();
    loadBidirectionalAnalytics();
  }, [loadQuotations, loadOrdersFromPO, loadBidirectionalAnalytics]);

  // Action handlers
  const handleAddQuotation = useCallback(() => {
    const createPath = `/companies/${companyId}/sales-orders/add`;
    navigate(createPath, {
      state: {
        orderType: "quotation",
        documentType: "quotation",
        mode: "quotations",
        returnPath: location.pathname,
        defaultOrderType: "quotation",
      },
    });
  }, [companyId, navigate, location.pathname]);

  const handleViewQuotation = useCallback((quotation) => {
    // Implementation for viewing quotation details
  }, []);

  const handleEditQuotation = useCallback(
    (quotation) => {
      const quotationId = quotation._id || quotation.id;

      if (!quotationId) {
        addToast?.("Cannot edit quotation: Invalid quotation data", "error");
        return;
      }

      const editPath = `/companies/${companyId}/sales-orders/${quotationId}/edit`;

      navigate(editPath, {
        state: {
          salesOrder: quotation,
          order: quotation,
          quotation: quotation,
          transaction: quotation,
          orderType: "quotation",
          documentType: "quotation",
          mode: "quotations",
          returnPath: location.pathname,
          editMode: true,
          isEdit: true,
          defaultOrderType: "quotation",
          apiEndpoint: "sales-orders",
          updateRoute: `/api/sales-orders/${quotationId}`,
          editContext: {
            source: "Quotations",
            timestamp: new Date().toISOString(),
            companyId: companyId,
            userId: currentUser?.id || currentUser?._id,
            isQuotationsMode: true,
            apiRoute: `/api/sales-orders/${quotationId}`,
          },
        },
      });
    },
    [companyId, location.pathname, navigate, currentUser, addToast]
  );

  const handleDeleteQuotation = useCallback(
    async (quotation) => {
      const quotationNumber =
        quotation.quotationNumber || quotation.orderNumber || quotation._id;

      const confirmed = window.confirm(
        `Are you sure you want to delete quotation ${quotationNumber}?\n\nThis action cannot be undone.`
      );

      if (!confirmed) return;

      try {
        setIsLoading(true);

        const response = await saleOrderService.deleteSalesOrder(
          quotation._id || quotation.id
        );

        if (response.success) {
          addToast?.(
            `Quotation ${quotationNumber} deleted successfully`,
            "success"
          );
          await Promise.all([
            loadQuotations(),
            loadOrdersFromPO(),
            loadBidirectionalAnalytics(),
          ]);
        } else {
          throw new Error(
            response.message || response.error || "Failed to delete quotation"
          );
        }
      } catch (error) {
        addToast?.(`Failed to delete quotation: ${error.message}`, "error");
      } finally {
        setIsLoading(false);
      }
    },
    [
      saleOrderService,
      addToast,
      loadQuotations,
      loadOrdersFromPO,
      loadBidirectionalAnalytics,
    ]
  );

  const handleConvertQuotation = useCallback(
    async (quotation) => {
      const quotationNumber =
        quotation.quotationNumber || quotation.orderNumber || quotation._id;

      const confirmed = window.confirm(
        `Convert quotation ${quotationNumber} to sales order?\n\nThis will create a new sales order based on this quotation.`
      );

      if (!confirmed) return;

      try {
        setIsLoading(true);

        const response = await saleOrderService.convertToInvoice(
          quotation._id || quotation.id,
          {
            convertToOrderType: "sales_order",
            preserveItems: true,
            preservePricing: true,
            preserveTerms: true,
            convertedBy: currentUser?._id || currentUser?.id,
            convertedByName: currentUser?.name || currentUser?.username,
            conversionReason: "quotation_to_sales_order",
          }
        );

        if (response.success) {
          addToast?.(
            `Quotation ${quotationNumber} converted to sales order successfully`,
            "success"
          );
          await loadQuotations();

          if (response.data?.order?._id) {
            const salesOrderPath = `/companies/${companyId}/sales-orders/${response.data.order._id}/view`;
            navigate(salesOrderPath, {
              state: {
                salesOrder: response.data.order,
                documentType: "sales_order",
                mode: "sales-orders",
                returnPath: location.pathname,
                converted: true,
                originalQuotation: quotation,
              },
            });
          }
        } else {
          throw new Error(
            response.message || response.error || "Conversion failed"
          );
        }
      } catch (error) {
        addToast?.(`Failed to convert quotation: ${error.message}`, "error");
      } finally {
        setIsLoading(false);
      }
    },
    [
      saleOrderService,
      addToast,
      loadQuotations,
      currentUser,
      companyId,
      navigate,
      location.pathname,
    ]
  );

  const handleDuplicateQuotation = useCallback(
    (quotation) => {
      const createPath = `/companies/${companyId}/sales-orders/add`;
      navigate(createPath, {
        state: {
          duplicateData: quotation,
          isDuplicate: true,
          originalQuotation: quotation,
          orderType: "quotation",
          documentType: "quotation",
          mode: "quotations",
          returnPath: location.pathname,
          defaultOrderType: "quotation",
        },
      });
    },
    [companyId, navigate, location.pathname]
  );

  const handlePrintQuotation = useCallback(
    async (quotation) => {
      try {
        const response = await saleOrderService.getSalesOrderForPrint?.(
          quotation._id || quotation.id,
          {
            template: "quotation",
            format: "a4",
          }
        );

        if (response && response.success) {
          return response;
        }
      } catch (error) {
        addToast?.(`Failed to print quotation: ${error.message}`, "error");
      }
    },
    [saleOrderService, addToast]
  );

  const handleShareQuotation = useCallback(
    async (quotation) => {
      try {
        const quotationNumber =
          quotation.quotationNumber || quotation.orderNumber || quotation._id;

        const response = await saleOrderService.shareOrder?.(
          quotation._id || quotation.id,
          {
            method: "email",
          }
        );

        if (response && response.success) {
          addToast?.(
            `Quotation ${quotationNumber} shared successfully`,
            "success"
          );
        }
      } catch (error) {
        addToast?.(`Failed to share quotation: ${error.message}`, "error");
      }
    },
    [saleOrderService, addToast]
  );

  const handleDownloadQuotation = useCallback(
    async (quotation) => {
      try {
        const quotationNumber =
          quotation.quotationNumber || quotation.orderNumber || quotation._id;

        const response = await saleOrderService.downloadSalesOrderPDF?.(
          quotation._id || quotation.id,
          {
            template: "quotation",
            format: "pdf",
          }
        );

        if (response && response.success) {
          addToast?.(
            `Quotation ${quotationNumber} downloaded successfully`,
            "success"
          );
        }
      } catch (error) {
        addToast?.(`Failed to download quotation: ${error.message}`, "error");
      }
    },
    [saleOrderService, addToast]
  );

  const handleViewTrackingChain = useCallback(
    async (quotation) => {
      try {
        const quotationNumber =
          quotation.quotationNumber || quotation.orderNumber || quotation._id;

        const response = await saleOrderService.getTrackingChain(
          quotation._id || quotation.id
        );

        if (response.success) {
          const trackingPath = `/companies/${companyId}/sales-orders/${
            quotation._id || quotation.id
          }/tracking`;
          navigate(trackingPath, {
            state: {
              quotation: quotation,
              trackingChain: response.data,
              documentType: "quotation",
              mode: "quotations",
              returnPath: location.pathname,
            },
          });
        } else {
          addToast?.(
            `No tracking information found for quotation ${quotationNumber}`,
            "warning"
          );
        }
      } catch (error) {
        addToast?.(`Failed to load tracking chain: ${error.message}`, "error");
      }
    },
    [saleOrderService, companyId, navigate, location.pathname, addToast]
  );

  const handleViewSourceOrder = useCallback(
    (quotation) => {
      if (
        quotation.sourceOrderId &&
        quotation.sourceOrderType === "purchase_order"
      ) {
        const sourcePath = `/companies/${
          quotation.sourceCompanyId || companyId
        }/purchase-orders/${quotation.sourceOrderId}/view`;
        navigate(sourcePath, {
          state: {
            returnPath: location.pathname,
            sourceQuotation: quotation,
          },
        });
      } else {
        addToast?.("No source order found for this quotation", "warning");
      }
    },
    [companyId, navigate, location.pathname, addToast]
  );

  const handleViewGeneratedOrders = useCallback(
    async (quotation) => {
      try {
        const generatedOrdersPath = `/companies/${companyId}/sales-orders/${
          quotation._id || quotation.id
        }/generated-orders`;
        navigate(generatedOrdersPath, {
          state: {
            quotation: quotation,
            documentType: "quotation",
            mode: "quotations",
            returnPath: location.pathname,
          },
        });
      } catch (error) {
        addToast?.(
          `Failed to load generated orders: ${error.message}`,
          "error"
        );
      }
    },
    [companyId, navigate, location.pathname, addToast]
  );

  const handleCancelQuotation = useCallback(
    async (quotation) => {
      const quotationNumber =
        quotation.quotationNumber || quotation.orderNumber || quotation._id;

      const confirmed = window.confirm(
        `Are you sure you want to cancel quotation ${quotationNumber}?`
      );

      if (!confirmed) return;

      try {
        const response = await saleOrderService.cancelOrder(
          quotation._id || quotation.id
        );

        if (response.success) {
          addToast?.(
            `Quotation ${quotationNumber} cancelled successfully`,
            "success"
          );
          await Promise.all([loadQuotations(), loadBidirectionalAnalytics()]);
        } else {
          throw new Error(response.message);
        }
      } catch (error) {
        addToast?.(`Failed to cancel quotation: ${error.message}`, "error");
      }
    },
    [saleOrderService, addToast, loadQuotations, loadBidirectionalAnalytics]
  );

  const handleGeneratePurchaseOrder = useCallback(
    async (quotation) => {
      const quotationNumber =
        quotation.quotationNumber || quotation.orderNumber || quotation._id;

      const confirmed = window.confirm(
        `Generate Purchase Order from quotation ${quotationNumber}?\n\nThis will create a corresponding purchase order.`
      );

      if (!confirmed) return;

      try {
        setIsLoading(true);

        const response = await saleOrderService.generatePurchaseOrder(
          quotation._id || quotation.id,
          {
            preserveItems: true,
            preservePricing: true,
            preserveTerms: true,
            generatedBy: currentUser?._id || currentUser?.id,
            generatedByName: currentUser?.name || currentUser?.username,
            generationReason: "quotation_to_purchase_order",
          }
        );

        if (response.success) {
          addToast?.(
            `Purchase Order generated from quotation ${quotationNumber} successfully`,
            "success"
          );
          await loadQuotations();

          if (response.data?.purchaseOrder?._id) {
            const purchaseOrderPath = `/companies/${companyId}/purchase-orders/${response.data.purchaseOrder._id}/view`;
            navigate(purchaseOrderPath, {
              state: {
                purchaseOrder: response.data.purchaseOrder,
                documentType: "purchase-order",
                mode: "purchase-orders",
                returnPath: location.pathname,
                generated: true,
                originalQuotation: quotation,
              },
            });
          }
        } else {
          throw new Error(
            response.message ||
              response.error ||
              "Purchase Order generation failed"
          );
        }
      } catch (error) {
        addToast?.(
          `Failed to generate Purchase Order: ${error.message}`,
          "error"
        );
      } finally {
        setIsLoading(false);
      }
    },
    [
      saleOrderService,
      currentUser,
      addToast,
      loadQuotations,
      companyId,
      navigate,
      location.pathname,
    ]
  );

  // Filter handlers
  const handleDateRangeChange = useCallback((range) => {
    setDateRange(range);
    const today = new Date();

    switch (range) {
      case "Today":
        setStartDate(new Date(today.setHours(0, 0, 0, 0)));
        setEndDate(new Date(today.setHours(23, 59, 59, 999)));
        break;
      case "Yesterday":
        const yesterday = new Date(today);
        yesterday.setDate(today.getDate() - 1);
        setStartDate(new Date(yesterday.setHours(0, 0, 0, 0)));
        setEndDate(new Date(yesterday.setHours(23, 59, 59, 999)));
        break;
      case "This Week":
        const startOfWeek = new Date(today);
        startOfWeek.setDate(today.getDate() - today.getDay());
        setStartDate(new Date(startOfWeek.setHours(0, 0, 0, 0)));
        setEndDate(new Date(today.setHours(23, 59, 59, 999)));
        break;
      case "This Month":
        setStartDate(new Date(today.getFullYear(), today.getMonth(), 1));
        setEndDate(
          new Date(
            today.getFullYear(),
            today.getMonth() + 1,
            0,
            23,
            59,
            59,
            999
          )
        );
        break;
      case "Last Month":
        const lastMonth = new Date(
          today.getFullYear(),
          today.getMonth() - 1,
          1
        );
        const lastMonthEnd = new Date(
          today.getFullYear(),
          today.getMonth(),
          0,
          23,
          59,
          59,
          999
        );
        setStartDate(lastMonth);
        setEndDate(lastMonthEnd);
        break;
      case "This Quarter":
        const quarterStart = new Date(
          today.getFullYear(),
          Math.floor(today.getMonth() / 3) * 3,
          1
        );
        setStartDate(quarterStart);
        setEndDate(
          new Date(
            today.getFullYear(),
            Math.floor(today.getMonth() / 3) * 3 + 3,
            0,
            23,
            59,
            59,
            999
          )
        );
        break;
      case "This Year":
        setStartDate(new Date(today.getFullYear(), 0, 1));
        setEndDate(new Date(today.getFullYear(), 11, 31, 23, 59, 59, 999));
        break;
      case "All Time":
        setStartDate(new Date(2020, 0, 1));
        setEndDate(new Date());
        break;
      case "Custom Range":
        break;
      default:
        break;
    }
  }, []);

  const handleStartDateChange = useCallback((e) => {
    setStartDate(new Date(e.target.value));
    setDateRange("Custom Range");
  }, []);

  const handleEndDateChange = useCallback((e) => {
    setEndDate(new Date(e.target.value));
    setDateRange("Custom Range");
  }, []);

  const handleFirmChange = useCallback((firm) => {
    setSelectedFirm(firm);
  }, []);

  const handleSearchChange = useCallback((e) => {
    const searchValue = typeof e === "string" ? e : e?.target?.value || "";
    setSearchTerm(searchValue);
  }, []);

  const handleSort = useCallback(
    (field) => {
      if (sortBy === field) {
        setSortOrder((prev) => (prev === "asc" ? "desc" : "asc"));
      } else {
        setSortBy(field);
        setSortOrder("asc");
      }
    },
    [sortBy]
  );

  const handleFilterChange = useCallback((status) => {
    setFilterStatus(status);
  }, []);

  const handleRefresh = useCallback(() => {
    loadQuotations();
    loadOrdersFromPO();
    loadBidirectionalAnalytics();
  }, [loadQuotations, loadOrdersFromPO, loadBidirectionalAnalytics]);

  // Validation states
  if (!companyId) {
    return (
      <div className="quotations-error-container">
        <Container fluid>
          <Alert variant="warning" className="text-center">
            <h5>‚ö†Ô∏è No Company Selected</h5>
            <p className="mb-0">
              Please select a company to view and manage quotations.
            </p>
          </Alert>
        </Container>
      </div>
    );
  }

  if (!isOnline) {
    return (
      <div className="quotations-error-container">
        <Container fluid>
          <Alert variant="warning" className="text-center">
            <h5>üì° No Internet Connection</h5>
            <p className="mb-0">
              Quotations data requires an internet connection.
            </p>
          </Alert>
        </Container>
      </div>
    );
  }

  if (!validateService()) {
    return (
      <div className="quotations-error-container">
        <Container fluid>
          <Alert variant="danger" className="text-center">
            <h5>üîß Service Unavailable</h5>
            <p className="mb-0">
              Sales order service is not available. Please check your
              configuration.
            </p>
            <Button
              variant="outline-danger"
              size="sm"
              className="mt-2"
              onClick={() => window.location.reload()}
            >
              <FontAwesomeIcon icon={faSync} className="me-1" /> Reload Page
            </Button>
          </Alert>
        </Container>
      </div>
    );
  }

  return (
    <div className="quotations-main-container">
      {/* Header - Fixed */}
      <div className="quotations-header-fixed">
        <SalesInvoicesHeader
          searchTerm={searchTerm}
          onSearchChange={handleSearchChange}
          onAddSale={handleAddQuotation}
          onAddPurchase={() => {}}
          onMoreOptions={() => addToast?.("More options coming soon", "info")}
          onSettings={() => addToast?.("Settings coming soon", "info")}
          pageTitle="Quotations"
          companyId={companyId}
          currentCompany={currentCompany}
          addToast={addToast}
          onNavigate={onNavigate}
        />
      </div>

      {/* Scrollable Content */}
      <div className="quotations-content-scrollable">
        <Container fluid className="quotations-container">
          {/* Page Title */}
          <div className="quotations-page-title">
            <SalesInvoicesPageTitle
              onAddSale={handleAddQuotation}
              invoiceCount={allQuotations.length}
              companyId={companyId}
              mode="quotations"
              documentType="quotation"
              title="Quotations"
              subtitle="Create and manage professional quotations for your clients"
            />
          </div>

          {/* Filters */}
          <Row className="mb-3">
            <Col xs={12}>
              <SalesInvoicesFilter
                dateRange={dateRange}
                startDate={startDate}
                endDate={endDate}
                selectedFirm={selectedFirm}
                dateRangeOptions={dateRangeOptions}
                firmOptions={firmOptions}
                onDateRangeChange={handleDateRangeChange}
                onStartDateChange={handleStartDateChange}
                onEndDateChange={handleEndDateChange}
                onFirmChange={handleFirmChange}
                onExcelExport={() =>
                  addToast?.("Excel export coming soon", "info")
                }
                onPrint={() => addToast?.("Print coming soon", "info")}
                resultCount={allQuotations.length}
                mode="quotations"
                documentType="quotation"
                pageTitle="Quotations"
                showBidirectionalFilters={true}
                onToggleBidirectionalAnalytics={() =>
                  setShowBidirectionalAnalytics(!showBidirectionalAnalytics)
                }
                showBidirectionalAnalytics={showBidirectionalAnalytics}
              />
            </Col>
          </Row>

          {/* Main Content */}
          <Row className="g-3">
            {/* Summary Sidebar */}
            <Col xl={2} lg={3} md={3} sm={12}>
              <SalesInvoicesSummary
                summary={summary}
                loading={isLoading}
                dateRange={dateRange}
                mode="quotations"
                documentType="quotation"
                isQuotationsMode={true}
                showBidirectionalMetrics={true}
                bidirectionalCount={summary.bidirectionalCount}
                autoGeneratedCount={summary.autoGeneratedCount}
                sourceCompanyLinkedCount={summary.sourceCompanyLinkedCount}
              />
            </Col>

            {/* Main Content Area */}
            <Col xl={10} lg={9} md={9} sm={12}>
              {/* Error Display */}
              {error && (
                <Alert variant="danger" className="mb-3">
                  <FontAwesomeIcon
                    icon={faExclamationTriangle}
                    className="me-2"
                  />
                  {error}
                  <Button
                    variant="outline-danger"
                    size="sm"
                    className="ms-2"
                    onClick={() => {
                      setError(null);
                      handleRefresh();
                    }}
                  >
                    <FontAwesomeIcon icon={faSync} className="me-1" /> Retry
                  </Button>
                </Alert>
              )}

              {/* Tabs */}
              <Tab.Container
                activeKey={activeTab}
                onSelect={(k) => setActiveTab(k)}
              >
                <Nav variant="tabs" className="mb-0 quotations-tabs">
                  <Nav.Item>
                    <Nav.Link eventKey="quotations">
                      <FontAwesomeIcon
                        icon={faClipboardList}
                        className="me-2"
                      />
                      Quotations ({quotations.length})
                    </Nav.Link>
                  </Nav.Item>
                  <Nav.Item>
                    <Nav.Link eventKey="fromBuyers">
                      <FontAwesomeIcon icon={faBuilding} className="me-2" />
                      From Buyers (
                      {summary.autoGeneratedCount + summary.bidirectionalCount})
                    </Nav.Link>
                  </Nav.Item>
                </Nav>

                <Tab.Content className="quotations-tab-content">
                  {/* All Quotations Tab */}
                  <Tab.Pane eventKey="quotations">
                    <Card className="quotations-card">
                      <Card.Body className="p-0">
                        <SalesOrderTable
                          salesOrders={quotations}
                          onViewOrder={handleViewQuotation}
                          onEditOrder={handleEditQuotation}
                          onDeleteOrder={handleDeleteQuotation}
                          onPrintOrder={handlePrintQuotation}
                          onShareOrder={handleShareQuotation}
                          onDownloadOrder={handleDownloadQuotation}
                          onConvertOrder={handleConvertQuotation}
                          onDuplicateOrder={handleDuplicateQuotation}
                          onGeneratePurchaseOrder={handleGeneratePurchaseOrder}
                          isLoading={isLoading}
                          title="Quotations"
                          searchPlaceholder="Search quotations, customers, mobile..."
                          companyId={companyId}
                          addToast={addToast}
                          currentUser={currentUser}
                          currentCompany={currentCompany}
                          searchTerm={searchTerm}
                          onSearchChange={handleSearchChange}
                          sortBy={sortBy}
                          sortOrder={sortOrder}
                          onSort={handleSort}
                          filterStatus={filterStatus}
                          onFilterChange={handleFilterChange}
                          showHeader={false}
                          enableActions={true}
                          enableBulkActions={true}
                          selectedOrders={selectedQuotations}
                          onSelectionChange={setSelectedQuotations}
                          showBidirectionalColumns={true}
                          documentType="quotation"
                          isQuotationsMode={true}
                          saleOrderService={saleOrderService}
                          onCancelOrder={handleCancelQuotation}
                          onViewTrackingChain={handleViewTrackingChain}
                          onViewSourceOrder={handleViewSourceOrder}
                          onViewGeneratedOrders={handleViewGeneratedOrders}
                          enableEnhancedTracking={true}
                          showSourceCompanyColumn={true}
                          showGeneratedOrdersColumn={false}
                          enableQuickNavigation={true}
                          refreshTrigger={`${quotations.length}-${ordersFromPO.length}`}
                        />
                      </Card.Body>
                    </Card>
                  </Tab.Pane>

                  {/* From Buyers Tab */}
                  <Tab.Pane eventKey="fromBuyers">
                    <Card className="quotations-card">
                      <Card.Header className="bg-light">
                        <div className="d-flex align-items-center justify-content-between">
                          <h5 className="mb-0">
                            <FontAwesomeIcon
                              icon={faBuilding}
                              className="me-2 text-primary"
                            />
                            Quotations From Buyers
                          </h5>
                          <Badge bg="info" className="fs-6">
                            {summary.autoGeneratedCount +
                              summary.bidirectionalCount}{" "}
                            Active
                          </Badge>
                        </div>
                      </Card.Header>
                      <Card.Body>
                        {/* Stats Cards */}
                        <Row className="mb-3">
                          <Col md={4}>
                            <Card className="text-center border-info quotations-stat-card">
                              <Card.Body className="py-2">
                                <FontAwesomeIcon
                                  icon={faFileImport}
                                  className="text-info mb-1"
                                />
                                <h6 className="text-info mb-1">
                                  {summary.autoGeneratedCount}
                                </h6>
                                <small className="text-muted">
                                  Auto-Generated from Purchase Orders
                                </small>
                              </Card.Body>
                            </Card>
                          </Col>
                          <Col md={4}>
                            <Card className="text-center border-success quotations-stat-card">
                              <Card.Body className="py-2">
                                <FontAwesomeIcon
                                  icon={faFileExport}
                                  className="text-success mb-1"
                                />
                                <h6 className="text-success mb-1">
                                  {summary.convertedQuotations}
                                </h6>
                                <small className="text-muted">
                                  Converted to Orders
                                </small>
                              </Card.Body>
                            </Card>
                          </Col>
                          <Col md={4}>
                            <Card className="text-center border-warning quotations-stat-card">
                              <Card.Body className="py-2">
                                <FontAwesomeIcon
                                  icon={faExchangeAlt}
                                  className="text-warning mb-1"
                                />
                                <h6 className="text-warning mb-1">
                                  {summary.bidirectionalCount}
                                </h6>
                                <small className="text-muted">
                                  From Purchase Orders
                                </small>
                              </Card.Body>
                            </Card>
                          </Col>
                        </Row>

                        {/* From Buyers Table */}
                        <SalesOrderTable
                          salesOrders={ordersFromPO}
                          onViewOrder={handleViewQuotation}
                          onEditOrder={handleEditQuotation}
                          onDeleteOrder={handleDeleteQuotation}
                          onPrintOrder={handlePrintQuotation}
                          onShareOrder={handleShareQuotation}
                          onDownloadOrder={handleDownloadQuotation}
                          onConvertOrder={handleConvertQuotation}
                          onDuplicateOrder={handleDuplicateQuotation}
                          onGeneratePurchaseOrder={handleGeneratePurchaseOrder}
                          isLoading={isLoading}
                          title="Quotations From Buyers"
                          searchPlaceholder="Search buyer quotations..."
                          companyId={companyId}
                          addToast={addToast}
                          currentUser={currentUser}
                          currentCompany={currentCompany}
                          showHeader={false}
                          enableActions={true}
                          enableBulkActions={false}
                          showBidirectionalColumns={true}
                          documentType="quotation"
                          isQuotationsMode={true}
                          saleOrderService={saleOrderService}
                          onCancelOrder={handleCancelQuotation}
                          onViewTrackingChain={handleViewTrackingChain}
                          onViewSourceOrder={handleViewSourceOrder}
                          onViewGeneratedOrders={handleViewGeneratedOrders}
                          enableEnhancedTracking={true}
                          showSourceCompanyColumn={true}
                          showGeneratedOrdersColumn={true}
                          enableQuickNavigation={true}
                        />
                      </Card.Body>
                    </Card>
                  </Tab.Pane>
                </Tab.Content>
              </Tab.Container>
            </Col>
          </Row>
        </Container>
      </div>

      {/* Production-ready styles */}
      <style>{`
        .quotations-main-container {
          width: 100%;
          height: 100vh;
          background-color: #f8f9fa;
          margin: 0;
          padding: 0;
          display: flex;
          flex-direction: column;
          overflow: hidden;
          font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
        }

        .quotations-header-fixed {
          flex-shrink: 0;
          z-index: 1000;
        }

        .quotations-content-scrollable {
          flex: 1;
          overflow: auto;
          padding: 0;
          margin: 0;
          height: 0;
        }

        .quotations-container {
          padding: 1rem 1.5rem 2rem;
          margin: 0;
          overflow: visible;
        }

        .quotations-page-title {
          margin-bottom: 1rem;
        }

        .quotations-error-container {
          width: 100%;
          height: 100vh;
          background-color: #f8f9fa;
          margin: 0;
          padding: 1rem;
          display: flex;
          align-items: center;
          justify-content: center;
        }

        .quotations-tabs .nav-link {
          border-radius: 0.375rem 0.375rem 0 0 !important;
          font-weight: 500;
          color: #6c757d;
          transition: all 0.15s ease-in-out;
        }

        .quotations-tabs .nav-link:hover {
          border-color: #e9ecef #e9ecef #dee2e6;
          color: #495057;
        }

        .quotations-tabs .nav-link.active {
          color: #495057;
          background-color: #fff;
          border-color: #dee2e6 #dee2e6 #fff;
          font-weight: 600;
        }

        .quotations-tab-content {
          border: 1px solid #dee2e6;
          border-top: none;
          border-radius: 0 0 0.375rem 0.375rem;
          background: white;
        }

        .quotations-card {
          border: none;
          box-shadow: 0 0.125rem 0.25rem rgba(0, 0, 0, 0.075);
          transition: all 0.15s ease-in-out;
        }

        .quotations-card:hover {
          box-shadow: 0 0.5rem 1rem rgba(0, 0, 0, 0.15);
        }

        .quotations-stat-card {
          transition: all 0.15s ease-in-out;
        }

        .quotations-stat-card:hover {
          transform: translateY(-2px);
          box-shadow: 0 0.25rem 0.5rem rgba(0, 0, 0, 0.1);
        }

        .quotations-stat-card .card-body {
          padding: 0.75rem !important;
        }

        .quotations-stat-card h6 {
          font-size: 1.1rem !important;
          margin-bottom: 0.25rem !important;
          font-weight: 600 !important;
        }

        .quotations-stat-card small {
          font-size: 0.75rem !important;
          line-height: 1.2 !important;
        }

        .quotations-stat-card .fa-icon {
          font-size: 1.2rem;
        }

        .alert {
          border: none !important;
          font-weight: 500;
          border-radius: 0.375rem !important;
        }

        .btn {
          border-radius: 0.375rem !important;
          transition: all 0.15s ease-in-out;
        }

        .btn:hover {
          transform: translateY(-1px);
        }

        .badge {
          font-weight: 600;
          letter-spacing: 0.025em;
          border-radius: 0.25rem !important;
        }

        .card {
          border-radius: 0.375rem !important;
        }

        .form-control,
        .form-select {
          border-radius: 0.375rem !important;
        }

        .form-control:focus,
        .form-select:focus {
          border-color: #86b7fe;
          outline: 0;
          box-shadow: 0 0 0 0.25rem rgba(13, 110, 253, 0.25);
        }

        .text-muted {
          color: #6c757d !important;
        }

        /* Scrollbar styling */
        .quotations-content-scrollable::-webkit-scrollbar {
          width: 8px;
        }

        .quotations-content-scrollable::-webkit-scrollbar-track {
          background: #f1f1f1;
        }

        .quotations-content-scrollable::-webkit-scrollbar-thumb {
          background: #c1c1c1;
          border-radius: 4px;
        }

        .quotations-content-scrollable::-webkit-scrollbar-thumb:hover {
          background: #a1a1a1;
        }

        /* Mobile responsiveness */
        @media (max-width: 768px) {
          .quotations-container {
            padding: 0.75rem;
          }

          .quotations-page-title {
            margin-bottom: 0.75rem;
          }

          .quotations-tabs .nav-link {
            padding: 0.5rem 0.75rem;
            font-size: 0.875rem;
          }

          .quotations-stat-card .card-body {
            padding: 0.5rem !important;
          }

          .quotations-stat-card h6 {
            font-size: 1rem !important;
          }

          .quotations-stat-card small {
            font-size: 0.7rem !important;
          }

          .g-3 {
            gap: 0.75rem !important;
          }
        }

        @media (max-width: 576px) {
          .quotations-container {
            padding: 0.5rem;
          }

          .quotations-tabs .nav-link {
            padding: 0.375rem 0.5rem;
            font-size: 0.8rem;
          }

          .btn-sm {
            padding: 0.25rem 0.5rem;
            font-size: 0.775rem;
          }

          .quotations-stat-card .card-body {
            padding: 0.375rem !important;
          }
        }

        /* Fix for footer overlap */
        .quotations-content-scrollable {
          padding-bottom: 60px;
        }

        /* Ensure proper spacing from footer */
        @media (max-width: 768px) {
          .quotations-content-scrollable {
            padding-bottom: 80px;
          }
        }
      `}</style>
    </div>
  );
}

export default Quotations;
