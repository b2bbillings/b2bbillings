import React, {useState, useEffect, useCallback, useMemo} from "react";
import {useParams, useNavigate, useLocation} from "react-router-dom";
import {
  Container,
  Row,
  Col,
  Alert,
  Card,
  Button,
  Tab,
  Nav,
  Badge,
} from "react-bootstrap";
import {FontAwesomeIcon} from "@fortawesome/react-fontawesome";
import {
  faSync,
  faExclamationTriangle,
  faClipboardList,
  faBuilding,
  faFileImport,
  faFileExport,
  faExchangeAlt,
} from "@fortawesome/free-solid-svg-icons";

import SalesOrderTable from "./Sales/SalesOrder/SalesOrderTable";
import SalesInvoicesHeader from "./Sales/SalesInvoice/SalesInvoicesHeader";
import SalesInvoicesPageTitle from "./Sales/SalesInvoice/SalesInvoicesPageTitle";
import SalesInvoicesFilter from "./Sales/SalesInvoice/SalesInvoicesFilter";
import SalesInvoicesSummary from "./Sales/SalesInvoice/SalesInvoicesSummary";
import salesOrderServiceImport from "../../services/saleOrderService";

function Quotations({
  view = "quotations",
  onNavigate,
  currentCompany,
  currentUser,
  isOnline = true,
  addToast,
  companyId: propCompanyId,
  saleOrderService: propSaleOrderService,
}) {
  const {companyId: urlCompanyId} = useParams();
  const navigate = useNavigate();
  const location = useLocation();

  const saleOrderService = propSaleOrderService || salesOrderServiceImport;

  const [quotations, setQuotations] = useState([]);
  const [ordersFromPO, setOrdersFromPO] = useState([]);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState(null);
  const [searchTerm, setSearchTerm] = useState("");
  const [sortBy, setSortBy] = useState("date");
  const [sortOrder, setSortOrder] = useState("desc");
  const [selectedQuotations, setSelectedQuotations] = useState([]);
  const [filterStatus, setFilterStatus] = useState("");
  const [bidirectionalOrders, setBidirectionalOrders] = useState([]);
  const [showBidirectionalAnalytics, setShowBidirectionalAnalytics] =
    useState(false);
  const [activeTab, setActiveTab] = useState("quotations");
  const [dateRange, setDateRange] = useState("This Month");
  const [startDate, setStartDate] = useState(
    new Date(new Date().getFullYear(), new Date().getMonth(), 1)
  );
  const [endDate, setEndDate] = useState(new Date());
  const [selectedFirm, setSelectedFirm] = useState("All Companies");
  const [summary, setSummary] = useState({
    totalQuotations: 0,
    quotationValue: 0,
    approvedValue: 0,
    pendingValue: 0,
    todaysAmount: 0,
    avgValue: 0,
    growthPercentage: 0,
    approvedDocuments: 0,
    pendingDocuments: 0,
    convertedQuotations: 0,
    conversionRate: 0,
    bidirectionalCount: 0,
    autoGeneratedCount: 0,
    sourceCompanyLinkedCount: 0,
  });

  const companyId = propCompanyId || urlCompanyId;

  const dateRangeOptions = [
    "Today",
    "Yesterday",
    "This Week",
    "Last Week",
    "This Month",
    "Last Month",
    "This Quarter",
    "Last Quarter",
    "This Year",
    "Last Year",
    "All Time",
    "Custom Range",
  ];

  const firmOptions = [
    "All Companies",
    currentCompany?.name || "Current Company",
    "Branch Office 1",
    "Branch Office 2",
  ];

  const allQuotations = useMemo(() => {
    const combined = [...quotations, ...ordersFromPO];
    const uniqueOrders = combined.filter(
      (order, index, self) =>
        index ===
        self.findIndex((o) => (o._id || o.id) === (order._id || order.id))
    );
    return uniqueOrders;
  }, [quotations, ordersFromPO]);

  const validateService = useCallback(() => {
    if (!saleOrderService) return false;
    if (typeof saleOrderService.getSalesOrders !== "function") return false;
    return true;
  }, [saleOrderService]);

  const loadQuotations = useCallback(async () => {
    if (!companyId || !validateService()) return;

    try {
      setIsLoading(true);
      setError(null);

      const response = await saleOrderService.getSalesOrders(companyId, {
        orderType: "quotation",
        search: searchTerm || undefined,
        status: filterStatus || undefined,
        sortBy: sortBy || "date",
        sortOrder: sortOrder || "desc",
        startDate: startDate?.toISOString(),
        endDate: endDate?.toISOString(),
        includeCustomer: true,
        includeItems: true,
      });

      if (response.success && response.data) {
        let quotationData = [];

        if (Array.isArray(response.data)) {
          quotationData = response.data;
        } else if (response.data.salesOrders) {
          quotationData = response.data.salesOrders;
        } else if (response.data.quotations) {
          quotationData = response.data.quotations;
        } else if (response.data.orders) {
          quotationData = response.data.orders;
        } else if (response.data.data) {
          if (Array.isArray(response.data.data)) {
            quotationData = response.data.data;
          } else if (response.data.data.salesOrders) {
            quotationData = response.data.data.salesOrders;
          } else if (response.data.data.quotations) {
            quotationData = response.data.data.quotations;
          }
        }

        if (!Array.isArray(quotationData)) {
          quotationData = [];
        }

        setQuotations(quotationData);

        const total = quotationData.length;
        const totalValue = quotationData.reduce((sum, q) => {
          const amount = parseFloat(
            q.amount ||
              q.totalAmount ||
              q.totals?.finalTotal ||
              q.totals?.grandTotal ||
              q.grandTotal ||
              0
          );
          return sum + (isNaN(amount) ? 0 : amount);
        }, 0);

        const approved = quotationData.filter(
          (q) => q.status === "approved" || q.status === "accepted"
        ).length;

        const pending = quotationData.filter(
          (q) =>
            q.status === "pending" ||
            q.status === "draft" ||
            q.status === "sent"
        ).length;

        const approvedValue = quotationData
          .filter((q) => q.status === "approved" || q.status === "accepted")
          .reduce((sum, q) => {
            const amount = parseFloat(
              q.amount ||
                q.totalAmount ||
                q.totals?.finalTotal ||
                q.totals?.grandTotal ||
                q.grandTotal ||
                0
            );
            return sum + (isNaN(amount) ? 0 : amount);
          }, 0);

        const pendingValue = quotationData
          .filter(
            (q) =>
              q.status === "pending" ||
              q.status === "draft" ||
              q.status === "sent"
          )
          .reduce((sum, q) => {
            const amount = parseFloat(
              q.amount ||
                q.totalAmount ||
                q.totals?.finalTotal ||
                q.totals?.grandTotal ||
                q.grandTotal ||
                0
            );
            return sum + (isNaN(amount) ? 0 : amount);
          }, 0);

        setSummary((prev) => ({
          ...prev,
          totalQuotations: total,
          quotationValue: totalValue,
          approvedDocuments: approved,
          pendingDocuments: pending,
          approvedValue: approvedValue,
          pendingValue: pendingValue,
          avgValue: total > 0 ? totalValue / total : 0,
        }));
      } else {
        setQuotations([]);
      }
    } catch (error) {
      setError(error.message);
      addToast?.(`Failed to load quotations: ${error.message}`, "error");
      setQuotations([]);
    } finally {
      setIsLoading(false);
    }
  }, [
    companyId,
    searchTerm,
    filterStatus,
    sortBy,
    sortOrder,
    startDate,
    endDate,
    saleOrderService,
    addToast,
    validateService,
  ]);

  const loadOrdersFromPO = useCallback(async () => {
    if (!companyId || !validateService()) return;

    try {
      const response = await saleOrderService.getSalesOrders(companyId, {
        isAutoGenerated: true,
        sourceOrderType: "purchase_order",
        orderType: "quotation",
        includeCustomer: true,
      });

      if (response.success && response.data) {
        let ordersData = [];

        if (Array.isArray(response.data)) {
          ordersData = response.data;
        } else if (response.data.salesOrders) {
          ordersData = response.data.salesOrders;
        } else if (response.data.orders) {
          ordersData = response.data.orders;
        } else if (response.data.data) {
          if (Array.isArray(response.data.data)) {
            ordersData = response.data.data;
          } else if (response.data.data.salesOrders) {
            ordersData = response.data.data.salesOrders;
          }
        }

        if (!Array.isArray(ordersData)) {
          ordersData = [];
        }

        setOrdersFromPO(ordersData);
        setSummary((prev) => ({
          ...prev,
          autoGeneratedCount: ordersData.length,
        }));
      }
    } catch (error) {
      setOrdersFromPO([]);
    }
  }, [companyId, saleOrderService, validateService]);

  const loadBidirectionalAnalytics = useCallback(async () => {
    if (!companyId || !validateService()) return;

    try {
      const response = await saleOrderService.getSalesOrders(companyId, {
        hasBidirectionalTracking: true,
        orderType: "quotation",
        includeTracking: true,
      });

      if (response.success && response.data) {
        const bidirectionalData = Array.isArray(response.data)
          ? response.data
          : response.data.salesOrders || [];
        setBidirectionalOrders(bidirectionalData);

        setSummary((prev) => ({
          ...prev,
          bidirectionalCount: bidirectionalData.length,
          sourceCompanyLinkedCount: bidirectionalData.filter(
            (o) => o.sourceCompanyId
          ).length,
        }));
      }
    } catch (error) {
      // Silent fail
    }
  }, [companyId, saleOrderService, validateService]);

  useEffect(() => {
    loadQuotations();
    loadOrdersFromPO();
    loadBidirectionalAnalytics();
  }, [loadQuotations, loadOrdersFromPO, loadBidirectionalAnalytics]);

  const handleAddQuotation = () => {
    const createPath = `/companies/${companyId}/sales-orders/add`;
    navigate(createPath, {
      state: {
        orderType: "quotation",
        documentType: "quotation",
        mode: "quotations",
        returnPath: location.pathname,
        defaultOrderType: "quotation",
      },
    });
  };
  const handleViewQuotation = useCallback((quotation) => {
    console.log(
      "Viewing quotation:",
      quotation.quotationNumber || quotation.orderNumber
    );
  }, []);

  // ✅ ENHANCED: Update handleEditQuotation to pass complete data
  const handleEditQuotation = useCallback(
    (quotation) => {
      const quotationId = quotation._id || quotation.id;

      if (!quotationId) {
        addToast?.("Cannot edit quotation: Invalid quotation data", "error");
        return;
      }

      console.log("🔄 Editing quotation:", {
        quotationId,
        quotationNumber: quotation.quotationNumber || quotation.orderNumber,
        quotationData: quotation,
        hasItems: Array.isArray(quotation.items),
        itemsCount: quotation.items?.length || 0,
      });

      const editPath = `/companies/${companyId}/sales-orders/${quotationId}/edit`;

      navigate(editPath, {
        state: {
          // ✅ CRITICAL: Pass the complete quotation data
          salesOrder: quotation,
          order: quotation,
          quotation: quotation,
          transaction: quotation,

          // ✅ ENHANCED: Document type information
          orderType: "quotation",
          documentType: "quotation",
          mode: "quotations",

          // ✅ ENHANCED: Navigation context
          returnPath: location.pathname,
          editMode: true,
          isEdit: true,

          // ✅ ENHANCED: Default settings
          defaultOrderType: "quotation",

          // ✅ ADDED: API configuration
          apiEndpoint: "sales-orders",
          updateRoute: `/api/sales-orders/${quotationId}`,

          // ✅ ENHANCED: Metadata
          editContext: {
            source: "Quotations",
            timestamp: new Date().toISOString(),
            companyId: companyId,
            userId: currentUser?.id || currentUser?._id,
            isQuotationsMode: true,
            apiRoute: `/api/sales-orders/${quotationId}`,
          },
        },
      });
    },
    [companyId, location.pathname, navigate, currentUser, addToast]
  );

  const handleDeleteQuotation = async (quotation) => {
    const quotationNumber =
      quotation.quotationNumber || quotation.orderNumber || quotation._id;

    const confirmed = window.confirm(
      `Are you sure you want to delete quotation ${quotationNumber}?\n\nThis action cannot be undone.`
    );

    if (!confirmed) return;

    try {
      setIsLoading(true);

      const response = await saleOrderService.deleteSalesOrder(
        quotation._id || quotation.id
      );

      if (response.success) {
        addToast?.(
          `Quotation ${quotationNumber} deleted successfully`,
          "success"
        );
        await Promise.all([
          loadQuotations(),
          loadOrdersFromPO(),
          loadBidirectionalAnalytics(),
        ]);
      } else {
        throw new Error(
          response.message || response.error || "Failed to delete quotation"
        );
      }
    } catch (error) {
      addToast?.(`Failed to delete quotation: ${error.message}`, "error");
    } finally {
      setIsLoading(false);
    }
  };

  const handleConvertQuotation = async (quotation) => {
    const quotationNumber =
      quotation.quotationNumber || quotation.orderNumber || quotation._id;

    const confirmed = window.confirm(
      `Convert quotation ${quotationNumber} to sales order?\n\nThis will create a new sales order based on this quotation.`
    );

    if (!confirmed) return;

    try {
      setIsLoading(true);

      const response = await saleOrderService.convertToInvoice(
        quotation._id || quotation.id,
        {
          convertToOrderType: "sales_order",
          preserveItems: true,
          preservePricing: true,
          preserveTerms: true,
          convertedBy: currentUser?._id || currentUser?.id,
          convertedByName: currentUser?.name || currentUser?.username,
          conversionReason: "quotation_to_sales_order",
        }
      );

      if (response.success) {
        addToast?.(
          `Quotation ${quotationNumber} converted to sales order successfully`,
          "success"
        );
        await loadQuotations();

        if (response.data?.order?._id) {
          const salesOrderPath = `/companies/${companyId}/sales-orders/${response.data.order._id}/view`;
          navigate(salesOrderPath, {
            state: {
              salesOrder: response.data.order,
              documentType: "sales_order",
              mode: "sales-orders",
              returnPath: location.pathname,
              converted: true,
              originalQuotation: quotation,
            },
          });
        }
      } else {
        throw new Error(
          response.message || response.error || "Conversion failed"
        );
      }
    } catch (error) {
      addToast?.(`Failed to convert quotation: ${error.message}`, "error");
    } finally {
      setIsLoading(false);
    }
  };

  const handleDuplicateQuotation = (quotation) => {
    const createPath = `/companies/${companyId}/sales-orders/add`;
    navigate(createPath, {
      state: {
        duplicateData: quotation,
        isDuplicate: true,
        originalQuotation: quotation,
        orderType: "quotation",
        documentType: "quotation",
        mode: "quotations",
        returnPath: location.pathname,
        defaultOrderType: "quotation",
      },
    });
  };

  const handlePrintQuotation = async (quotation) => {
    try {
      const quotationNumber =
        quotation.quotationNumber || quotation.orderNumber || quotation._id;

      // ✅ REMOVED: No "preparing quotation for printing" toast
      // ✅ REMOVED: No "quotation sent to printer" toast

      // Just call the print service without showing toasts
      const response = await saleOrderService.getSalesOrderForPrint?.(
        quotation._id || quotation.id,
        {
          template: "quotation",
          format: "a4",
        }
      );

      if (response && response.success) {
        // Let the SalesOrderTable component handle the print UI
        return response;
      }
    } catch (error) {
      // Only show error toasts
      addToast?.(`Failed to print quotation: ${error.message}`, "error");
    }
  };

  // ✅ FIXED: Remove toasts from handleShareQuotation function around line 545
  const handleShareQuotation = async (quotation) => {
    try {
      const quotationNumber =
        quotation.quotationNumber || quotation.orderNumber || quotation._id;

      // ✅ REMOVED: No "sharing quotation" toast
      // ✅ REMOVED: No "quotation shared successfully" toast

      // Just call the share service without showing toasts
      const response = await saleOrderService.shareOrder?.(
        quotation._id || quotation.id,
        {
          method: "email",
        }
      );

      if (response && response.success) {
        // Only show final success message
        addToast?.(
          `Quotation ${quotationNumber} shared successfully`,
          "success"
        );
      }
    } catch (error) {
      addToast?.(`Failed to share quotation: ${error.message}`, "error");
    }
  };

  // ✅ FIXED: Remove toasts from handleDownloadQuotation function around line 555
  const handleDownloadQuotation = async (quotation) => {
    try {
      const quotationNumber =
        quotation.quotationNumber || quotation.orderNumber || quotation._id;

      // ✅ REMOVED: No "downloading quotation" toast
      // ✅ REMOVED: No "quotation downloaded successfully" toast

      // Just call the download service without showing toasts
      const response = await saleOrderService.downloadSalesOrderPDF?.(
        quotation._id || quotation.id,
        {
          template: "quotation",
          format: "pdf",
        }
      );

      if (response && response.success) {
        // Only show final success message
        addToast?.(
          `Quotation ${quotationNumber} downloaded successfully`,
          "success"
        );
      }
    } catch (error) {
      addToast?.(`Failed to download quotation: ${error.message}`, "error");
    }
  };

  const handleViewTrackingChain = async (quotation) => {
    try {
      const quotationNumber =
        quotation.quotationNumber || quotation.orderNumber || quotation._id;

      const response = await saleOrderService.getTrackingChain(
        quotation._id || quotation.id
      );

      if (response.success) {
        const trackingPath = `/companies/${companyId}/sales-orders/${
          quotation._id || quotation.id
        }/tracking`;
        navigate(trackingPath, {
          state: {
            quotation: quotation,
            trackingChain: response.data,
            documentType: "quotation",
            mode: "quotations",
            returnPath: location.pathname,
          },
        });
      } else {
        addToast?.(
          `No tracking information found for quotation ${quotationNumber}`,
          "warning"
        );
      }
    } catch (error) {
      addToast?.(`Failed to load tracking chain: ${error.message}`, "error");
    }
  };

  const handleViewSourceOrder = (quotation) => {
    if (
      quotation.sourceOrderId &&
      quotation.sourceOrderType === "purchase_order"
    ) {
      const sourcePath = `/companies/${
        quotation.sourceCompanyId || companyId
      }/purchase-orders/${quotation.sourceOrderId}/view`;
      navigate(sourcePath, {
        state: {
          returnPath: location.pathname,
          sourceQuotation: quotation,
        },
      });
    } else {
      addToast?.("No source order found for this quotation", "warning");
    }
  };

  const handleViewGeneratedOrders = async (quotation) => {
    try {
      const generatedOrdersPath = `/companies/${companyId}/sales-orders/${
        quotation._id || quotation.id
      }/generated-orders`;
      navigate(generatedOrdersPath, {
        state: {
          quotation: quotation,
          documentType: "quotation",
          mode: "quotations",
          returnPath: location.pathname,
        },
      });
    } catch (error) {
      addToast?.(`Failed to load generated orders: ${error.message}`, "error");
    }
  };

  const handleCancelQuotation = async (quotation) => {
    const quotationNumber =
      quotation.quotationNumber || quotation.orderNumber || quotation._id;

    const confirmed = window.confirm(
      `Are you sure you want to cancel quotation ${quotationNumber}?`
    );

    if (!confirmed) return;

    try {
      const response = await saleOrderService.cancelOrder(
        quotation._id || quotation.id
      );

      if (response.success) {
        addToast?.(
          `Quotation ${quotationNumber} cancelled successfully`,
          "success"
        );
        await Promise.all([loadQuotations(), loadBidirectionalAnalytics()]);
      } else {
        throw new Error(response.message);
      }
    } catch (error) {
      addToast?.(`Failed to cancel quotation: ${error.message}`, "error");
    }
  };

  const handleGeneratePurchaseOrder = async (quotation) => {
    const quotationNumber =
      quotation.quotationNumber || quotation.orderNumber || quotation._id;

    const confirmed = window.confirm(
      `Generate Purchase Order from quotation ${quotationNumber}?\n\nThis will create a corresponding purchase order.`
    );

    if (!confirmed) return;

    try {
      setIsLoading(true);

      // Call service to generate PO from quotation
      const response = await saleOrderService.generatePurchaseOrder(
        quotation._id || quotation.id,
        {
          preserveItems: true,
          preservePricing: true,
          preserveTerms: true,
          generatedBy: currentUser?._id || currentUser?.id,
          generatedByName: currentUser?.name || currentUser?.username,
          generationReason: "quotation_to_purchase_order",
        }
      );

      if (response.success) {
        addToast?.(
          `Purchase Order generated from quotation ${quotationNumber} successfully`,
          "success"
        );
        await loadQuotations();

        if (response.data?.purchaseOrder?._id) {
          const purchaseOrderPath = `/companies/${companyId}/purchase-orders/${response.data.purchaseOrder._id}/view`;
          navigate(purchaseOrderPath, {
            state: {
              purchaseOrder: response.data.purchaseOrder,
              documentType: "purchase-order",
              mode: "purchase-orders",
              returnPath: location.pathname,
              generated: true,
              originalQuotation: quotation,
            },
          });
        }
      } else {
        throw new Error(
          response.message ||
            response.error ||
            "Purchase Order generation failed"
        );
      }
    } catch (error) {
      addToast?.(
        `Failed to generate Purchase Order: ${error.message}`,
        "error"
      );
    } finally {
      setIsLoading(false);
    }
  };

  const handleDateRangeChange = useCallback((range) => {
    setDateRange(range);
    const today = new Date();

    switch (range) {
      case "Today":
        setStartDate(new Date(today.setHours(0, 0, 0, 0)));
        setEndDate(new Date(today.setHours(23, 59, 59, 999)));
        break;
      case "Yesterday":
        const yesterday = new Date(today);
        yesterday.setDate(today.getDate() - 1);
        setStartDate(new Date(yesterday.setHours(0, 0, 0, 0)));
        setEndDate(new Date(yesterday.setHours(23, 59, 59, 999)));
        break;
      case "This Week":
        const startOfWeek = new Date(today);
        startOfWeek.setDate(today.getDate() - today.getDay());
        setStartDate(new Date(startOfWeek.setHours(0, 0, 0, 0)));
        setEndDate(new Date(today.setHours(23, 59, 59, 999)));
        break;
      case "This Month":
        setStartDate(new Date(today.getFullYear(), today.getMonth(), 1));
        setEndDate(
          new Date(
            today.getFullYear(),
            today.getMonth() + 1,
            0,
            23,
            59,
            59,
            999
          )
        );
        break;
      case "Last Month":
        const lastMonth = new Date(
          today.getFullYear(),
          today.getMonth() - 1,
          1
        );
        const lastMonthEnd = new Date(
          today.getFullYear(),
          today.getMonth(),
          0,
          23,
          59,
          59,
          999
        );
        setStartDate(lastMonth);
        setEndDate(lastMonthEnd);
        break;
      case "This Quarter":
        const quarterStart = new Date(
          today.getFullYear(),
          Math.floor(today.getMonth() / 3) * 3,
          1
        );
        setStartDate(quarterStart);
        setEndDate(
          new Date(
            today.getFullYear(),
            Math.floor(today.getMonth() / 3) * 3 + 3,
            0,
            23,
            59,
            59,
            999
          )
        );
        break;
      case "This Year":
        setStartDate(new Date(today.getFullYear(), 0, 1));
        setEndDate(new Date(today.getFullYear(), 11, 31, 23, 59, 59, 999));
        break;
      case "All Time":
        setStartDate(new Date(2020, 0, 1));
        setEndDate(new Date());
        break;
      case "Custom Range":
        break;
      default:
        break;
    }
  }, []);

  const handleStartDateChange = useCallback((e) => {
    setStartDate(new Date(e.target.value));
    setDateRange("Custom Range");
  }, []);

  const handleEndDateChange = useCallback((e) => {
    setEndDate(new Date(e.target.value));
    setDateRange("Custom Range");
  }, []);

  const handleFirmChange = useCallback((firm) => {
    setSelectedFirm(firm);
  }, []);

  const handleSearchChange = useCallback((e) => {
    const searchValue = typeof e === "string" ? e : e?.target?.value || "";
    setSearchTerm(searchValue);
  }, []);

  const handleSort = useCallback(
    (field) => {
      if (sortBy === field) {
        setSortOrder((prev) => (prev === "asc" ? "desc" : "asc"));
      } else {
        setSortBy(field);
        setSortOrder("asc");
      }
    },
    [sortBy]
  );

  const handleFilterChange = useCallback((status) => {
    setFilterStatus(status);
  }, []);

  const handleRefresh = () => {
    loadQuotations();
    loadOrdersFromPO();
    loadBidirectionalAnalytics();
  };

  if (!companyId) {
    return (
      <div
        style={{
          width: "100%",
          height: "100vh",
          backgroundColor: "#f8f9fa",
          margin: 0,
          padding: "1rem",
        }}
      >
        <Container fluid>
          <Alert variant="warning" className="text-center">
            <h5>⚠️ No Company Selected</h5>
            <p className="mb-0">
              Please select a company to view and manage quotations.
            </p>
          </Alert>
        </Container>
      </div>
    );
  }

  if (!isOnline) {
    return (
      <div
        style={{
          width: "100%",
          height: "100vh",
          backgroundColor: "#f8f9fa",
          margin: 0,
          padding: "1rem",
        }}
      >
        <Container fluid>
          <Alert variant="warning" className="text-center">
            <h5>📡 No Internet Connection</h5>
            <p className="mb-0">
              Quotations data requires an internet connection.
            </p>
          </Alert>
        </Container>
      </div>
    );
  }

  if (!validateService()) {
    return (
      <div
        style={{
          width: "100%",
          height: "100vh",
          backgroundColor: "#f8f9fa",
          margin: 0,
          padding: "1rem",
        }}
      >
        <Container fluid>
          <Alert variant="danger" className="text-center">
            <h5>🔧 Service Unavailable</h5>
            <p className="mb-0">
              Sales order service is not available. Please check your
              configuration.
            </p>
            <Button
              variant="outline-danger"
              size="sm"
              className="mt-2"
              onClick={() => window.location.reload()}
            >
              <FontAwesomeIcon icon={faSync} className="me-1" /> Reload Page
            </Button>
          </Alert>
        </Container>
      </div>
    );
  }

  return (
    <div
      style={{
        width: "100%",
        height: "100vh",
        backgroundColor: "#f8f9fa",
        margin: 0,
        padding: 0,
        overflow: "hidden", // ✅ FIXED: Prevent outer scroll
        display: "flex",
        flexDirection: "column",
      }}
    >
      <style>
        {`
        .main-content {
          padding: 0 !important;
          margin: 0 !important;
          min-height: auto !important;
        }
        
        /* ✅ FIXED: Remove scroll bars from nested components */
        .quotations-container {
          overflow: hidden !important;
        }
        
        .quotations-container .container-fluid {
          overflow: hidden !important;
        }
        
        /* ✅ FIXED: Ensure tables handle overflow properly */
        .table-responsive {
          overflow-x: auto !important;
          overflow-y: hidden !important;
        }
        
        /* ✅ Smaller card styling for quotations */
        .text-center .card-body {
          padding: 0.5rem !important;
        }
        
        .text-center h6 {
          font-size: 1rem !important;
          margin-bottom: 0.25rem !important;
          font-weight: 600 !important;
        }
        
        .text-center small {
          font-size: 0.7rem !important;
          line-height: 1.2 !important;
        }
        
        /* Tab styling */
        .nav-tabs .nav-link {
          border-radius: 0 !important;
        }
        
        .nav-tabs .nav-link.active {
          border-radius: 0 !important;
        }

        /* ✅ FIXED: Prevent scroll in specific containers */
        .sales-order-table-container {
          overflow: visible !important;
        }
        
        .card-body {
          overflow: visible !important;
        }
      `}
      </style>

      {/* ✅ FIXED: Header with fixed height */}
      <div style={{flexShrink: 0}}>
        <SalesInvoicesHeader
          searchTerm={searchTerm}
          onSearchChange={handleSearchChange}
          onAddSale={handleAddQuotation}
          onAddPurchase={() => {}}
          onMoreOptions={() => addToast?.("More options coming soon", "info")}
          onSettings={() => addToast?.("Settings coming soon", "info")}
          pageTitle="Quotations"
          companyId={companyId}
          currentCompany={currentCompany}
          addToast={addToast}
          onNavigate={onNavigate}
        />
      </div>

      {/* ✅ FIXED: Scrollable content area */}
      <Container
        fluid
        className="px-3 quotations-container"
        style={{
          flex: 1,
          overflow: "auto",
          height: 0, // ✅ CRITICAL: Forces proper flex behavior
          paddingBottom: "20px",
        }}
      >
        {/* ✅ FIXED: Page Title Header with margin adjustment */}
        <div style={{marginBottom: "1rem"}}>
          <SalesInvoicesPageTitle
            onAddSale={handleAddQuotation}
            invoiceCount={allQuotations.length}
            companyId={companyId}
            mode="quotations"
            documentType="quotation"
            title="Quotations"
            subtitle="Create and manage professional quotations for your clients"
          />
        </div>

        {/* ✅ FIXED: Filter section */}
        <Row className="mb-3">
          <Col xs={12}>
            <SalesInvoicesFilter
              dateRange={dateRange}
              startDate={startDate}
              endDate={endDate}
              selectedFirm={selectedFirm}
              dateRangeOptions={dateRangeOptions}
              firmOptions={firmOptions}
              onDateRangeChange={handleDateRangeChange}
              onStartDateChange={handleStartDateChange}
              onEndDateChange={handleEndDateChange}
              onFirmChange={handleFirmChange}
              onExcelExport={() =>
                addToast?.("Excel export coming soon", "info")
              }
              onPrint={() => addToast?.("Print coming soon", "info")}
              resultCount={allQuotations.length}
              mode="quotations"
              documentType="quotation"
              pageTitle="Quotations"
              showBidirectionalFilters={true}
              onToggleBidirectionalAnalytics={() =>
                setShowBidirectionalAnalytics(!showBidirectionalAnalytics)
              }
              showBidirectionalAnalytics={showBidirectionalAnalytics}
            />
          </Col>
        </Row>

        <Row className="g-3">
          <Col xl={2} lg={3} md={3} sm={12}>
            <SalesInvoicesSummary
              summary={summary}
              loading={isLoading}
              dateRange={dateRange}
              mode="quotations"
              documentType="quotation"
              isQuotationsMode={true}
              showBidirectionalMetrics={true}
              bidirectionalCount={summary.bidirectionalCount}
              autoGeneratedCount={summary.autoGeneratedCount}
              sourceCompanyLinkedCount={summary.sourceCompanyLinkedCount}
            />
          </Col>

          <Col xl={10} lg={9} md={9} sm={12}>
            {error && (
              <Alert
                variant="danger"
                className="mb-3"
                style={{borderRadius: 0}}
              >
                <FontAwesomeIcon
                  icon={faExclamationTriangle}
                  className="me-2"
                />
                {error}
                <Button
                  variant="outline-danger"
                  size="sm"
                  className="ms-2"
                  onClick={() => {
                    setError(null);
                    handleRefresh();
                  }}
                  style={{borderRadius: 0}}
                >
                  <FontAwesomeIcon icon={faSync} className="me-1" /> Retry
                </Button>
              </Alert>
            )}

            <Tab.Container
              activeKey={activeTab}
              onSelect={(k) => setActiveTab(k)}
            >
              <Nav variant="tabs" className="mb-0" style={{borderRadius: 0}}>
                <Nav.Item>
                  <Nav.Link eventKey="quotations">
                    <FontAwesomeIcon icon={faClipboardList} className="me-2" />
                    Quotations ({quotations.length})
                  </Nav.Link>
                </Nav.Item>
                <Nav.Item>
                  <Nav.Link eventKey="fromBuyers">
                    <FontAwesomeIcon icon={faBuilding} className="me-2" />
                    From Buyers (
                    {summary.autoGeneratedCount + summary.bidirectionalCount})
                  </Nav.Link>
                </Nav.Item>
              </Nav>

              <Tab.Content>
                <Tab.Pane eventKey="quotations">
                  {/* ✅ FIXED: Card without scroll overflow */}
                  <Card
                    className="border-0 shadow-sm"
                    style={{
                      borderRadius: 0,
                      overflow: "visible", // ✅ FIXED: Remove overflow restriction
                    }}
                  >
                    <Card.Body
                      className="p-0"
                      style={{
                        overflow: "visible", // ✅ FIXED: Remove overflow restriction
                      }}
                    >
                      <SalesOrderTable
                        salesOrders={quotations}
                        onViewOrder={handleViewQuotation}
                        onEditOrder={handleEditQuotation}
                        onDeleteOrder={handleDeleteQuotation}
                        onPrintOrder={handlePrintQuotation}
                        onShareOrder={handleShareQuotation}
                        onDownloadOrder={handleDownloadQuotation}
                        onConvertOrder={handleConvertQuotation}
                        onDuplicateOrder={handleDuplicateQuotation}
                        onGeneratePurchaseOrder={handleGeneratePurchaseOrder}
                        isLoading={isLoading}
                        title="Quotations"
                        searchPlaceholder="Search quotations, customers, mobile..."
                        companyId={companyId}
                        addToast={addToast}
                        currentUser={currentUser}
                        currentCompany={currentCompany}
                        searchTerm={searchTerm}
                        onSearchChange={handleSearchChange}
                        sortBy={sortBy}
                        sortOrder={sortOrder}
                        onSort={handleSort}
                        filterStatus={filterStatus}
                        onFilterChange={handleFilterChange}
                        showHeader={false}
                        enableActions={true}
                        enableBulkActions={true}
                        selectedOrders={selectedQuotations}
                        onSelectionChange={setSelectedQuotations}
                        showBidirectionalColumns={true}
                        documentType="quotation"
                        isQuotationsMode={true}
                        saleOrderService={saleOrderService}
                        onCancelOrder={handleCancelQuotation}
                        onViewTrackingChain={handleViewTrackingChain}
                        onViewSourceOrder={handleViewSourceOrder}
                        onViewGeneratedOrders={handleViewGeneratedOrders}
                        enableEnhancedTracking={true}
                        showSourceCompanyColumn={true}
                        showGeneratedOrdersColumn={false}
                        enableQuickNavigation={true}
                        refreshTrigger={`${quotations.length}-${ordersFromPO.length}`}
                      />
                    </Card.Body>
                  </Card>
                </Tab.Pane>

                <Tab.Pane eventKey="fromBuyers">
                  {/* ✅ FIXED: Similar overflow fix for second tab */}
                  <Card
                    style={{
                      borderRadius: 0,
                      overflow: "visible", // ✅ FIXED: Remove overflow restriction
                    }}
                  >
                    <Card.Header className="bg-light">
                      <div className="d-flex align-items-center justify-content-between">
                        <h5 className="mb-0">
                          <FontAwesomeIcon
                            icon={faBuilding}
                            className="me-2 text-primary"
                          />
                          Quotations From Buyers
                        </h5>
                        <Badge
                          bg="info"
                          className="fs-6"
                          style={{borderRadius: 0}}
                        >
                          {summary.autoGeneratedCount +
                            summary.bidirectionalCount}{" "}
                          Active
                        </Badge>
                      </div>
                    </Card.Header>
                    <Card.Body
                      style={{
                        overflow: "visible", // ✅ FIXED: Remove overflow restriction
                      }}
                    >
                      <Row className="mb-3">
                        <Col md={4}>
                          <Card
                            className="text-center border-info"
                            style={{borderRadius: 0}}
                          >
                            <Card.Body className="py-2">
                              <FontAwesomeIcon
                                icon={faFileImport}
                                className="text-info mb-1"
                                style={{fontSize: "1.2rem"}}
                              />
                              <h6 className="text-info mb-1">
                                {summary.autoGeneratedCount}
                              </h6>
                              <small
                                className="text-muted"
                                style={{fontSize: "0.75rem"}}
                              >
                                Auto-Generated from Purchase Orders
                              </small>
                            </Card.Body>
                          </Card>
                        </Col>
                        <Col md={4}>
                          <Card
                            className="text-center border-success"
                            style={{borderRadius: 0}}
                          >
                            <Card.Body className="py-2">
                              <FontAwesomeIcon
                                icon={faFileExport}
                                className="text-success mb-1"
                                style={{fontSize: "1.2rem"}}
                              />
                              <h6 className="text-success mb-1">
                                {summary.convertedQuotations}
                              </h6>
                              <small
                                className="text-muted"
                                style={{fontSize: "0.75rem"}}
                              >
                                Converted to Orders
                              </small>
                            </Card.Body>
                          </Card>
                        </Col>
                        <Col md={4}>
                          <Card
                            className="text-center border-warning"
                            style={{borderRadius: 0}}
                          >
                            <Card.Body className="py-2">
                              <FontAwesomeIcon
                                icon={faExchangeAlt}
                                className="text-warning mb-1"
                                style={{fontSize: "1.2rem"}}
                              />
                              <h6 className="text-warning mb-1">
                                {summary.bidirectionalCount}
                              </h6>
                              <small
                                className="text-muted"
                                style={{fontSize: "0.75rem"}}
                              >
                                From Purchase Orders
                              </small>
                            </Card.Body>
                          </Card>
                        </Col>
                      </Row>

                      <SalesOrderTable
                        salesOrders={ordersFromPO}
                        onViewOrder={handleViewQuotation}
                        onEditOrder={handleEditQuotation}
                        onDeleteOrder={handleDeleteQuotation}
                        onPrintOrder={handlePrintQuotation}
                        onShareOrder={handleShareQuotation}
                        onDownloadOrder={handleDownloadQuotation}
                        onConvertOrder={handleConvertQuotation}
                        onDuplicateOrder={handleDuplicateQuotation}
                        onGeneratePurchaseOrder={handleGeneratePurchaseOrder}
                        isLoading={isLoading}
                        title="Quotations From Buyers"
                        searchPlaceholder="Search buyer quotations..."
                        companyId={companyId}
                        addToast={addToast}
                        currentUser={currentUser}
                        currentCompany={currentCompany}
                        showHeader={false}
                        enableActions={true}
                        enableBulkActions={false}
                        showBidirectionalColumns={true}
                        documentType="quotation"
                        isQuotationsMode={true}
                        saleOrderService={saleOrderService}
                        onCancelOrder={handleCancelQuotation}
                        onViewTrackingChain={handleViewTrackingChain}
                        onViewSourceOrder={handleViewSourceOrder}
                        onViewGeneratedOrders={handleViewGeneratedOrders}
                        enableEnhancedTracking={true}
                        showSourceCompanyColumn={true}
                        showGeneratedOrdersColumn={true}
                        enableQuickNavigation={true}
                      />
                    </Card.Body>
                  </Card>
                </Tab.Pane>
              </Tab.Content>
            </Tab.Container>
          </Col>
        </Row>
      </Container>
    </div>
  );
}

export default Quotations;
