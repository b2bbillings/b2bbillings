import React, {useState, useEffect, useCallback, useMemo} from "react";
import {useParams, useNavigate, useLocation} from "react-router-dom";
import {Container, Row, Col, Alert, Card, Button} from "react-bootstrap";
import {FontAwesomeIcon} from "@fortawesome/react-fontawesome";
import {faSync, faExclamationTriangle} from "@fortawesome/free-solid-svg-icons";

import SalesOrderTable from "./Sales/SalesOrder/SalesOrderTable";
import SalesInvoicesHeader from "./Sales/SalesInvoice/SalesInvoicesHeader";
import SalesInvoicesFilter from "./Sales/SalesInvoice/SalesInvoicesFilter";
import SalesInvoicesSummary from "./Sales/SalesInvoice/SalesInvoicesSummary";
import SalesInvoicesPageTitle from "./Sales/SalesInvoice/SalesInvoicesPageTitle";
import salesOrderServiceImport from "../../services/saleOrderService";

function Quotations({
  view = "quotations",
  onNavigate,
  currentCompany,
  currentUser,
  isOnline = true,
  addToast,
  companyId: propCompanyId,
  saleOrderService: propSaleOrderService,
}) {
  const {companyId: urlCompanyId} = useParams();
  const navigate = useNavigate();
  const location = useLocation();

  const saleOrderService = propSaleOrderService || salesOrderServiceImport;

  // ✅ STATES
  const [quotations, setQuotations] = useState([]);
  const [ordersFromPO, setOrdersFromPO] = useState([]);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState(null);
  const [searchTerm, setSearchTerm] = useState("");
  const [sortBy, setSortBy] = useState("date");
  const [sortOrder, setSortOrder] = useState("desc");
  const [selectedQuotations, setSelectedQuotations] = useState([]);
  const [filterStatus, setFilterStatus] = useState("");
  const [bidirectionalOrders, setBidirectionalOrders] = useState([]);
  const [showBidirectionalAnalytics, setShowBidirectionalAnalytics] =
    useState(false);
  const [dateRange, setDateRange] = useState("This Month");
  const [startDate, setStartDate] = useState(
    new Date(new Date().getFullYear(), new Date().getMonth(), 1)
  );
  const [endDate, setEndDate] = useState(new Date());
  const [selectedFirm, setSelectedFirm] = useState("All Companies");
  const [summary, setSummary] = useState({
    totalQuotations: 0,
    quotationValue: 0,
    approvedValue: 0,
    pendingValue: 0,
    todaysAmount: 0,
    avgValue: 0,
    growthPercentage: 0,
    approvedDocuments: 0,
    pendingDocuments: 0,
    convertedQuotations: 0,
    conversionRate: 0,
    bidirectionalCount: 0,
    autoGeneratedCount: 0,
    sourceCompanyLinkedCount: 0,
  });

  const companyId = propCompanyId || urlCompanyId;

  // ✅ CONSTANTS
  const dateRangeOptions = [
    "Today",
    "Yesterday",
    "This Week",
    "Last Week",
    "This Month",
    "Last Month",
    "This Quarter",
    "Last Quarter",
    "This Year",
    "Last Year",
    "All Time",
    "Custom Range",
  ];

  const firmOptions = [
    "All Companies",
    currentCompany?.name || "Current Company",
    "Branch Office 1",
    "Branch Office 2",
  ];

  // ✅ COMPUTED VALUES
  const allQuotations = useMemo(() => {
    const combined = [...quotations, ...ordersFromPO];
    const uniqueOrders = combined.filter(
      (order, index, self) =>
        index ===
        self.findIndex((o) => (o._id || o.id) === (order._id || order.id))
    );
    return uniqueOrders;
  }, [quotations, ordersFromPO]);

  // ✅ VALIDATION
  const validateService = useCallback(() => {
    if (!saleOrderService) return false;
    if (typeof saleOrderService.getSalesOrders !== "function") return false;
    return true;
  }, [saleOrderService]);

  // ✅ DATA LOADING
  const loadQuotations = useCallback(async () => {
    if (!validateService()) {
      setError("Sales order service is not available");
      return;
    }

    try {
      setIsLoading(true);
      setError(null);

      console.log("🔄 Loading quotations:", {
        companyId,
        searchTerm,
        filterStatus,
        sortBy,
        sortOrder,
        startDate: startDate.toISOString(),
        endDate: endDate.toISOString(),
      });

      const response = await saleOrderService.getSalesOrders(companyId, {
        search: searchTerm,
        status: filterStatus,
        sortBy,
        sortOrder,
        startDate: startDate.toISOString(),
        endDate: endDate.toISOString(),
        orderType: "quotation", // ✅ Filter for quotations only
        documentType: "quotation",
        limit: 1000,
      });

      console.log("📥 Quotations response:", response);

      if (response.success && response.data) {
        const quotationsData =
          response.data.salesOrders ||
          response.data.orders ||
          response.data.quotations ||
          [];

        // Filter to ensure we only get quotations
        const filteredQuotations = quotationsData.filter(
          (order) =>
            order.orderType === "quotation" ||
            order.documentType === "quotation" ||
            order.quotationNumber ||
            order.isQuotation
        );

        setQuotations(filteredQuotations);

        // Update summary
        const total = filteredQuotations.length;
        const totalValue = filteredQuotations.reduce(
          (sum, q) => sum + (q.amount || 0),
          0
        );
        const approvedQuotations = filteredQuotations.filter(
          (q) => q.status === "approved"
        );
        const pendingQuotations = filteredQuotations.filter(
          (q) => q.status === "pending" || q.status === "draft"
        );
        const convertedQuotations = filteredQuotations.filter(
          (q) => q.isConverted || q.convertedToSalesOrder
        );

        setSummary((prev) => ({
          ...prev,
          totalQuotations: total,
          quotationValue: totalValue,
          approvedValue: approvedQuotations.reduce(
            (sum, q) => sum + (q.amount || 0),
            0
          ),
          pendingValue: pendingQuotations.reduce(
            (sum, q) => sum + (q.amount || 0),
            0
          ),
          avgValue: total > 0 ? totalValue / total : 0,
          approvedDocuments: approvedQuotations.length,
          pendingDocuments: pendingQuotations.length,
          convertedQuotations: convertedQuotations.length,
          conversionRate:
            total > 0 ? (convertedQuotations.length / total) * 100 : 0,
        }));

        addToast?.(`Loaded ${total} quotations successfully`, "success");
      } else {
        throw new Error(response.message || "Failed to load quotations");
      }
    } catch (error) {
      console.error("❌ Error loading quotations:", error);
      setError(error.message || "Failed to load quotations");
      addToast?.("Failed to load quotations", "error");
    } finally {
      setIsLoading(false);
    }
  }, [
    companyId,
    searchTerm,
    filterStatus,
    sortBy,
    sortOrder,
    startDate,
    endDate,
    saleOrderService,
    addToast,
    validateService,
  ]);

  const loadOrdersFromPO = useCallback(async () => {
    if (!validateService()) return;

    try {
      console.log("🔄 Loading orders from purchase orders...");

      const response = await saleOrderService.getSalesOrders(companyId, {
        sourceOrderType: "purchase_order",
        orderType: "quotation",
        documentType: "quotation",
        limit: 1000,
      });

      if (response.success && response.data) {
        const ordersData =
          response.data.salesOrders || response.data.orders || [];

        // Filter for quotations that came from purchase orders
        const quotationsFromPO = ordersData.filter(
          (order) =>
            (order.orderType === "quotation" ||
              order.documentType === "quotation") &&
            (order.sourceOrderType === "purchase_order" || order.sourceOrderId)
        );

        setOrdersFromPO(quotationsFromPO);

        console.log(
          `✅ Loaded ${quotationsFromPO.length} quotations from purchase orders`
        );
      }
    } catch (error) {
      console.error("❌ Error loading orders from PO:", error);
    }
  }, [companyId, saleOrderService, validateService]);

  const loadBidirectionalAnalytics = useCallback(async () => {
    if (!validateService()) return;

    try {
      console.log("🔄 Loading bidirectional analytics...");

      // Load bidirectional orders
      const bidirectionalResponse =
        await saleOrderService.getBidirectionalOrders?.(companyId);

      if (bidirectionalResponse?.success && bidirectionalResponse.data) {
        const bidirectionalData = bidirectionalResponse.data.orders || [];

        // Filter for quotations
        const bidirectionalQuotations = bidirectionalData.filter(
          (order) =>
            order.orderType === "quotation" ||
            order.documentType === "quotation"
        );

        setBidirectionalOrders(bidirectionalQuotations);

        // Update summary with bidirectional metrics
        const bidirectionalCount = bidirectionalQuotations.length;
        const autoGeneratedCount = bidirectionalQuotations.filter(
          (q) => q.isAutoGenerated
        ).length;
        const sourceCompanyLinkedCount = bidirectionalQuotations.filter(
          (q) => q.sourceCompanyId
        ).length;

        setSummary((prev) => ({
          ...prev,
          bidirectionalCount,
          autoGeneratedCount,
          sourceCompanyLinkedCount,
        }));

        console.log(`✅ Loaded ${bidirectionalCount} bidirectional quotations`);
      }
    } catch (error) {
      console.error("❌ Error loading bidirectional analytics:", error);
      // Don't show error toast for this as it's not critical
    }
  }, [companyId, saleOrderService, validateService]);

  // ✅ EFFECTS
  useEffect(() => {
    loadQuotations();
    loadOrdersFromPO();
    loadBidirectionalAnalytics();
  }, [loadQuotations, loadOrdersFromPO, loadBidirectionalAnalytics]);

  // ✅ ACTION HANDLERS
  const handleAddQuotation = () => {
    navigate(`/companies/${companyId}/quotations/add`);
  };

  const handleEditQuotation = (quotation) => {
    const quotationId = quotation._id || quotation.id;
    navigate(`/companies/${companyId}/quotations/${quotationId}/edit`);
  };

  const handleDeleteQuotation = async (quotation) => {
    const quotationId = quotation._id || quotation.id;
    const quotationNumber = quotation.quotationNumber || quotation.orderNumber;

    const confirmed = window.confirm(
      `Are you sure you want to delete quotation ${quotationNumber}?`
    );

    if (!confirmed) return;

    try {
      const response = await saleOrderService.deleteSalesOrder(quotationId);

      if (response.success) {
        addToast?.(
          `Quotation ${quotationNumber} deleted successfully`,
          "success"
        );
        loadQuotations();
        loadBidirectionalAnalytics();
      } else {
        throw new Error(response.message || "Failed to delete quotation");
      }
    } catch (error) {
      console.error("❌ Error deleting quotation:", error);
      addToast?.(`Failed to delete quotation: ${error.message}`, "error");
    }
  };

  const handleConvertQuotation = async (quotation) => {
    const quotationId = quotation._id || quotation.id;
    navigate(
      `/companies/${companyId}/sales-orders/new?fromQuotation=${quotationId}`
    );
  };

  const handleDuplicateQuotation = (quotation) => {
    const quotationId = quotation._id || quotation.id;
    navigate(`/companies/${companyId}/quotations/add?duplicate=${quotationId}`);
  };

  const handleViewTrackingChain = (quotation) => {
    addToast?.("Tracking chain feature coming soon", "info");
  };

  const handleViewSourceOrder = (quotation) => {
    if (
      quotation.sourceOrderId &&
      quotation.sourceOrderType === "purchase_order"
    ) {
      navigate(
        `/companies/${companyId}/purchase-orders/${quotation.sourceOrderId}`
      );
    } else {
      addToast?.("No source order found", "warning");
    }
  };

  const handleViewGeneratedOrders = (quotation) => {
    const quotationId = quotation._id || quotation.id;
    navigate(
      `/companies/${companyId}/quotations/${quotationId}/generated-orders`
    );
  };

  // ✅ EVENT HANDLERS
  const handleDateRangeChange = useCallback((range) => {
    setDateRange(range);

    const now = new Date();
    let start, end;

    switch (range) {
      case "Today":
        start = new Date(now.getFullYear(), now.getMonth(), now.getDate());
        end = new Date(
          now.getFullYear(),
          now.getMonth(),
          now.getDate(),
          23,
          59,
          59
        );
        break;
      case "Yesterday":
        start = new Date(now.getFullYear(), now.getMonth(), now.getDate() - 1);
        end = new Date(
          now.getFullYear(),
          now.getMonth(),
          now.getDate() - 1,
          23,
          59,
          59
        );
        break;
      case "This Week":
        const weekStart = new Date(now);
        weekStart.setDate(now.getDate() - now.getDay());
        start = new Date(
          weekStart.getFullYear(),
          weekStart.getMonth(),
          weekStart.getDate()
        );
        end = now;
        break;
      case "Last Week":
        const lastWeekStart = new Date(now);
        lastWeekStart.setDate(now.getDate() - now.getDay() - 7);
        const lastWeekEnd = new Date(lastWeekStart);
        lastWeekEnd.setDate(lastWeekStart.getDate() + 6);
        start = new Date(
          lastWeekStart.getFullYear(),
          lastWeekStart.getMonth(),
          lastWeekStart.getDate()
        );
        end = new Date(
          lastWeekEnd.getFullYear(),
          lastWeekEnd.getMonth(),
          lastWeekEnd.getDate(),
          23,
          59,
          59
        );
        break;
      case "This Month":
        start = new Date(now.getFullYear(), now.getMonth(), 1);
        end = now;
        break;
      case "Last Month":
        start = new Date(now.getFullYear(), now.getMonth() - 1, 1);
        end = new Date(now.getFullYear(), now.getMonth(), 0, 23, 59, 59);
        break;
      case "This Quarter":
        const quarterStart = new Date(
          now.getFullYear(),
          Math.floor(now.getMonth() / 3) * 3,
          1
        );
        start = quarterStart;
        end = now;
        break;
      case "Last Quarter":
        const lastQuarterStart = new Date(
          now.getFullYear(),
          Math.floor(now.getMonth() / 3) * 3 - 3,
          1
        );
        const lastQuarterEnd = new Date(
          now.getFullYear(),
          Math.floor(now.getMonth() / 3) * 3,
          0,
          23,
          59,
          59
        );
        start = lastQuarterStart;
        end = lastQuarterEnd;
        break;
      case "This Year":
        start = new Date(now.getFullYear(), 0, 1);
        end = now;
        break;
      case "Last Year":
        start = new Date(now.getFullYear() - 1, 0, 1);
        end = new Date(now.getFullYear() - 1, 11, 31, 23, 59, 59);
        break;
      case "All Time":
        start = new Date(2020, 0, 1); // Starting from 2020
        end = now;
        break;
      default:
        return; // Custom Range - don't change dates
    }

    if (start && end) {
      setStartDate(start);
      setEndDate(end);
    }
  }, []);

  const handleStartDateChange = useCallback((e) => {
    setStartDate(new Date(e.target.value));
    setDateRange("Custom Range");
  }, []);

  const handleEndDateChange = useCallback((e) => {
    setEndDate(new Date(e.target.value));
    setDateRange("Custom Range");
  }, []);

  const handleFirmChange = useCallback((firm) => {
    setSelectedFirm(firm);
  }, []);

  const handleSearchChange = useCallback((e) => {
    const searchValue = typeof e === "string" ? e : e?.target?.value || "";
    setSearchTerm(searchValue);
  }, []);

  const handleSort = useCallback(
    (field) => {
      if (sortBy === field) {
        setSortOrder((prev) => (prev === "asc" ? "desc" : "asc"));
      } else {
        setSortBy(field);
        setSortOrder("asc");
      }
    },
    [sortBy]
  );

  const handleFilterChange = useCallback((status) => {
    setFilterStatus(status);
  }, []);

  const handleRefresh = () => {
    loadQuotations();
    loadOrdersFromPO();
    loadBidirectionalAnalytics();
  };

  // ✅ GUARDS
  if (!companyId) {
    return (
      <div
        className="quotations-container"
        style={{
          width: "100%",
          height: "100%",
          minHeight: "100vh",
          backgroundColor: "#f8f9fa",
        }}
      >
        <Container fluid className="py-4">
          <Alert variant="warning" className="text-center">
            <h5>⚠️ No Company Selected</h5>
            <p className="mb-0">
              Please select a company to view and manage quotations.
            </p>
          </Alert>
        </Container>
      </div>
    );
  }

  if (!isOnline) {
    return (
      <div
        className="quotations-container"
        style={{
          width: "100%",
          height: "100%",
          minHeight: "100vh",
          backgroundColor: "#f8f9fa",
        }}
      >
        <Container fluid className="py-4">
          <Alert variant="warning" className="text-center">
            <h5>📡 No Internet Connection</h5>
            <p className="mb-0">
              Quotations data requires an internet connection.
            </p>
          </Alert>
        </Container>
      </div>
    );
  }

  if (!validateService()) {
    return (
      <div
        className="quotations-container"
        style={{
          width: "100%",
          height: "100%",
          minHeight: "100vh",
          backgroundColor: "#f8f9fa",
        }}
      >
        <Container fluid className="py-4">
          <Alert variant="danger" className="text-center">
            <h5>🔧 Service Unavailable</h5>
            <p className="mb-0">
              Sales order service is not available. Please check your
              configuration.
            </p>
            <div className="mt-3">
              <p className="small text-muted mb-2">Debug Information:</p>
              <ul className="small text-muted text-start list-unstyled">
                <li>
                  • Service object:{" "}
                  {saleOrderService ? "✅ Available" : "❌ Missing"}
                </li>
                <li>
                  • getSalesOrders method:{" "}
                  {saleOrderService?.getSalesOrders
                    ? "✅ Available"
                    : "❌ Missing"}
                </li>
              </ul>
            </div>
            <Button
              variant="outline-danger"
              size="sm"
              className="mt-2"
              onClick={() => window.location.reload()}
            >
              <FontAwesomeIcon icon={faSync} className="me-1" />
              Reload Page
            </Button>
          </Alert>
        </Container>
      </div>
    );
  }

  // ✅ RENDER
  return (
    <div
      className="quotations-container"
      style={{
        width: "100%",
        height: "100%",
        minHeight: "100vh",
        backgroundColor: "#f8f9fa",
      }}
    >
      <SalesInvoicesPageTitle
        onAddSale={handleAddQuotation}
        invoiceCount={allQuotations.length}
        companyId={companyId}
        mode="quotations"
        documentType="quotation"
        title="Quotations"
        subtitle="Create and manage quotations with enhanced tracking"
      />

      <SalesInvoicesHeader
        searchTerm={searchTerm}
        onSearchChange={handleSearchChange}
        onAddSale={handleAddQuotation}
        onAddPurchase={() => {}}
        onMoreOptions={() => addToast?.("More options coming soon", "info")}
        onSettings={() => addToast?.("Settings coming soon", "info")}
        mode="quotations"
        documentType="quotation"
        pageTitle="Quotations"
        companyId={companyId}
      />

      <Container fluid>
        <Row>
          <Col lg={3} md={4} className="mb-4">
            <SalesInvoicesSummary
              summary={summary}
              loading={isLoading}
              dateRange={dateRange}
              mode="quotations"
              documentType="quotation"
              isQuotationsMode={true}
              showBidirectionalMetrics={true}
              bidirectionalCount={summary.bidirectionalCount}
              autoGeneratedCount={summary.autoGeneratedCount}
              sourceCompanyLinkedCount={summary.sourceCompanyLinkedCount}
            />
          </Col>

          <Col lg={9} md={8}>
            <SalesInvoicesFilter
              dateRange={dateRange}
              startDate={startDate}
              endDate={endDate}
              selectedFirm={selectedFirm}
              dateRangeOptions={dateRangeOptions}
              firmOptions={firmOptions}
              onDateRangeChange={handleDateRangeChange}
              onStartDateChange={handleStartDateChange}
              onEndDateChange={handleEndDateChange}
              onFirmChange={handleFirmChange}
              onExcelExport={() =>
                addToast?.("Excel export coming soon", "info")
              }
              onPrint={() => addToast?.("Print coming soon", "info")}
              resultCount={allQuotations.length}
              mode="quotations"
              documentType="quotation"
              pageTitle="Quotations"
              showBidirectionalFilters={true}
              onToggleBidirectionalAnalytics={() =>
                setShowBidirectionalAnalytics(!showBidirectionalAnalytics)
              }
              showBidirectionalAnalytics={showBidirectionalAnalytics}
            />

            {error && (
              <Alert variant="danger" className="mb-3">
                <FontAwesomeIcon
                  icon={faExclamationTriangle}
                  className="me-2"
                />
                {error}
                <Button
                  variant="outline-danger"
                  size="sm"
                  className="ms-2"
                  onClick={() => {
                    setError(null);
                    handleRefresh();
                  }}
                >
                  <FontAwesomeIcon icon={faSync} className="me-1" />
                  Retry
                </Button>
              </Alert>
            )}

            <Card className="border-0 shadow-sm">
              <Card.Body className="p-0">
                <SalesOrderTable
                  salesOrders={allQuotations}
                  onViewOrder={handleEditQuotation}
                  onEditOrder={handleEditQuotation}
                  onDeleteOrder={handleDeleteQuotation}
                  onPrintOrder={(quotation) =>
                    addToast?.(
                      `Printing quotation ${
                        quotation.quotationNumber || quotation.orderNumber
                      }...`,
                      "info"
                    )
                  }
                  onShareOrder={(quotation) =>
                    addToast?.(
                      `Sharing quotation ${
                        quotation.quotationNumber || quotation.orderNumber
                      }...`,
                      "info"
                    )
                  }
                  onDownloadOrder={(quotation) =>
                    addToast?.(
                      `Downloading quotation ${
                        quotation.quotationNumber || quotation.orderNumber
                      }...`,
                      "info"
                    )
                  }
                  onConvertOrder={handleConvertQuotation}
                  onDuplicateOrder={handleDuplicateQuotation}
                  isLoading={isLoading}
                  title="Quotations"
                  searchPlaceholder="Search quotations, customers, mobile..."
                  companyId={companyId}
                  addToast={addToast}
                  currentUser={currentUser}
                  currentCompany={currentCompany}
                  searchTerm={searchTerm}
                  onSearchChange={handleSearchChange}
                  sortBy={sortBy}
                  sortOrder={sortOrder}
                  onSort={handleSort}
                  filterStatus={filterStatus}
                  onFilterChange={handleFilterChange}
                  showHeader={false}
                  enableActions={true}
                  enableBulkActions={true}
                  selectedOrders={selectedQuotations}
                  onSelectionChange={setSelectedQuotations}
                  showBidirectionalColumns={true}
                  documentType="quotation"
                  isQuotationsMode={true}
                  saleOrderService={saleOrderService} // ✅ Pass service to SalesOrderTable
                  onConfirmOrder={(quotation) => {
                    addToast?.(
                      `Confirming quotation ${
                        quotation.quotationNumber || quotation.orderNumber
                      }...`,
                      "info"
                    );
                  }}
                  onApproveOrder={(quotation) => {
                    addToast?.(
                      `Approving quotation ${
                        quotation.quotationNumber || quotation.orderNumber
                      }...`,
                      "info"
                    );
                  }}
                  onCancelOrder={(quotation) => {
                    const confirmed = window.confirm(
                      `Are you sure you want to cancel quotation ${
                        quotation.quotationNumber || quotation.orderNumber
                      }?`
                    );
                    if (confirmed) {
                      loadQuotations();
                      loadBidirectionalAnalytics();
                    }
                  }}
                  onViewTrackingChain={handleViewTrackingChain}
                  // ✅ NO onGeneratePurchaseOrder - SalesOrderTable uses internal modal
                  onViewSourceOrder={handleViewSourceOrder}
                  onViewGeneratedOrders={handleViewGeneratedOrders}
                  bidirectionalOrders={bidirectionalOrders}
                  showBidirectionalAnalytics={showBidirectionalAnalytics}
                  onToggleBidirectionalAnalytics={() =>
                    setShowBidirectionalAnalytics(!showBidirectionalAnalytics)
                  }
                  enableEnhancedTracking={true}
                  showSourceCompanyColumn={true}
                  showGeneratedOrdersColumn={true}
                  enableQuickNavigation={true}
                />
              </Card.Body>
            </Card>
          </Col>
        </Row>
      </Container>
    </div>
  );
}

export default Quotations;
