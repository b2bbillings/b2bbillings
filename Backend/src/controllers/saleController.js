const mongoose = require("mongoose");
const Sale = require("../models/Sale");
const Item = require("../models/Item");
const Party = require("../models/Party");
const saleController = {
  // ‚úÖ UPDATED: Generate actual preview invoice number (not just pattern)
  getNextInvoiceNumber: async (req, res) => {
    try {
      const {companyId, invoiceType = "gst"} = req.query;

      if (!companyId) {
        return res.status(400).json({
          success: false,
          message: "Company ID is required",
        });
      }

      console.log(
        "üî¢ Generating preview invoice number for company:",
        companyId
      );

      // ‚úÖ Get company details
      const Company = require("../models/Company");
      const company = await Company.findById(companyId).select(
        "businessName code gstin"
      );

      if (!company) {
        return res.status(400).json({
          success: false,
          message: "Company not found",
        });
      }

      // ‚úÖ Generate preview invoice number using same logic as model
      const today = new Date();
      const year = today.getFullYear();
      const month = String(today.getMonth() + 1).padStart(2, "0");
      const day = String(today.getDate()).padStart(2, "0");
      const dateStr = `${year}${month}${day}`;

      // Get company prefix (same as model logic)
      let companyPrefix = "INV";
      if (company?.code) {
        companyPrefix = company.code
          .toUpperCase()
          .replace(/[^A-Z0-9]/g, "")
          .substring(0, 6);
      } else if (company?.businessName) {
        companyPrefix = company.businessName
          .replace(/[^A-Za-z]/g, "")
          .substring(0, 3)
          .toUpperCase();
      }

      // ‚úÖ Find the next sequence number for today
      const todayStart = new Date(year, today.getMonth(), today.getDate());
      const todayEnd = new Date(year, today.getMonth(), today.getDate() + 1);

      const latestInvoice = await Sale.findOne({
        companyId: companyId,
        invoiceDate: {$gte: todayStart, $lt: todayEnd},
        invoiceNumber: {$exists: true, $ne: null},
      })
        .sort({invoiceNumber: -1})
        .select("invoiceNumber");

      let nextSequence = 1;
      if (latestInvoice && latestInvoice.invoiceNumber) {
        // Extract sequence from invoice number pattern: PREFIX-GST-YYYYMMDD-XXXX
        const match = latestInvoice.invoiceNumber.match(/-(\d{4})$/);
        if (match) {
          nextSequence = parseInt(match[1], 10) + 1;
        }
      }

      const sequenceStr = String(nextSequence).padStart(4, "0");

      // ‚úÖ Generate actual preview number (same format as model)
      const gstPrefix = invoiceType === "gst" ? "GST-" : "";
      const previewInvoiceNumber = `${companyPrefix}-${gstPrefix}${dateStr}-${sequenceStr}`;

      console.log("‚úÖ Preview invoice number generated:", {
        companyId,
        companyPrefix,
        dateStr,
        nextSequence,
        previewInvoiceNumber,
      });

      res.status(200).json({
        success: true,
        data: {
          previewInvoiceNumber,
          nextInvoiceNumber: previewInvoiceNumber, // ‚úÖ Actual preview number
          invoiceType,
          company: {
            id: company._id,
            name: company.businessName,
            code: company.code,
            prefix: companyPrefix,
          },
          numbering: {
            prefix: companyPrefix,
            gstPrefix: invoiceType === "gst" ? "GST-" : "",
            dateString: dateStr,
            sequence: nextSequence,
            formattedSequence: sequenceStr,
          },
          pattern: `${companyPrefix}-[GST-]YYYYMMDD-XXXX`,
          date: today.toISOString().split("T")[0],
          isSequential: true,
          companySpecific: true,
          isPreview: true, // ‚úÖ This is a preview number
          actualNumberGeneratedBy: "model_pre_save_middleware",
          note: "This is a preview. Actual number will be confirmed when saving.",
        },
        message: "Preview invoice number generated successfully",
      });
    } catch (error) {
      console.error("‚ùå Error generating preview invoice number:", error);
      res.status(500).json({
        success: false,
        message: "Failed to generate preview invoice number",
        error: error.message,
      });
    }
  },

  createSale: async (req, res) => {
    try {
      const {
        customerName,
        customerMobile,
        customer,
        customerId,
        // ‚ùå REMOVED: invoiceNumber, // Don't accept manual invoice numbers
        invoiceDate,
        gstEnabled = true,
        companyId,
        items,
        payment,
        notes,
        termsAndConditions,
        roundOff = 0,
        roundOffEnabled = false,
        status = "draft",
        taxMode = "without-tax",
        priceIncludesTax = false,
        sourceOrderId,
        sourceOrderNumber,
        sourceOrderType = "sales_order",
        sourceCompanyId,
        isAutoGenerated = false,
        generatedFrom = "manual",
        convertedBy,
        autoDetectSourceCompany = true,
      } = req.body;

      console.log(
        "üì• Creating sale with model-based automatic invoice numbering:",
        {
          customerName,
          customer,
          customerId,
          taxMode,
          priceIncludesTax,
          gstEnabled,
          itemCount: items?.length || 0,
          companyId,
          sourceOrderId,
          sourceOrderType,
          sourceCompanyId,
          isAutoGenerated,
          generatedFrom,
          autoDetectSourceCompany,
          modelHandlesNumbering: true, // ‚úÖ Clear indication
        }
      );

      // Validate required fields
      if (!companyId || !items || items.length === 0) {
        return res.status(400).json({
          success: false,
          message: "Company ID and Items are required",
        });
      }

      // ‚úÖ Get company details for response only (not for numbering)
      const Company = require("../models/Company");
      const currentCompany = await Company.findById(companyId).select(
        "businessName code gstin"
      );

      if (!currentCompany) {
        return res.status(400).json({
          success: false,
          message: "Company not found",
        });
      }

      console.log(
        "üè¢ Company details (model will handle numbering automatically):",
        {
          companyId,
          businessName: currentCompany.businessName,
          code: currentCompany.code,
          modelHandlesInvoiceNumberGeneration: true, // ‚úÖ Emphasize model responsibility
        }
      );

      // ‚úÖ Handle customer validation (existing code)
      let customerRecord = null;
      const finalCustomerId = customer || customerId;

      if (finalCustomerId && mongoose.Types.ObjectId.isValid(finalCustomerId)) {
        console.log("üîç Finding customer by ID:", finalCustomerId);
        customerRecord = await Party.findById(finalCustomerId);

        if (!customerRecord) {
          return res.status(400).json({
            success: false,
            message: "Customer not found with provided ID",
          });
        }

        console.log("‚úÖ Found customer:", {
          id: customerRecord._id,
          name: customerRecord.name,
          mobile: customerRecord.mobile,
          customerCompanyId: customerRecord.companyId,
          linkedCompanyId: customerRecord.linkedCompanyId,
        });
      } else if (customerName && customerMobile) {
        console.log(
          "üîç Finding customer by name and mobile:",
          customerName,
          customerMobile
        );

        customerRecord = await Party.findOne({
          $and: [
            {companyId: companyId},
            {type: "customer"},
            {
              $or: [{mobile: customerMobile}, {phoneNumber: customerMobile}],
            },
          ],
        });

        if (!customerRecord) {
          customerRecord = await Party.findOne({
            companyId: companyId,
            type: "customer",
            name: {$regex: new RegExp(`^${customerName}$`, "i")},
          });
        }

        if (!customerRecord) {
          return res.status(400).json({
            success: false,
            message:
              "Customer not found. Please select an existing customer or create one first.",
          });
        }

        console.log("‚úÖ Found customer by search:", {
          id: customerRecord._id,
          name: customerRecord.name,
          mobile: customerRecord.mobile,
          customerCompanyId: customerRecord?.companyId,
          linkedCompanyId: customerRecord?.linkedCompanyId,
        });
      } else {
        return res.status(400).json({
          success: false,
          message: "Customer ID or customer name and mobile are required",
        });
      }

      // FIXED: Sync tax mode fields
      const finalTaxMode =
        taxMode || (priceIncludesTax ? "with-tax" : "without-tax");
      const finalPriceIncludesTax = finalTaxMode === "with-tax";

      console.log("üîÑ Tax mode synchronization:", {
        originalTaxMode: taxMode,
        originalPriceIncludesTax: priceIncludesTax,
        finalTaxMode,
        finalPriceIncludesTax,
      });

      // Process items (existing code continues...)
      const processedItems = [];
      let subtotal = 0;
      let totalDiscount = 0;
      let totalTax = 0;
      let totalTaxableAmount = 0;

      for (let i = 0; i < items.length; i++) {
        const item = items[i];

        console.log(`üîÑ Processing item ${i + 1}:`, {
          itemName: item.itemName,
          quantity: item.quantity,
          pricePerUnit: item.pricePerUnit,
          taxRate: item.taxRate,
        });

        // Basic validation
        if (!item.itemName || !item.quantity || !item.pricePerUnit) {
          return res.status(400).json({
            success: false,
            message: `Item ${i + 1}: Name, quantity, and price are required`,
          });
        }

        // Parse item values
        const quantity = parseFloat(item.quantity);
        const pricePerUnit = parseFloat(item.pricePerUnit);
        const discountPercent = parseFloat(item.discountPercent || 0);
        const discountAmount = parseFloat(item.discountAmount || 0);
        const taxRate = parseFloat(item.taxRate || 18);

        // Validate numeric values
        if (
          isNaN(quantity) ||
          isNaN(pricePerUnit) ||
          quantity <= 0 ||
          pricePerUnit < 0
        ) {
          return res.status(400).json({
            success: false,
            message: `Item ${i + 1}: Invalid quantity or price values`,
          });
        }

        // FIXED: Determine item-level tax mode
        const itemTaxMode = item.taxMode || finalTaxMode;
        const itemPriceIncludesTax = itemTaxMode === "with-tax";

        // Calculate base amount
        const baseAmount = quantity * pricePerUnit;

        // Calculate discount
        let itemDiscountAmount = discountAmount;
        if (discountAmount === 0 && discountPercent > 0) {
          itemDiscountAmount = (baseAmount * discountPercent) / 100;
        }

        const amountAfterDiscount = baseAmount - itemDiscountAmount;

        // Calculate taxes
        let cgst = 0;
        let sgst = 0;
        let igst = 0;
        let itemAmount = 0;
        let itemTaxableAmount = 0;

        if (gstEnabled && taxRate > 0) {
          const cgstRate = taxRate / 2;
          const sgstRate = taxRate / 2;

          if (itemPriceIncludesTax) {
            const taxMultiplier = 1 + taxRate / 100;
            itemTaxableAmount = amountAfterDiscount / taxMultiplier;
            cgst = (itemTaxableAmount * cgstRate) / 100;
            sgst = (itemTaxableAmount * sgstRate) / 100;
            itemAmount = amountAfterDiscount;
          } else {
            itemTaxableAmount = amountAfterDiscount;
            cgst = (itemTaxableAmount * cgstRate) / 100;
            sgst = (itemTaxableAmount * sgstRate) / 100;
            itemAmount = itemTaxableAmount + cgst + sgst;
          }
        } else {
          itemTaxableAmount = amountAfterDiscount;
          itemAmount = amountAfterDiscount;
        }

        // Update totals
        subtotal += baseAmount;
        totalDiscount += itemDiscountAmount;
        totalTaxableAmount += itemTaxableAmount;
        const itemTotalTax = cgst + sgst + igst;
        totalTax += itemTotalTax;

        // Create processed item
        const processedItem = {
          itemRef: item.itemRef || null,
          itemName: item.itemName.trim(),
          itemCode: item.itemCode || "",
          hsnCode: item.hsnCode || "0000",
          category: item.category || "",
          quantity,
          unit: item.unit || "PCS",
          pricePerUnit,
          taxRate: taxRate,
          taxMode: itemTaxMode,
          priceIncludesTax: itemPriceIncludesTax,
          discountPercent,
          discountAmount: parseFloat(itemDiscountAmount.toFixed(2)),
          cgst: parseFloat(cgst.toFixed(2)),
          sgst: parseFloat(sgst.toFixed(2)),
          igst: parseFloat(igst.toFixed(2)),
          cgstAmount: parseFloat(cgst.toFixed(2)),
          sgstAmount: parseFloat(sgst.toFixed(2)),
          igstAmount: parseFloat(igst.toFixed(2)),
          taxableAmount: parseFloat(itemTaxableAmount.toFixed(2)),
          totalTaxAmount: parseFloat(itemTotalTax.toFixed(2)),
          amount: parseFloat(itemAmount.toFixed(2)),
          itemAmount: parseFloat(itemAmount.toFixed(2)),
          lineNumber: i + 1,
        };

        processedItems.push(processedItem);

        console.log(`‚úÖ Item ${i + 1} processed:`, {
          itemName: processedItem.itemName,
          taxableAmount: processedItem.taxableAmount,
          totalTax: processedItem.totalTaxAmount,
          finalAmount: processedItem.amount,
        });
      }

      // Calculate final totals
      const finalTotal = processedItems.reduce(
        (sum, item) => sum + item.amount,
        0
      );

      // Apply round off if enabled
      let appliedRoundOff = 0;
      let adjustedFinalTotal = finalTotal;
      if (roundOffEnabled && roundOff !== 0) {
        appliedRoundOff = parseFloat(roundOff);
        adjustedFinalTotal = finalTotal + appliedRoundOff;
      }

      // Prepare totals object
      const totals = {
        subtotal: parseFloat(subtotal.toFixed(2)),
        totalQuantity: processedItems.reduce(
          (sum, item) => sum + item.quantity,
          0
        ),
        totalDiscount: parseFloat(totalDiscount.toFixed(2)),
        totalTax: parseFloat(totalTax.toFixed(2)),
        totalCGST: parseFloat(
          processedItems.reduce((sum, item) => sum + item.cgst, 0).toFixed(2)
        ),
        totalSGST: parseFloat(
          processedItems.reduce((sum, item) => sum + item.sgst, 0).toFixed(2)
        ),
        totalIGST: parseFloat(
          processedItems.reduce((sum, item) => sum + item.igst, 0).toFixed(2)
        ),
        totalTaxableAmount: parseFloat(totalTaxableAmount.toFixed(2)),
        finalTotal: parseFloat(adjustedFinalTotal.toFixed(2)),
        roundOff: parseFloat(appliedRoundOff.toFixed(2)),
      };

      console.log("üí∞ Final totals calculated:", totals);

      // Enhanced payment details
      const paymentDetails = {
        method: payment?.method || "cash",
        status: payment?.status || "pending",
        paidAmount: parseFloat(payment?.paidAmount || 0),
        pendingAmount: 0,
        paymentDate: payment?.paymentDate
          ? new Date(payment.paymentDate)
          : new Date(),
        dueDate: payment?.dueDate ? new Date(payment.dueDate) : null,
        creditDays: parseInt(payment?.creditDays || 0),
        reference: payment?.reference || "",
        notes: payment?.notes || "",
        bankAccountId: payment?.bankAccountId || null,
        bankAccountName: payment?.bankAccountName || null,
      };

      const paidAmount = paymentDetails.paidAmount;
      paymentDetails.pendingAmount = parseFloat(
        (adjustedFinalTotal - paidAmount).toFixed(2)
      );

      // Auto-determine payment status
      if (paidAmount >= adjustedFinalTotal) {
        paymentDetails.status = "paid";
        paymentDetails.pendingAmount = 0;
        paymentDetails.dueDate = null;
      } else if (paidAmount > 0) {
        paymentDetails.status = "partial";
        if (paymentDetails.creditDays > 0 && !paymentDetails.dueDate) {
          const dueDate = new Date();
          dueDate.setDate(dueDate.getDate() + paymentDetails.creditDays);
          paymentDetails.dueDate = dueDate;
        }
      } else {
        paymentDetails.status = "pending";
        paymentDetails.pendingAmount = adjustedFinalTotal;
        if (paymentDetails.creditDays > 0 && !paymentDetails.dueDate) {
          const dueDate = new Date();
          dueDate.setDate(dueDate.getDate() + paymentDetails.creditDays);
          paymentDetails.dueDate = dueDate;
        }
      }

      if (paymentDetails.pendingAmount < 0) {
        paymentDetails.pendingAmount = 0;
      }

      // Initialize payment history
      let paymentHistory = [];
      if (paidAmount > 0) {
        paymentHistory.push({
          amount: paidAmount,
          method: paymentDetails.method,
          reference: paymentDetails.reference,
          paymentDate: paymentDetails.paymentDate,
          bankAccountId: paymentDetails.bankAccountId,
          bankAccountName: paymentDetails.bankAccountName,
          notes: paymentDetails.notes || "Initial payment",
          createdAt: new Date(),
          createdBy: req.user?.id || "system",
        });
      }

      // Enhanced source company detection
      let finalNotes = notes || "";
      if (sourceOrderId && sourceOrderType) {
        const conversionNote = `Converted from ${sourceOrderType} ${
          sourceOrderNumber || sourceOrderId
        }`;
        finalNotes = finalNotes
          ? `${finalNotes} | ${conversionNote}`
          : conversionNote;
      }

      let finalSourceCompanyId = sourceCompanyId;
      let sourceCompanyDetectionMethod = sourceCompanyId ? "manual" : "none";

      // ‚úÖ Create sale object WITHOUT manual invoiceNumber - model will auto-generate
      const saleData = {
        invoiceDate: invoiceDate ? new Date(invoiceDate) : new Date(),
        invoiceType: gstEnabled ? "gst" : "non-gst",
        customer: customerRecord._id,
        // ‚ùå NO invoiceNumber field - let model's pre-save middleware generate it
        customerMobile: customerRecord.mobile || customerMobile,
        gstEnabled,
        taxMode: finalTaxMode,
        priceIncludesTax: finalPriceIncludesTax,
        companyId, // ‚úÖ Required for model's automatic numbering
        items: processedItems,
        totals,
        payment: paymentDetails,
        paymentHistory: paymentHistory,
        notes: finalNotes,
        termsAndConditions: termsAndConditions || "",
        status,

        // Enhanced source tracking
        sourceOrderId: sourceOrderId || null,
        sourceOrderNumber: sourceOrderNumber || null,
        sourceOrderType: sourceOrderId ? sourceOrderType : null,

        ...(finalSourceCompanyId && {
          sourceCompanyId: finalSourceCompanyId,
          isCrossCompanyTransaction: true,
          customerCompanyId: customerRecord?.companyId || null,
          sourceCompanyDetectionMethod: sourceCompanyDetectionMethod,
        }),

        ...(!finalSourceCompanyId && {
          isCrossCompanyTransaction: false,
          customerCompanyId: null,
          sourceCompanyDetectionMethod: sourceCompanyDetectionMethod,
        }),

        isAutoGenerated: isAutoGenerated || false,
        generatedFrom: sourceOrderId ? "sales_order" : generatedFrom,
        convertedBy: convertedBy || null,

        autoGeneratedPurchaseInvoice: false,
        purchaseInvoiceRef: null,
        purchaseInvoiceNumber: null,
        targetCompanyId: null,

        convertedFromSalesOrder:
          !!sourceOrderId && sourceOrderType === "sales_order",
        salesOrderRef:
          sourceOrderId && sourceOrderType === "sales_order"
            ? sourceOrderId
            : null,
        salesOrderNumber:
          sourceOrderId && sourceOrderType === "sales_order"
            ? sourceOrderNumber
            : null,

        correspondingPurchaseInvoiceId: null,
        correspondingPurchaseInvoiceNumber: null,
        correspondingPurchaseInvoiceCompany: null,

        createdBy: req.user?.id || "system",
        lastModifiedBy: req.user?.id || "system",
      };

      console.log(
        "üíæ Creating sale - model will auto-generate invoice number:",
        {
          companyId: companyId.toString(),
          companyName: currentCompany.businessName,
          companyCode: currentCompany.code,
          customer: customerRecord.name,
          itemCount: saleData.items.length,
          finalTotal: saleData.totals.finalTotal,
          modelHandlesNumbering: true, // ‚úÖ Emphasize model responsibility
        }
      );

      // ‚úÖ Create the sale - invoice number will be auto-generated by model's pre-save middleware
      const sale = new Sale(saleData);
      await sale.save(); // ‚úÖ Model's pre-save middleware generates invoiceNumber automatically

      // Populate customer details for response
      await sale.populate(
        "customer",
        "name mobile email address type companyId linkedCompanyId"
      );

      // Update item stock
      for (const item of processedItems) {
        if (item.itemRef && mongoose.Types.ObjectId.isValid(item.itemRef)) {
          try {
            await Item.findByIdAndUpdate(
              item.itemRef,
              {$inc: {currentStock: -item.quantity}},
              {new: true}
            );
            console.log(
              `üì¶ Updated stock for item ${item.itemName}: -${item.quantity}`
            );
          } catch (stockError) {
            console.warn("Stock update failed:", stockError.message);
          }
        }
      }

      // Update source sales order if conversion
      if (sourceOrderId && mongoose.Types.ObjectId.isValid(sourceOrderId)) {
        try {
          const SalesOrder = require("../models/SalesOrder");
          await SalesOrder.findByIdAndUpdate(sourceOrderId, {
            convertedToInvoice: true,
            invoiceRef: sale._id,
            invoiceNumber: sale.invoiceNumber,
            convertedAt: new Date(),
            convertedBy: convertedBy || req.user?.id || "system",
            status: "completed",
          });

          console.log("üîó Updated source sales order:", {
            sourceOrderId,
            invoiceId: sale._id,
            invoiceNumber: sale.invoiceNumber,
          });
        } catch (updateError) {
          console.warn(
            "Failed to update source sales order:",
            updateError.message
          );
        }
      }

      console.log(
        "‚úÖ Sale created successfully with model-generated sequential numbering:",
        {
          id: sale._id,
          invoiceNumber: sale.invoiceNumber, // ‚úÖ Generated by model's pre-save middleware
          companyId: sale.companyId.toString(),
          companyName: currentCompany.businessName,
          customer: customerRecord.name,
          finalTotal: sale.totals.finalTotal,
          numberingSource: "model_pre_save_middleware", // ‚úÖ Clear source
        }
      );

      // ‚úÖ Enhanced response
      res.status(201).json({
        success: true,
        message:
          "Sale created successfully with automatic model-based sequential invoice numbering",
        data: {
          sale,
          invoice: {
            invoiceNumber: sale.invoiceNumber, // ‚úÖ Generated by model
            invoiceDate: sale.invoiceDate,
            companyInfo: {
              id: currentCompany._id,
              name: currentCompany.businessName,
              code: currentCompany.code,
              prefix: sale.invoiceNumber.split("-")[0], // Extract prefix from generated number
            },
            customer: {
              id: customerRecord._id,
              name: customerRecord.name,
              mobile: customerRecord.mobile,
              companyId: customerRecord.companyId,
              linkedCompanyId: customerRecord.linkedCompanyId,
            },
            totals: sale.totals,
            payment: {
              ...sale.payment,
              dueDate: sale.payment.dueDate,
              creditDays: sale.payment.creditDays,
            },
            taxMode: sale.taxMode,
            priceIncludesTax: sale.priceIncludesTax,
            gstEnabled: sale.gstEnabled,
            numberingInfo: {
              isSequential: true,
              companySpecific: true,
              autoGenerated: true,
              generatedBy: "model_pre_save_middleware", // ‚úÖ Clear source
              pattern: `${
                sale.invoiceNumber.split("-")[0]
              }-[GST-]YYYYMMDD-XXXX`,
              modelBased: true, // ‚úÖ Indicate model-based generation
            },
          },
        },
      });
    } catch (error) {
      console.error(
        "‚ùå Error creating sale with model-based numbering:",
        error
      );
      res.status(500).json({
        success: false,
        message: "Failed to create sale",
        error: error.message,
      });
    }
  },

  getSaleById: async (req, res) => {
    try {
      const {id} = req.params;

      if (!mongoose.Types.ObjectId.isValid(id)) {
        return res.status(400).json({
          success: false,
          message: "Invalid sale ID",
        });
      }

      const sale = await Sale.findById(id)
        .populate("customer", "name mobile email address type gstNumber")
        .populate("items.itemRef", "name itemCode category currentStock");

      if (!sale) {
        return res.status(404).json({
          success: false,
          message: "Sale not found",
        });
      }

      // FIXED: Ensure backward compatibility for tax mode fields
      const compatibleSale = {
        ...sale.toObject(),
        taxMode:
          sale.taxMode || (sale.priceIncludesTax ? "with-tax" : "without-tax"),
        priceIncludesTax: sale.priceIncludesTax ?? sale.taxMode === "with-tax",
        items: sale.items.map((item) => ({
          ...item,
          taxMode: item.taxMode || sale.taxMode || "without-tax",
          priceIncludesTax:
            item.priceIncludesTax ?? item.taxMode === "with-tax",
          // Ensure frontend compatibility fields
          cgstAmount: item.cgstAmount || item.cgst || 0,
          sgstAmount: item.sgstAmount || item.sgst || 0,
          igstAmount: item.igstAmount || item.igst || 0,
          amount: item.amount || item.itemAmount || 0,
        })),
      };

      console.log("üì§ Sending sale data with tax mode compatibility:", {
        id: sale._id,
        taxMode: compatibleSale.taxMode,
        priceIncludesTax: compatibleSale.priceIncludesTax,
      });

      res.json({
        success: true,
        data: compatibleSale,
      });
    } catch (error) {
      console.error("‚ùå Error fetching sale:", error);
      res.status(500).json({
        success: false,
        message: "Failed to fetch sale",
        error: error.message,
      });
    }
  },

  addPayment: async (req, res) => {
    try {
      const {id} = req.params;
      const {
        amount,
        method = "cash",
        reference = "",
        paymentDate,
        dueDate,
        creditDays,
        notes = "",
      } = req.body;

      if (!mongoose.Types.ObjectId.isValid(id)) {
        return res.status(400).json({
          success: false,
          message: "Invalid sale ID",
        });
      }

      if (!amount || amount <= 0) {
        return res.status(400).json({
          success: false,
          message: "Valid payment amount is required",
        });
      }

      const sale = await Sale.findById(id);
      if (!sale) {
        return res.status(404).json({
          success: false,
          message: "Sale not found",
        });
      }

      const currentBalance = sale.balanceAmount;
      if (amount > currentBalance) {
        return res.status(400).json({
          success: false,
          message: `Payment amount cannot exceed balance amount of ‚Çπ${currentBalance.toFixed(
            2
          )}`,
        });
      }

      const newPaidAmount = sale.payment.paidAmount + parseFloat(amount);
      const newPendingAmount = sale.totals.finalTotal - newPaidAmount;

      let newPaymentStatus = "pending";
      let newDueDate = sale.payment.dueDate;

      if (newPaidAmount >= sale.totals.finalTotal) {
        newPaymentStatus = "paid";
        newDueDate = null;
      } else if (newPaidAmount > 0) {
        newPaymentStatus = "partial";

        if (dueDate) {
          newDueDate = new Date(dueDate);
        } else if (creditDays && creditDays > 0) {
          const calculatedDueDate = new Date();
          calculatedDueDate.setDate(
            calculatedDueDate.getDate() + parseInt(creditDays)
          );
          newDueDate = calculatedDueDate;
        }
      }

      if (newDueDate && new Date() > newDueDate && newPendingAmount > 0) {
        newPaymentStatus = "overdue";
      }

      sale.payment = {
        ...sale.payment,
        method: method,
        status: newPaymentStatus,
        paidAmount: parseFloat(newPaidAmount.toFixed(2)),
        pendingAmount: parseFloat(Math.max(0, newPendingAmount).toFixed(2)),
        paymentDate: paymentDate ? new Date(paymentDate) : new Date(),
        dueDate: newDueDate,
        creditDays: creditDays ? parseInt(creditDays) : sale.payment.creditDays,
        reference: reference,
        notes: notes,
      };

      if (!sale.paymentHistory) {
        sale.paymentHistory = [];
      }

      sale.paymentHistory.push({
        amount: parseFloat(amount),
        method,
        reference,
        paymentDate: paymentDate ? new Date(paymentDate) : new Date(),
        dueDate: newDueDate,
        notes,
        createdAt: new Date(),
        createdBy: req.user?.id || "system",
      });

      await sale.save();

      res.status(200).json({
        success: true,
        message: "Payment added successfully",
        data: {
          invoiceNumber: sale.invoiceNumber,
          totalAmount: sale.totals.finalTotal,
          paidAmount: sale.payment.paidAmount,
          pendingAmount: sale.payment.pendingAmount,
          paymentStatus: sale.payment.status,
          paymentMethod: sale.payment.method,
          paymentDate: sale.payment.paymentDate,
          dueDate: sale.payment.dueDate,
          creditDays: sale.payment.creditDays,
          isOverdue: sale.isOverdue,
          daysOverdue: sale.daysOverdue,
          paymentHistory: sale.paymentHistory,
          balanceAmount: sale.balanceAmount,
        },
      });
    } catch (error) {
      console.error("Error adding payment:", error);
      res.status(500).json({
        success: false,
        message: "Failed to add payment",
        error: error.message,
      });
    }
  },
  getAllSales: async (req, res) => {
    try {
      const {
        page = 1,
        limit = 10,
        companyId,
        customer,
        status,
        paymentStatus,
        invoiceType,
        dateFrom,
        dateTo,
        search,
      } = req.query;

      const filter = {};

      if (companyId) filter.companyId = companyId;
      if (customer) filter.customer = customer;
      if (status) filter.status = status;
      if (paymentStatus) filter["payment.status"] = paymentStatus;
      if (invoiceType) filter.invoiceType = invoiceType;

      if (dateFrom || dateTo) {
        filter.invoiceDate = {};
        if (dateFrom) filter.invoiceDate.$gte = new Date(dateFrom);
        if (dateTo) filter.invoiceDate.$lte = new Date(dateTo);
      }

      if (search) {
        filter.$or = [
          {invoiceNumber: {$regex: search, $options: "i"}},
          {customerMobile: {$regex: search, $options: "i"}},
          {notes: {$regex: search, $options: "i"}},
        ];
      }

      const skip = (parseInt(page) - 1) * parseInt(limit);

      const sales = await Sale.find(filter)
        .populate("customer", "name mobile email address type")
        .sort({createdAt: -1})
        .skip(skip)
        .limit(parseInt(limit));

      const transformedSales = sales.map((sale) => ({
        id: sale._id,
        invoiceNo: sale.invoiceNumber,
        date: sale.invoiceDate,
        partyName: sale.customer?.name || "Unknown",
        partyPhone: sale.customer?.mobile || sale.customerMobile,
        transaction: sale.invoiceType === "gst" ? "GST Invoice" : "Sale",
        paymentType: sale.payment?.method || "cash",
        amount: sale.totals?.finalTotal || 0,
        balance: sale.payment?.pendingAmount || 0,
        cgst: sale.items?.reduce((sum, item) => sum + (item.cgst || 0), 0) || 0,
        sgst: sale.items?.reduce((sum, item) => sum + (item.sgst || 0), 0) || 0,
        igst: sale.items?.reduce((sum, item) => sum + (item.igst || 0), 0) || 0,
        status: sale.status,
        paymentStatus: sale.payment?.status || "pending",
        // ‚úÖ NEW: Add source tracking
        isFromSalesOrder: sale.notes && sale.notes.includes("Converted from"),
        sourceType:
          sale.notes && sale.notes.includes("Converted from")
            ? "sales_order"
            : "direct",
        ...sale.toObject(),
      }));

      const totalSales = await Sale.countDocuments(filter);
      const totalPages = Math.ceil(totalSales / parseInt(limit));

      const summary = await Sale.aggregate([
        {$match: filter},
        {
          $group: {
            _id: null,
            totalAmount: {$sum: "$totals.finalTotal"},
            totalTax: {$sum: "$totals.totalTax"},
            totalDiscount: {$sum: "$totals.totalDiscount"},
            paidAmount: {$sum: "$payment.paidAmount"},
            pendingAmount: {$sum: "$payment.pendingAmount"},
          },
        },
      ]);

      res.status(200).json({
        success: true,
        data: {
          sales: transformedSales,
          pagination: {
            currentPage: parseInt(page),
            totalPages,
            totalSales,
            hasNext: parseInt(page) < totalPages,
            hasPrev: parseInt(page) > 1,
          },
          summary: summary[0] || {
            totalAmount: 0,
            totalTax: 0,
            totalDiscount: 0,
            paidAmount: 0,
            pendingAmount: 0,
          },
        },
      });
    } catch (error) {
      console.error("Error getting sales:", error);
      res.status(500).json({
        success: false,
        message: "Failed to get sales",
        error: error.message,
      });
    }
  },

  updateSale: async (req, res) => {
    try {
      const {id} = req.params;
      const updateData = req.body;

      console.log(
        "üîÑ Updating sale:",
        id,
        "with data:",
        Object.keys(updateData)
      );

      if (!mongoose.Types.ObjectId.isValid(id)) {
        return res.status(400).json({
          success: false,
          message: "Invalid sale ID",
        });
      }

      const existingSale = await Sale.findById(id);
      if (!existingSale) {
        return res.status(404).json({
          success: false,
          message: "Sale not found",
        });
      }

      // Check if sale can be updated
      if (
        existingSale.status === "completed" ||
        existingSale.status === "cancelled"
      ) {
        return res.status(400).json({
          success: false,
          message: "Cannot update completed or cancelled sales",
        });
      }

      // Store original items for stock adjustment
      const originalItems = existingSale.items || [];

      // FIXED: Process updated items if provided
      if (updateData.items && Array.isArray(updateData.items)) {
        console.log("üîÑ Processing updated items:", updateData.items.length);

        const processedItems = [];
        let subtotal = 0;
        let totalDiscount = 0;
        let totalTax = 0;
        let totalTaxableAmount = 0;

        // Get GST and tax mode settings
        const gstEnabled =
          updateData.gstEnabled ?? existingSale.gstEnabled ?? true;
        const taxMode =
          updateData.taxMode || existingSale.taxMode || "exclusive";
        const priceIncludesTax = taxMode === "inclusive";

        // Process each item
        for (let i = 0; i < updateData.items.length; i++) {
          const item = updateData.items[i];

          // Validate item
          if (!item.itemName || !item.quantity || !item.pricePerUnit) {
            return res.status(400).json({
              success: false,
              message: `Item ${i + 1}: Name, quantity, and price are required`,
            });
          }

          // Check stock availability if item reference exists
          if (item.itemRef && mongoose.Types.ObjectId.isValid(item.itemRef)) {
            const itemDetails = await Item.findById(item.itemRef);
            if (itemDetails) {
              // Find original quantity for this item
              const originalItem = originalItems.find(
                (orig) =>
                  orig.itemRef &&
                  orig.itemRef.toString() === item.itemRef.toString()
              );
              const originalQuantity = originalItem ? originalItem.quantity : 0;
              const quantityDifference = item.quantity - originalQuantity;

              // Check if we have enough stock for the increase
              if (
                quantityDifference > 0 &&
                itemDetails.currentStock < quantityDifference
              ) {
                return res.status(400).json({
                  success: false,
                  message: `Item ${i + 1} (${
                    item.itemName
                  }): Insufficient stock. Available: ${
                    itemDetails.currentStock
                  }, Required additional: ${quantityDifference}`,
                });
              }
            }
          }

          // Parse values
          const quantity = parseFloat(item.quantity);
          const pricePerUnit = parseFloat(item.pricePerUnit);
          const discountPercent = parseFloat(item.discountPercent || 0);
          const discountAmount = parseFloat(item.discountAmount || 0);
          const taxRate = parseFloat(item.taxRate || 18);

          // Calculate base amount
          const baseAmount = quantity * pricePerUnit;

          // Calculate discount
          let itemDiscountAmount = discountAmount;
          if (discountAmount === 0 && discountPercent > 0) {
            itemDiscountAmount = (baseAmount * discountPercent) / 100;
          }

          const amountAfterDiscount = baseAmount - itemDiscountAmount;

          // Calculate taxes
          let cgst = 0;
          let sgst = 0;
          let igst = 0;
          let itemAmount = 0;
          let itemTaxableAmount = 0;

          if (gstEnabled && taxRate > 0) {
            const cgstRate = taxRate / 2;
            const sgstRate = taxRate / 2;

            if (priceIncludesTax) {
              // Tax inclusive calculation
              const taxMultiplier = 1 + taxRate / 100;
              itemTaxableAmount = amountAfterDiscount / taxMultiplier;
              cgst = (itemTaxableAmount * cgstRate) / 100;
              sgst = (itemTaxableAmount * sgstRate) / 100;
              itemAmount = amountAfterDiscount;
            } else {
              // Tax exclusive calculation
              itemTaxableAmount = amountAfterDiscount;
              cgst = (itemTaxableAmount * cgstRate) / 100;
              sgst = (itemTaxableAmount * sgstRate) / 100;
              itemAmount = itemTaxableAmount + cgst + sgst;
            }
          } else {
            itemTaxableAmount = amountAfterDiscount;
            itemAmount = amountAfterDiscount;
          }

          // Update totals
          subtotal += baseAmount;
          totalDiscount += itemDiscountAmount;
          totalTaxableAmount += itemTaxableAmount;
          const itemTotalTax = cgst + sgst + igst;
          totalTax += itemTotalTax;

          // Create processed item
          const processedItem = {
            itemRef: item.itemRef || null,
            itemName: item.itemName.trim(),
            itemCode: item.itemCode || "",
            hsnCode: item.hsnCode || "0000",
            category: item.category || "",
            quantity,
            unit: item.unit || "PCS",
            pricePerUnit,
            taxRate,
            taxMode: item.taxMode || taxMode,
            priceIncludesTax,
            discountPercent,
            discountAmount: parseFloat(itemDiscountAmount.toFixed(2)),
            cgst: parseFloat(cgst.toFixed(2)),
            sgst: parseFloat(sgst.toFixed(2)),
            igst: parseFloat(igst.toFixed(2)),
            cgstAmount: parseFloat(cgst.toFixed(2)),
            sgstAmount: parseFloat(sgst.toFixed(2)),
            igstAmount: parseFloat(igst.toFixed(2)),
            taxableAmount: parseFloat(itemTaxableAmount.toFixed(2)),
            totalTaxAmount: parseFloat(itemTotalTax.toFixed(2)),
            amount: parseFloat(itemAmount.toFixed(2)),
            itemAmount: parseFloat(itemAmount.toFixed(2)),
            lineNumber: i + 1,
          };

          processedItems.push(processedItem);
        }

        // Calculate final totals
        const finalTotal = processedItems.reduce(
          (sum, item) => sum + item.amount,
          0
        );

        // Apply round off if enabled
        const roundOffEnabled =
          updateData.roundOffEnabled ?? existingSale.roundOffEnabled ?? false;
        const roundOff = updateData.roundOff || existingSale.roundOff || 0;
        let appliedRoundOff = 0;
        let adjustedFinalTotal = finalTotal;

        if (roundOffEnabled && roundOff !== 0) {
          appliedRoundOff = parseFloat(roundOff);
          adjustedFinalTotal = finalTotal + appliedRoundOff;
        }

        // Update totals
        updateData.totals = {
          subtotal: parseFloat(subtotal.toFixed(2)),
          totalQuantity: processedItems.reduce(
            (sum, item) => sum + item.quantity,
            0
          ),
          totalDiscount: parseFloat(totalDiscount.toFixed(2)),
          totalTax: parseFloat(totalTax.toFixed(2)),
          totalCGST: parseFloat(
            processedItems.reduce((sum, item) => sum + item.cgst, 0).toFixed(2)
          ),
          totalSGST: parseFloat(
            processedItems.reduce((sum, item) => sum + item.sgst, 0).toFixed(2)
          ),
          totalIGST: parseFloat(
            processedItems.reduce((sum, item) => sum + item.igst, 0).toFixed(2)
          ),
          totalTaxableAmount: parseFloat(totalTaxableAmount.toFixed(2)),
          finalTotal: parseFloat(adjustedFinalTotal.toFixed(2)),
          roundOff: parseFloat(appliedRoundOff.toFixed(2)),
        };

        updateData.items = processedItems;

        // FIXED: Update payment status based on new total
        if (updateData.totals.finalTotal !== existingSale.totals.finalTotal) {
          const currentPaidAmount = existingSale.payment.paidAmount;
          const newPendingAmount =
            updateData.totals.finalTotal - currentPaidAmount;

          updateData.payment = {
            ...existingSale.payment,
            pendingAmount: parseFloat(Math.max(0, newPendingAmount).toFixed(2)),
          };

          // Update payment status
          if (currentPaidAmount >= updateData.totals.finalTotal) {
            updateData.payment.status = "paid";
            updateData.payment.pendingAmount = 0;
          } else if (currentPaidAmount > 0) {
            updateData.payment.status = "partial";
          } else {
            updateData.payment.status = "pending";
            updateData.payment.pendingAmount = updateData.totals.finalTotal;
          }
        }

        console.log(
          "‚úÖ Items processed, new total:",
          updateData.totals.finalTotal
        );
      }

      // Add update metadata
      updateData.lastModifiedBy = req.user?.id || "system";
      updateData.lastModifiedAt = new Date();

      // Update the sale
      const updatedSale = await Sale.findByIdAndUpdate(id, updateData, {
        new: true,
        runValidators: true,
      }).populate("customer", "name mobile email address");

      // FIXED: Adjust stock for item changes
      if (updateData.items) {
        // Create maps for easier comparison
        const originalItemsMap = new Map();
        const updatedItemsMap = new Map();

        originalItems.forEach((item) => {
          if (item.itemRef) {
            originalItemsMap.set(item.itemRef.toString(), item.quantity);
          }
        });

        updateData.items.forEach((item) => {
          if (item.itemRef) {
            updatedItemsMap.set(item.itemRef.toString(), item.quantity);
          }
        });

        // Process stock changes
        const allItemRefs = new Set([
          ...originalItemsMap.keys(),
          ...updatedItemsMap.keys(),
        ]);

        for (const itemRef of allItemRefs) {
          const originalQuantity = originalItemsMap.get(itemRef) || 0;
          const updatedQuantity = updatedItemsMap.get(itemRef) || 0;
          const quantityDifference = updatedQuantity - originalQuantity;

          if (
            quantityDifference !== 0 &&
            mongoose.Types.ObjectId.isValid(itemRef)
          ) {
            try {
              await Item.findByIdAndUpdate(
                itemRef,
                {$inc: {currentStock: -quantityDifference}},
                {new: true}
              );
              console.log(
                `üì¶ Stock adjusted for item ${itemRef}: ${
                  quantityDifference > 0 ? "-" : "+"
                }${Math.abs(quantityDifference)}`
              );
            } catch (stockError) {
              console.warn("Stock adjustment failed:", stockError.message);
            }
          }
        }
      }

      console.log("‚úÖ Sale updated successfully:", updatedSale.invoiceNumber);

      res.status(200).json({
        success: true,
        message: "Sale updated successfully",
        data: updatedSale,
      });
    } catch (error) {
      console.error("‚ùå Error updating sale:", error);
      res.status(500).json({
        success: false,
        message: "Failed to update sale",
        error: error.message,
      });
    }
  },

  deleteSale: async (req, res) => {
    try {
      const {id} = req.params;
      const {reason = "User requested deletion"} = req.body;

      console.log("üóëÔ∏è Deleting/Cancelling sale:", id);

      if (!mongoose.Types.ObjectId.isValid(id)) {
        return res.status(400).json({
          success: false,
          message: "Invalid sale ID",
        });
      }

      const sale = await Sale.findById(id).populate(
        "customer",
        "name mobile email"
      );
      if (!sale) {
        return res.status(404).json({
          success: false,
          message: "Sale not found",
        });
      }

      // Check if sale can be cancelled
      if (sale.status === "cancelled") {
        return res.status(400).json({
          success: false,
          message: "Sale is already cancelled",
        });
      }

      if (sale.status === "completed" && sale.payment.status === "paid") {
        return res.status(400).json({
          success: false,
          message:
            "Cannot cancel completed and fully paid sales. Please create a return/refund instead.",
        });
      }

      // FIXED: Restore stock for all items
      if (sale.items && sale.items.length > 0) {
        console.log("üì¶ Restoring stock for cancelled sale items...");

        for (const item of sale.items) {
          if (item.itemRef && mongoose.Types.ObjectId.isValid(item.itemRef)) {
            try {
              const updatedItem = await Item.findByIdAndUpdate(
                item.itemRef,
                {$inc: {currentStock: item.quantity}}, // Restore stock
                {new: true}
              );

              if (updatedItem) {
                console.log(
                  `‚úÖ Restored stock for ${item.itemName}: +${item.quantity} (New stock: ${updatedItem.currentStock})`
                );
              }
            } catch (stockError) {
              console.warn(
                `‚ö†Ô∏è Failed to restore stock for item ${item.itemName}:`,
                stockError.message
              );
            }
          }
        }
      }

      // FIXED: Handle payment cancellation
      const cancellationData = {
        status: "cancelled",
        lastModifiedBy: req.user?.id || "system",
        lastModifiedAt: new Date(),
        cancellationReason: reason,
        cancelledAt: new Date(),
      };

      // If there were payments made, record them in payment history
      if (sale.payment.paidAmount > 0) {
        if (!sale.paymentHistory) {
          sale.paymentHistory = [];
        }

        sale.paymentHistory.push({
          amount: -sale.payment.paidAmount, // Negative amount for refund/cancellation
          method: "cancellation",
          reference: `Cancellation of invoice ${sale.invoiceNumber}`,
          paymentDate: new Date(),
          notes: `Sale cancelled. Reason: ${reason}`,
          createdAt: new Date(),
          createdBy: req.user?.id || "system",
        });

        // Reset payment amounts
        cancellationData.payment = {
          ...sale.payment,
          paidAmount: 0,
          pendingAmount: 0,
          status: "cancelled",
        };

        // Add payment history
        cancellationData.paymentHistory = sale.paymentHistory;
      }

      // Update the sale
      const cancelledSale = await Sale.findByIdAndUpdate(id, cancellationData, {
        new: true,
      }).populate("customer", "name mobile email");

      console.log("‚úÖ Sale cancelled successfully:", sale.invoiceNumber);

      // OPTIONAL: Send notification (implement as needed)
      // await sendCancellationNotification(sale, reason);

      res.status(200).json({
        success: true,
        message: "Sale cancelled successfully",
        data: {
          invoiceNumber: cancelledSale.invoiceNumber,
          status: cancelledSale.status,
          cancellationReason: reason,
          cancelledAt: cancelledSale.cancelledAt,
          restoredItems: sale.items.length,
          refundAmount: sale.payment.paidAmount,
        },
      });
    } catch (error) {
      console.error("‚ùå Error deleting/cancelling sale:", error);
      res.status(500).json({
        success: false,
        message: "Failed to cancel sale",
        error: error.message,
      });
    }
  },

  completeSale: async (req, res) => {
    try {
      const {id} = req.params;

      if (!mongoose.Types.ObjectId.isValid(id)) {
        return res.status(400).json({
          success: false,
          message: "Invalid sale ID",
        });
      }

      const sale = await Sale.findById(id);
      if (!sale) {
        return res.status(404).json({
          success: false,
          message: "Sale not found",
        });
      }

      if (sale.status === "completed") {
        return res.status(400).json({
          success: false,
          message: "Sale is already completed",
        });
      }

      await sale.markAsCompleted();

      res.status(200).json({
        success: true,
        message: "Sale marked as completed",
        data: sale,
      });
    } catch (error) {
      console.error("Error completing sale:", error);
      res.status(500).json({
        success: false,
        message: "Failed to complete sale",
        error: error.message,
      });
    }
  },

  getTodaysSales: async (req, res) => {
    try {
      const {companyId} = req.query;

      if (!companyId) {
        return res.status(400).json({
          success: false,
          message: "Company ID is required",
        });
      }

      const sales = await Sale.getTodaysSales(companyId)
        .populate("customer", "name mobile")
        .select(
          "invoiceNumber invoiceDate totals.finalTotal payment.status items"
        );

      const summary = {
        totalSales: sales.length,
        totalAmount: sales.reduce(
          (sum, sale) => sum + sale.totals.finalTotal,
          0
        ),
        totalItems: sales.reduce((sum, sale) => sum + sale.items.length, 0),
        paidSales: sales.filter((sale) => sale.payment.status === "paid")
          .length,
        pendingSales: sales.filter((sale) => sale.payment.status === "pending")
          .length,
      };

      res.status(200).json({
        success: true,
        data: {
          sales,
          summary,
        },
      });
    } catch (error) {
      console.error("Error getting today's sales:", error);
      res.status(500).json({
        success: false,
        message: "Failed to get today's sales",
        error: error.message,
      });
    }
  },

  getSalesReport: async (req, res) => {
    try {
      const {companyId, startDate, endDate} = req.query;

      if (!companyId || !startDate || !endDate) {
        return res.status(400).json({
          success: false,
          message: "Company ID, start date, and end date are required",
        });
      }

      const start = new Date(startDate);
      const end = new Date(endDate);

      const report = await Sale.aggregate([
        {
          $match: {
            companyId: new mongoose.Types.ObjectId(companyId),
            invoiceDate: {$gte: start, $lte: end},
            status: {$ne: "cancelled"},
          },
        },
        {
          $group: {
            _id: null,
            totalSales: {$sum: "$totals.finalTotal"},
            totalInvoices: {$sum: 1},
            totalItems: {$sum: {$size: "$items"}},
            totalTax: {$sum: "$totals.totalTax"},
            avgInvoiceValue: {$avg: "$totals.finalTotal"},
            totalPaid: {$sum: "$payment.paidAmount"},
            totalPending: {$sum: "$payment.pendingAmount"},
          },
        },
      ]);

      res.status(200).json({
        success: true,
        data: report[0] || {
          totalSales: 0,
          totalInvoices: 0,
          totalItems: 0,
          totalTax: 0,
          avgInvoiceValue: 0,
          totalPaid: 0,
          totalPending: 0,
        },
      });
    } catch (error) {
      console.error("Error getting sales report:", error);
      res.status(500).json({
        success: false,
        message: "Failed to get sales report",
        error: error.message,
      });
    }
  },

  getDashboardData: async (req, res) => {
    try {
      const {companyId} = req.query;

      if (!companyId) {
        return res.status(400).json({
          success: false,
          message: "Company ID is required",
        });
      }

      const today = new Date();
      const startOfDay = new Date(
        today.getFullYear(),
        today.getMonth(),
        today.getDate()
      );
      const endOfDay = new Date(
        today.getFullYear(),
        today.getMonth(),
        today.getDate() + 1
      );
      const startOfMonth = new Date(today.getFullYear(), today.getMonth(), 1);
      const startOfWeek = new Date(
        today.setDate(today.getDate() - today.getDay())
      );

      const [todaysSales, weekSales, monthSales, recentSales, topCustomers] =
        await Promise.all([
          Sale.aggregate([
            {
              $match: {
                companyId: new mongoose.Types.ObjectId(companyId),
                invoiceDate: {$gte: startOfDay, $lt: endOfDay},
                status: {$ne: "cancelled"},
              },
            },
            {
              $group: {
                _id: null,
                totalSales: {$sum: "$totals.finalTotal"},
                totalInvoices: {$sum: 1},
              },
            },
          ]),

          Sale.aggregate([
            {
              $match: {
                companyId: new mongoose.Types.ObjectId(companyId),
                invoiceDate: {$gte: startOfWeek},
                status: {$ne: "cancelled"},
              },
            },
            {
              $group: {
                _id: null,
                totalSales: {$sum: "$totals.finalTotal"},
                totalInvoices: {$sum: 1},
              },
            },
          ]),

          Sale.aggregate([
            {
              $match: {
                companyId: new mongoose.Types.ObjectId(companyId),
                invoiceDate: {$gte: startOfMonth},
                status: {$ne: "cancelled"},
              },
            },
            {
              $group: {
                _id: null,
                totalSales: {$sum: "$totals.finalTotal"},
                totalInvoices: {$sum: 1},
              },
            },
          ]),

          Sale.find({companyId, status: {$ne: "cancelled"}})
            .populate("customer", "name mobile")
            .sort({createdAt: -1})
            .limit(5)
            .select(
              "invoiceNumber invoiceDate totals.finalTotal payment.status"
            ),

          Sale.aggregate([
            {
              $match: {
                companyId: new mongoose.Types.ObjectId(companyId),
                status: {$ne: "cancelled"},
              },
            },
            {
              $group: {
                _id: "$customer",
                totalPurchases: {$sum: "$totals.finalTotal"},
                invoiceCount: {$sum: 1},
              },
            },
            {
              $lookup: {
                from: "parties",
                localField: "_id",
                foreignField: "_id",
                as: "customerInfo",
              },
            },
            {$unwind: "$customerInfo"},
            {
              $project: {
                name: "$customerInfo.name",
                mobile: "$customerInfo.mobile",
                totalPurchases: 1,
                invoiceCount: 1,
              },
            },
            {$sort: {totalPurchases: -1}},
            {$limit: 5},
          ]),
        ]);

      res.status(200).json({
        success: true,
        data: {
          today: todaysSales[0] || {totalSales: 0, totalInvoices: 0},
          week: weekSales[0] || {totalSales: 0, totalInvoices: 0},
          month: monthSales[0] || {totalSales: 0, totalInvoices: 0},
          recentSales,
          topCustomers,
        },
      });
    } catch (error) {
      console.error("Error getting dashboard data:", error);
      res.status(500).json({
        success: false,
        message: "Failed to get dashboard data",
        error: error.message,
      });
    }
  },

  getPaymentStatus: async (req, res) => {
    try {
      const {id} = req.params;

      const sale = await Sale.findById(id).select(
        "payment totals paymentHistory"
      );

      if (!sale) {
        return res.status(404).json({
          success: false,
          message: "Sale not found",
        });
      }

      res.status(200).json({
        success: true,
        data: {
          paymentStatus: sale.payment.status,
          paidAmount: sale.payment.paidAmount,
          pendingAmount: sale.payment.pendingAmount,
          totalAmount: sale.totals.finalTotal,
          balanceAmount: sale.balanceAmount,
          paymentMethod: sale.payment.method,
          paymentDate: sale.payment.paymentDate,
          paymentHistory: sale.paymentHistory || [],
        },
      });
    } catch (error) {
      console.error("Error getting payment status:", error);
      res.status(500).json({
        success: false,
        message: "Failed to get payment status",
        error: error.message,
      });
    }
  },

  getMonthlyReport: async (req, res) => {
    try {
      const {
        companyId,
        year = new Date().getFullYear(),
        month = new Date().getMonth() + 1,
      } = req.query;

      const startDate = new Date(year, month - 1, 1);
      const endDate = new Date(year, month, 0, 23, 59, 59);

      const monthlyData = await Sale.aggregate([
        {
          $match: {
            companyId: new mongoose.Types.ObjectId(companyId),
            invoiceDate: {$gte: startDate, $lte: endDate},
            status: {$ne: "cancelled"},
          },
        },
        {
          $group: {
            _id: {$dayOfMonth: "$invoiceDate"},
            dailySales: {$sum: "$totals.finalTotal"},
            dailyInvoices: {$sum: 1},
            dailyItems: {$sum: {$size: "$items"}},
          },
        },
        {$sort: {_id: 1}},
      ]);

      const summary = await Sale.aggregate([
        {
          $match: {
            companyId: new mongoose.Types.ObjectId(companyId),
            invoiceDate: {$gte: startDate, $lte: endDate},
            status: {$ne: "cancelled"},
          },
        },
        {
          $group: {
            _id: null,
            totalSales: {$sum: "$totals.finalTotal"},
            totalInvoices: {$sum: 1},
            totalTax: {$sum: "$totals.totalTax"},
            avgDailySales: {$avg: "$totals.finalTotal"},
          },
        },
      ]);

      res.status(200).json({
        success: true,
        data: {
          monthlyBreakdown: monthlyData,
          summary: summary[0] || {
            totalSales: 0,
            totalInvoices: 0,
            totalTax: 0,
            avgDailySales: 0,
          },
          period: {year: parseInt(year), month: parseInt(month)},
        },
      });
    } catch (error) {
      console.error("Error getting monthly report:", error);
      res.status(500).json({
        success: false,
        message: "Failed to get monthly report",
        error: error.message,
      });
    }
  },

  getCustomerStats: async (req, res) => {
    try {
      const {companyId, customerId} = req.query;

      if (!customerId) {
        return res.status(400).json({
          success: false,
          message: "Customer ID is required",
        });
      }

      const customerStats = await Sale.aggregate([
        {
          $match: {
            companyId: new mongoose.Types.ObjectId(companyId),
            customer: new mongoose.Types.ObjectId(customerId),
            status: {$ne: "cancelled"},
          },
        },
        {
          $group: {
            _id: null,
            totalPurchases: {$sum: "$totals.finalTotal"},
            totalInvoices: {$sum: 1},
            totalItems: {$sum: {$size: "$items"}},
            avgInvoiceValue: {$avg: "$totals.finalTotal"},
            lastPurchaseDate: {$max: "$invoiceDate"},
            firstPurchaseDate: {$min: "$invoiceDate"},
          },
        },
      ]);

      const recentPurchases = await Sale.find({
        companyId,
        customer: customerId,
        status: {$ne: "cancelled"},
      })
        .sort({invoiceDate: -1})
        .limit(5)
        .select("invoiceNumber invoiceDate totals.finalTotal payment.status");

      res.status(200).json({
        success: true,
        data: {
          stats: customerStats[0] || {
            totalPurchases: 0,
            totalInvoices: 0,
            totalItems: 0,
            avgInvoiceValue: 0,
            lastPurchaseDate: null,
            firstPurchaseDate: null,
          },
          recentPurchases,
        },
      });
    } catch (error) {
      console.error("Error getting customer stats:", error);
      res.status(500).json({
        success: false,
        message: "Failed to get customer statistics",
        error: error.message,
      });
    }
  },

  validateStock: async (req, res) => {
    try {
      const {items} = req.body;

      if (!items || !Array.isArray(items)) {
        return res.status(400).json({
          success: false,
          message: "Items array is required",
        });
      }

      const stockValidation = [];

      for (const item of items) {
        if (item.itemRef) {
          const itemDetails = await Item.findById(item.itemRef);
          if (itemDetails) {
            const isAvailable =
              itemDetails.currentStock >= (item.quantity || 0);
            stockValidation.push({
              itemRef: item.itemRef,
              itemName: itemDetails.name,
              requestedQuantity: item.quantity,
              availableStock: itemDetails.currentStock,
              isAvailable,
              shortfall: isAvailable
                ? 0
                : item.quantity - itemDetails.currentStock,
            });
          } else {
            stockValidation.push({
              itemRef: item.itemRef,
              error: "Item not found",
            });
          }
        }
      }

      const allAvailable = stockValidation.every(
        (item) => item.isAvailable !== false
      );

      res.status(200).json({
        success: true,
        data: {
          allItemsAvailable: allAvailable,
          stockValidation,
        },
      });
    } catch (error) {
      console.error("Error validating stock:", error);
      res.status(500).json({
        success: false,
        message: "Failed to validate stock",
        error: error.message,
      });
    }
  },

  exportCSV: async (req, res) => {
    try {
      const {
        companyId,
        customer,
        status,
        paymentStatus,
        invoiceType,
        dateFrom,
        dateTo,
      } = req.query;

      const filter = {companyId};
      if (customer) filter.customer = customer;
      if (status) filter.status = status;
      if (paymentStatus) filter["payment.status"] = paymentStatus;
      if (invoiceType) filter.invoiceType = invoiceType;

      if (dateFrom || dateTo) {
        filter.invoiceDate = {};
        if (dateFrom) filter.invoiceDate.$gte = new Date(dateFrom);
        if (dateTo) filter.invoiceDate.$lte = new Date(dateTo);
      }

      const sales = await Sale.find(filter)
        .populate("customer", "name mobile email")
        .sort({invoiceDate: -1})
        .limit(1000);

      const csvHeaders = [
        "Invoice Number",
        "Invoice Date",
        "Customer Name",
        "Customer Mobile",
        "Invoice Type",
        "Total Amount",
        "Tax Amount",
        "Paid Amount",
        "Pending Amount",
        "Payment Status",
        "Status",
      ];

      const csvRows = sales.map((sale) => [
        sale.invoiceNumber,
        sale.invoiceDate.toISOString().split("T")[0],
        sale.customer?.name || "",
        sale.customer?.mobile || sale.customerMobile || "",
        sale.invoiceType,
        sale.totals.finalTotal,
        sale.totals.totalTax,
        sale.payment.paidAmount,
        sale.payment.pendingAmount,
        sale.payment.status,
        sale.status,
      ]);

      const csvContent = [csvHeaders, ...csvRows]
        .map((row) => row.map((field) => `"${field}"`).join(","))
        .join("\n");

      res.setHeader("Content-Type", "text/csv");
      res.setHeader(
        "Content-Disposition",
        "attachment; filename=sales-export.csv"
      );
      res.status(200).send(csvContent);
    } catch (error) {
      console.error("Error exporting CSV:", error);
      res.status(500).json({
        success: false,
        message: "Failed to export CSV",
        error: error.message,
      });
    }
  },

  getOverdueSales: async (req, res) => {
    try {
      const {companyId} = req.query;

      if (!companyId) {
        return res.status(400).json({
          success: false,
          message: "Company ID is required",
        });
      }

      const today = new Date();
      today.setHours(23, 59, 59, 999);

      const overdueSales = await Sale.find({
        companyId: companyId,
        status: {$ne: "cancelled"},
        "payment.pendingAmount": {$gt: 0},
        "payment.dueDate": {
          $exists: true,
          $ne: null,
          $lt: today,
        },
      })
        .populate("customer", "name mobile email")
        .sort({"payment.dueDate": 1});

      const salesWithOverdueInfo = overdueSales.map((sale) => {
        const saleObj = sale.toObject();
        const dueDate = new Date(sale.payment.dueDate);
        const diffTime = Math.abs(today - dueDate);
        const daysOverdue = Math.ceil(diffTime / (1000 * 60 * 60 * 24));

        return {
          ...saleObj,
          isOverdue: true,
          daysOverdue: daysOverdue,
        };
      });

      console.log(
        `Found ${salesWithOverdueInfo.length} overdue sales for company ${companyId}`
      );

      res.status(200).json({
        success: true,
        data: salesWithOverdueInfo,
        message: `Found ${salesWithOverdueInfo.length} overdue sales`,
      });
    } catch (error) {
      console.error("Error getting overdue sales:", error);
      res.status(500).json({
        success: false,
        message: "Failed to get overdue sales",
        error: error.message,
      });
    }
  },
  // NEW: Get sales due today
  getSalesDueToday: async (req, res) => {
    try {
      const {companyId} = req.query;

      if (!companyId) {
        return res.status(400).json({
          success: false,
          message: "Company ID is required",
        });
      }

      const today = new Date();
      const startOfDay = new Date(
        today.getFullYear(),
        today.getMonth(),
        today.getDate()
      );
      const endOfDay = new Date(
        today.getFullYear(),
        today.getMonth(),
        today.getDate() + 1
      );

      // Find sales due today
      const salesDueToday = await Sale.find({
        companyId: companyId,
        status: {$ne: "cancelled"},
        "payment.pendingAmount": {$gt: 0},
        "payment.dueDate": {
          $gte: startOfDay,
          $lt: endOfDay,
        },
      })
        .populate("customer", "name mobile email")
        .sort({"payment.dueDate": 1});

      console.log(
        `Found ${salesDueToday.length} sales due today for company ${companyId}`
      );

      res.status(200).json({
        success: true,
        data: salesDueToday,
        message: `Found ${salesDueToday.length} sales due today`,
      });
    } catch (error) {
      console.error("Error getting sales due today:", error);
      res.status(500).json({
        success: false,
        message: "Failed to get sales due today",
        error: error.message,
      });
    }
  },

  updatePaymentDueDate: async (req, res) => {
    try {
      const {id} = req.params;
      const {dueDate, creditDays} = req.body;

      if (!mongoose.Types.ObjectId.isValid(id)) {
        return res.status(400).json({
          success: false,
          message: "Invalid sale ID",
        });
      }

      const sale = await Sale.findById(id);
      if (!sale) {
        return res.status(404).json({
          success: false,
          message: "Sale not found",
        });
      }

      // Update due date and credit days
      sale.payment.dueDate = dueDate ? new Date(dueDate) : null;
      sale.payment.creditDays = creditDays ? parseInt(creditDays) : 0;
      sale.lastModifiedBy = req.user?.id || "system";

      await sale.save();

      console.log(`Updated due date for sale ${id}`);

      res.status(200).json({
        success: true,
        data: sale,
        message: "Payment due date updated successfully",
      });
    } catch (error) {
      console.error("Error updating payment due date:", error);
      res.status(500).json({
        success: false,
        message: "Failed to update payment due date",
        error: error.message,
      });
    }
  },

  convertSalesInvoiceToPurchaseInvoice: async (req, res) => {
    try {
      const {salesInvoiceId} = req.params;
      const {convertedBy, customerCompanyId, notes, createdBy, userId} =
        req.body; // ‚úÖ Added userId

      console.log(
        "üîÑ Converting sales invoice to purchase invoice for customer's company:",
        salesInvoiceId
      );

      // Validate sales invoice ID
      if (!mongoose.Types.ObjectId.isValid(salesInvoiceId)) {
        return res.status(400).json({
          success: false,
          message: "Invalid sales invoice ID",
        });
      }

      // Find the sales invoice
      const salesInvoice = await Sale.findById(salesInvoiceId)
        .populate(
          "customer",
          "name mobile email address gstNumber companyId linkedCompanyId"
        )
        .populate("companyId", "businessName email phoneNumber address gstin");

      if (!salesInvoice) {
        return res.status(404).json({
          success: false,
          message: "Sales invoice not found",
        });
      }

      console.log("üìä Sales invoice found:", {
        invoiceNumber: salesInvoice.invoiceNumber,
        sellerCompany: salesInvoice.companyId?.businessName,
        customerName: salesInvoice.customer?.name,
        itemsCount: salesInvoice.items.length,
      });

      // Check if already converted
      if (salesInvoice.autoGeneratedPurchaseInvoice) {
        return res.status(400).json({
          success: false,
          message:
            "Sales invoice has already been converted to purchase invoice",
          data: {
            existingPurchaseInvoiceId: salesInvoice.purchaseInvoiceRef,
            existingPurchaseInvoiceNumber: salesInvoice.purchaseInvoiceNumber,
          },
        });
      }

      // ‚úÖ CRITICAL FIX: Determine the customer's company ID
      let purchaseCompanyId = customerCompanyId;

      if (!purchaseCompanyId && salesInvoice.customer?.linkedCompanyId) {
        purchaseCompanyId = salesInvoice.customer.linkedCompanyId;
        console.log("üîß Using customer's linkedCompanyId:", purchaseCompanyId);
      }

      if (!purchaseCompanyId && salesInvoice.customer?.companyId) {
        purchaseCompanyId = salesInvoice.customer.companyId;
        console.log("üîß Using customer's companyId:", purchaseCompanyId);
      }

      if (!purchaseCompanyId) {
        return res.status(400).json({
          success: false,
          message:
            "Customer company ID is required. This invoice will be created as a purchase invoice for the customer's company.",
          hint: "Provide customerCompanyId in the request body or ensure the customer has a linked company",
        });
      }

      // ‚úÖ VALIDATION: Ensure we're not creating for the same company
      if (purchaseCompanyId.toString() === salesInvoice.companyId.toString()) {
        return res.status(400).json({
          success: false,
          message:
            "Cannot create purchase invoice for the same company. Purchase invoice should be created for the customer's company.",
          data: {
            salesCompanyId: salesInvoice.companyId,
            providedCustomerCompanyId: purchaseCompanyId,
          },
        });
      }

      console.log("üè¢ Company mapping for cross-company invoice:", {
        salesCompany: salesInvoice.companyId,
        purchaseCompany: purchaseCompanyId,
        customer: salesInvoice.customer.name,
        crossCompany: true,
      });

      // Import models
      const Purchase = require("../models/Purchase");

      // ‚úÖ CRITICAL FIX: Get valid User ID for createdBy field
      const getValidUserId = async () => {
        // Priority 1: Explicitly provided userId
        if (userId && mongoose.Types.ObjectId.isValid(userId)) {
          return userId;
        }

        // Priority 2: Provided createdBy (if it's a valid User ID)
        if (createdBy && mongoose.Types.ObjectId.isValid(createdBy)) {
          return createdBy;
        }

        // Priority 3: Provided convertedBy (if it's a valid User ID)
        if (convertedBy && mongoose.Types.ObjectId.isValid(convertedBy)) {
          return convertedBy;
        }

        // Priority 4: User ID from request
        if (req.user?.id && mongoose.Types.ObjectId.isValid(req.user.id)) {
          return req.user.id;
        }

        // Priority 5: User ID from request._id
        if (req.user?._id && mongoose.Types.ObjectId.isValid(req.user._id)) {
          return req.user._id;
        }

        // ‚úÖ Priority 6: Try to find a system user or create one
        try {
          const User = require("../models/User"); // Adjust path as needed

          // Look for existing system user
          let systemUser = await User.findOne({
            email: "system@crosscompany.internal",
            role: "system",
          });

          if (!systemUser) {
            // Create system user for cross-company operations
            systemUser = new User({
              name: "System User - Cross Company",
              email: "system@crosscompany.internal",
              password: "system123", // You should hash this properly
              role: "system",
              isActive: true,
              isSystemUser: true,
            });
            await systemUser.save();
            console.log("‚úÖ Created system user for cross-company operations");
          }

          return systemUser._id;
        } catch (userError) {
          console.error("‚ùå Error getting/creating system user:", userError);
          return null;
        }
      };

      const validUserId = await getValidUserId();

      if (!validUserId) {
        return res.status(400).json({
          success: false,
          message:
            "User authentication required for cross-company invoice conversion",
          error: "No valid user ID found for creating supplier party",
          hint: "Please provide userId in the request body or ensure proper user authentication",
        });
      }

      console.log("‚úÖ Using valid user ID for party creation:", validUserId);

      // ‚úÖ ENHANCED: Create supplier party representing the SELLING company
      let supplierParty = await Party.findOne({
        companyId: purchaseCompanyId, // Customer's company
        $or: [
          {name: salesInvoice.companyId.businessName, type: "supplier"},
          {linkedCompanyId: salesInvoice.companyId._id, type: "supplier"},
          // ‚úÖ Also search by phone number to find existing party
          {
            phoneNumber: salesInvoice.companyId.phoneNumber,
            type: "supplier",
            companyId: purchaseCompanyId,
          },
        ],
      });

      if (!supplierParty) {
        console.log(
          "üèóÔ∏è Creating supplier party representing selling company:",
          salesInvoice.companyId.businessName
        );

        // ‚úÖ ENHANCED: Generate unique phone number if duplicate exists
        const generateUniquePhoneNumber = async (
          basePhoneNumber,
          companyId
        ) => {
          let phoneNumber = basePhoneNumber || "9000000000";
          let counter = 1;

          while (true) {
            const existingParty = await Party.findOne({
              companyId: companyId,
              phoneNumber: phoneNumber,
            });

            if (!existingParty) {
              return phoneNumber;
            }

            // ‚úÖ If duplicate, append counter to make it unique
            const baseNumber = basePhoneNumber || "9000000000";
            const paddedCounter = counter.toString().padStart(2, "0");
            phoneNumber = baseNumber.slice(0, -2) + paddedCounter;
            counter++;

            // ‚úÖ Safety check to prevent infinite loop
            if (counter > 99) {
              phoneNumber = `${Date.now()}`.slice(-10); // Use timestamp as fallback
              break;
            }
          }

          return phoneNumber;
        };

        // ‚úÖ Generate unique phone number
        const uniquePhoneNumber = await generateUniquePhoneNumber(
          salesInvoice.companyId.phoneNumber,
          purchaseCompanyId
        );

        // ‚úÖ FIXED: Create supplier party with proper User ID and unique phone
        const supplierPartyData = {
          name: salesInvoice.companyId.businessName || "Supplier Company",
          mobile: uniquePhoneNumber, // ‚úÖ Use unique phone number
          phoneNumber: uniquePhoneNumber, // ‚úÖ Use unique phone number
          email:
            salesInvoice.companyId.email ||
            `supplier-${Date.now()}@company.com`, // ‚úÖ Make email unique too
          address: salesInvoice.companyId.address || "",
          gstNumber: salesInvoice.companyId.gstin || "",
          type: "supplier",
          partyType: "supplier",
          companyId: purchaseCompanyId, // ‚úÖ Customer's company ID
          status: "active",
          creditLimit: 0,
          creditDays: 30,
          currentBalance: 0,
          openingBalance: 0,

          // ‚úÖ CRITICAL FIX: Use valid User ID (not Customer ID)
          userId: validUserId, // ‚úÖ This should be a User ID
          createdBy: validUserId, // ‚úÖ This should be a User ID
          lastModifiedBy: validUserId, // ‚úÖ This should be a User ID

          // ‚úÖ ENHANCED: Cross-company linking
          linkedCompanyId: salesInvoice.companyId._id, // Link to the selling company
          isLinkedSupplier: true,
          enableBidirectionalInvoices: true,
          sourceInvoiceId: salesInvoice._id,
          sourceInvoiceNumber: salesInvoice.invoiceNumber,
          notes: `Auto-created from Sales Invoice ${salesInvoice.invoiceNumber} - Represents ${salesInvoice.companyId.businessName}`,

          // ‚úÖ NEW: Add metadata about phone number modification
          ...(uniquePhoneNumber !== salesInvoice.companyId.phoneNumber && {
            originalPhoneNumber: salesInvoice.companyId.phoneNumber,
            phoneNumberModified: true,
            phoneNumberModificationReason:
              "Avoided duplicate in target company",
          }),
        };

        try {
          supplierParty = new Party(supplierPartyData);
          await supplierParty.save();

          console.log("‚úÖ Successfully created supplier party:", {
            id: supplierParty._id,
            name: supplierParty.name,
            phoneNumber: supplierParty.phoneNumber,
            originalPhone: salesInvoice.companyId.phoneNumber,
            phoneModified:
              uniquePhoneNumber !== salesInvoice.companyId.phoneNumber,
            companyId: supplierParty.companyId,
            userId: supplierParty.userId,
            linkedCompanyId: supplierParty.linkedCompanyId,
          });
        } catch (partyError) {
          console.error("‚ùå Error creating supplier party:", partyError);

          // ‚úÖ ENHANCED: Check if it's still a duplicate error and try to find existing party
          if (partyError.code === 11000) {
            console.log(
              "üîç Duplicate error occurred, searching for existing party..."
            );

            // Try to find the existing party that's causing the duplicate
            const existingParty = await Party.findOne({
              companyId: purchaseCompanyId,
              $or: [
                {phoneNumber: salesInvoice.companyId.phoneNumber},
                {mobile: salesInvoice.companyId.phoneNumber},
                {name: salesInvoice.companyId.businessName},
              ],
            });

            if (existingParty) {
              console.log("‚úÖ Found existing party, will use it:", {
                id: existingParty._id,
                name: existingParty.name,
                phoneNumber: existingParty.phoneNumber,
              });

              // ‚úÖ Update existing party with cross-company linking if needed
              if (!existingParty.linkedCompanyId) {
                existingParty.linkedCompanyId = salesInvoice.companyId._id;
                existingParty.isLinkedSupplier = true;
                existingParty.enableBidirectionalInvoices = true;
                existingParty.notes = `${
                  existingParty.notes || ""
                } | Linked to ${
                  salesInvoice.companyId.businessName
                } via invoice ${salesInvoice.invoiceNumber}`;
                await existingParty.save();
                console.log(
                  "‚úÖ Updated existing party with cross-company linking"
                );
              }

              supplierParty = existingParty;
            } else {
              // If we still can't find the party, return error
              return res.status(500).json({
                success: false,
                message:
                  "Failed to create or find supplier party for cross-company conversion",
                error: "Duplicate phone number constraint violation",
                details: {
                  duplicateField: "phoneNumber",
                  duplicateValue: salesInvoice.companyId.phoneNumber,
                  companyId: purchaseCompanyId,
                  suggestion:
                    "A party with this phone number already exists in the target company",
                },
              });
            }
          } else {
            // For other errors, return the original error response
            return res.status(500).json({
              success: false,
              message:
                "Failed to create supplier party for cross-company conversion",
              error: partyError.message,
              details: {
                requiredField: "userId",
                providedUserId: validUserId,
                partyData: {
                  name: supplierPartyData.name,
                  companyId: supplierPartyData.companyId,
                  type: supplierPartyData.type,
                },
              },
            });
          }
        }
      } else {
        console.log(
          "‚úÖ Found existing supplier party for selling company:",
          supplierParty.name
        );
      }

      // Transform sales invoice items
      const purchaseInvoiceItems = salesInvoice.items.map((item, index) => {
        const itemAmount =
          item.itemAmount || item.amount || item.quantity * item.pricePerUnit;

        return {
          itemRef: item.itemRef || null,
          itemName: item.itemName,
          itemCode: item.itemCode || "",
          hsnCode: item.hsnCode || "0000",
          category: item.category || "",
          description: item.description || "",
          quantity: item.quantity,
          pricePerUnit: item.pricePerUnit,
          unit: item.unit || "PCS",
          discountPercent: item.discountPercent || 0,
          discountAmount: item.discountAmount || 0,
          taxRate: item.taxRate || 0,
          taxMode: item.taxMode || salesInvoice.taxMode || "without-tax",
          priceIncludesTax:
            item.priceIncludesTax !== undefined
              ? item.priceIncludesTax
              : salesInvoice.priceIncludesTax || false,

          // Tax fields
          cgst: item.cgst || item.cgstAmount || 0,
          sgst: item.sgst || item.sgstAmount || 0,
          igst: item.igst || item.igstAmount || 0,
          cgstAmount: item.cgstAmount || item.cgst || 0,
          sgstAmount: item.sgstAmount || item.sgst || 0,
          igstAmount: item.igstAmount || item.igst || 0,

          taxableAmount: item.taxableAmount || itemAmount,
          totalTaxAmount:
            item.totalTaxAmount ||
            (item.cgst || 0) + (item.sgst || 0) + (item.igst || 0),

          amount: itemAmount,
          itemAmount: itemAmount,
          lineNumber: item.lineNumber || index + 1,
          receivedQuantity: item.quantity,
          pendingQuantity: 0,
        };
      });

      // Generate purchase number for customer's company
      const generatePurchaseNumber = () => {
        const date = new Date();
        const year = date.getFullYear();
        const month = String(date.getMonth() + 1).padStart(2, "0");
        const day = String(date.getDate()).padStart(2, "0");
        const timestamp = Date.now().toString().slice(-4);

        const prefix = salesInvoice.gstEnabled ? "PINV-GST" : "PINV";
        return `${prefix}-${year}${month}${day}-${timestamp}`;
      };

      const purchaseNumber = generatePurchaseNumber();
      console.log(
        "üìù Generated purchase number for customer's company:",
        purchaseNumber
      );

      // ‚úÖ ENHANCED: Create purchase invoice data for CUSTOMER'S company
      const purchaseInvoiceData = {
        purchaseNumber: purchaseNumber,
        invoiceNumber: purchaseNumber,
        purchaseType: salesInvoice.invoiceType || "gst",
        invoiceType: salesInvoice.invoiceType || "gst",
        purchaseDate: salesInvoice.invoiceDate || new Date(),
        invoiceDate: salesInvoice.invoiceDate || new Date(),
        supplier: supplierParty._id, // Supplier = your company
        supplierMobile: supplierParty.mobile || "",
        companyId: purchaseCompanyId, // ‚úÖ CRITICAL: Customer's company ID
        items: purchaseInvoiceItems,
        totals: {
          subtotal: salesInvoice.totals.subtotal || 0,
          totalQuantity: salesInvoice.totals.totalQuantity || 0,
          totalDiscount: salesInvoice.totals.totalDiscount || 0,
          totalDiscountAmount: salesInvoice.totals.totalDiscountAmount || 0,
          totalTax: salesInvoice.totals.totalTax || 0,
          totalCGST: salesInvoice.totals.totalCGST || 0,
          totalSGST: salesInvoice.totals.totalSGST || 0,
          totalIGST: salesInvoice.totals.totalIGST || 0,
          totalTaxableAmount:
            salesInvoice.totals.totalTaxableAmount ||
            salesInvoice.totals.subtotal ||
            0,
          finalTotal: salesInvoice.totals.finalTotal || 0,
          roundOff: salesInvoice.totals.roundOff || 0,
          withTaxTotal: salesInvoice.totals.withTaxTotal || 0,
          withoutTaxTotal: salesInvoice.totals.withoutTaxTotal || 0,
        },
        payment: {
          method: salesInvoice.payment?.method || "credit",
          status: "paid", // Assume paid since it's based on a completed sale
          paidAmount: salesInvoice.totals.finalTotal || 0,
          pendingAmount: 0,
          paymentDate: new Date(),
          dueDate: null,
          creditDays: 0,
          reference: `Payment for Sales Invoice ${salesInvoice.invoiceNumber}`,
          notes: "Auto-payment for cross-company purchase invoice",
        },
        gstEnabled:
          salesInvoice.gstEnabled !== undefined
            ? salesInvoice.gstEnabled
            : true,
        taxMode: salesInvoice.taxMode || "without-tax",
        priceIncludesTax: salesInvoice.priceIncludesTax || false,

        // ‚úÖ ENHANCED: Bidirectional cross-company tracking
        sourceInvoiceId: salesInvoice._id,
        sourceInvoiceNumber: salesInvoice.invoiceNumber,
        sourceInvoiceType: "sales_invoice",
        sourceCompanyId: salesInvoice.companyId._id, // ‚úÖ Original selling company
        targetCompanyId: purchaseCompanyId, // ‚úÖ Customer's company
        isAutoGenerated: true,
        isCrossCompanyInvoice: true, // ‚úÖ Flag for cross-company
        generatedFrom: "sales_invoice",
        generatedBy: validUserId,
        generatedAt: new Date(),

        // ‚úÖ ENHANCED: Cross-company correspondence
        correspondingSalesInvoiceId: salesInvoice._id,
        correspondingSalesInvoiceNumber: salesInvoice.invoiceNumber,
        correspondingSalesInvoiceCompany: salesInvoice.companyId._id,

        notes:
          notes ||
          `Cross-company purchase invoice generated from Sales Invoice ${salesInvoice.invoiceNumber} of ${salesInvoice.companyId.businessName}`,
        termsAndConditions: salesInvoice.termsAndConditions || "",
        status: "received",
        receivingStatus: "complete",
        createdBy: validUserId,
        lastModifiedBy: validUserId,
      };

      console.log(
        "üìã Creating cross-company purchase invoice for customer's company..."
      );

      // Create the purchase invoice
      const purchaseInvoice = new Purchase(purchaseInvoiceData);
      await purchaseInvoice.save();

      console.log(
        "‚úÖ Cross-company purchase invoice created:",
        purchaseInvoice.purchaseNumber,
        "for company:",
        purchaseCompanyId
      );

      // ‚úÖ ENHANCED: Update the sales invoice with cross-company references
      salesInvoice.autoGeneratedPurchaseInvoice = true;
      salesInvoice.purchaseInvoiceRef = purchaseInvoice._id;
      salesInvoice.purchaseInvoiceNumber = purchaseInvoice.purchaseNumber;
      salesInvoice.purchaseInvoiceGeneratedAt = new Date();
      salesInvoice.purchaseInvoiceGeneratedBy = validUserId;

      // ‚úÖ ENHANCED: Cross-company tracking
      salesInvoice.targetCompanyId = purchaseCompanyId;
      salesInvoice.correspondingPurchaseInvoiceId = purchaseInvoice._id;
      salesInvoice.correspondingPurchaseInvoiceNumber =
        purchaseInvoice.purchaseNumber;
      salesInvoice.correspondingPurchaseInvoiceCompany = purchaseCompanyId;
      salesInvoice.isCrossCompanyLinked = true;

      await salesInvoice.save();

      console.log(
        "‚úÖ Sales invoice updated with cross-company purchase reference"
      );

      res.status(201).json({
        success: true,
        message:
          "Sales invoice converted to cross-company purchase invoice successfully",
        data: {
          purchaseInvoice: {
            _id: purchaseInvoice._id,
            purchaseNumber: purchaseInvoice.purchaseNumber,
            invoiceNumber: purchaseInvoice.invoiceNumber,
            invoiceDate: purchaseInvoice.invoiceDate,
            supplier: {
              _id: supplierParty._id,
              name: supplierParty.name,
              mobile: supplierParty.mobile,
              linkedCompanyId: supplierParty.linkedCompanyId,
            },
            companyId: purchaseCompanyId, // ‚úÖ Customer's company
            totals: purchaseInvoice.totals,
            status: purchaseInvoice.status,
            isCrossCompanyInvoice: true,
            sourceInvoiceId: purchaseInvoice.sourceInvoiceId,
            sourceInvoiceNumber: purchaseInvoice.sourceInvoiceNumber,
            sourceCompanyId: salesInvoice.companyId._id, // ‚úÖ Your company
          },
          salesInvoice: {
            id: salesInvoice._id,
            invoiceNumber: salesInvoice.invoiceNumber,
            autoGeneratedPurchaseInvoice:
              salesInvoice.autoGeneratedPurchaseInvoice,
            purchaseInvoiceRef: salesInvoice.purchaseInvoiceRef,
            purchaseInvoiceNumber: salesInvoice.purchaseInvoiceNumber,
            targetCompanyId: salesInvoice.targetCompanyId,
            isCrossCompanyLinked: true,
          },
          crossCompanyMapping: {
            sellingCompany: salesInvoice.companyId._id,
            buyingCompany: purchaseCompanyId,
            customerName: salesInvoice.customer.name,
            invoiceAmount: salesInvoice.totals.finalTotal,
            conversionDate: new Date(),
          },
        },
      });
    } catch (error) {
      console.error(
        "‚ùå Error converting sales invoice to cross-company purchase invoice:",
        error
      );
      res.status(500).json({
        success: false,
        message:
          "Failed to convert sales invoice to cross-company purchase invoice",
        error: error.message,
      });
    }
  },

  // ‚úÖ NEW: Get purchase invoices created from sales invoices
  getPurchaseInvoicesFromSalesInvoices: async (req, res) => {
    try {
      const {companyId, page = 1, limit = 10} = req.query;

      if (!companyId) {
        return res.status(400).json({
          success: false,
          message: "Company ID is required",
        });
      }

      const skip = (parseInt(page) - 1) * parseInt(limit);

      // Import Purchase model
      const Purchase = require("../models/Purchase");

      // Find purchase invoices that were generated from sales invoices
      const purchaseInvoices = await Purchase.find({
        companyId,
        sourceInvoiceType: "sales_invoice",
        isAutoGenerated: true,
      })
        .populate("supplier", "name mobile email")
        .sort({createdAt: -1})
        .skip(skip)
        .limit(parseInt(limit));

      const total = await Purchase.countDocuments({
        companyId,
        sourceInvoiceType: "sales_invoice",
        isAutoGenerated: true,
      });

      res.status(200).json({
        success: true,
        data: {
          purchaseInvoices,
          pagination: {
            currentPage: parseInt(page),
            totalPages: Math.ceil(total / parseInt(limit)),
            totalItems: total,
            hasNext: parseInt(page) < Math.ceil(total / parseInt(limit)),
            hasPrev: parseInt(page) > 1,
          },
        },
        message: "Purchase invoices from sales invoices retrieved successfully",
      });
    } catch (error) {
      console.error(
        "Error getting purchase invoices from sales invoices:",
        error
      );
      res.status(500).json({
        success: false,
        message: "Failed to get purchase invoices from sales invoices",
        error: error.message,
      });
    }
  },

  // ‚úÖ NEW: Get bidirectional invoice analytics
  getBidirectionalInvoiceAnalytics: async (req, res) => {
    try {
      const {companyId} = req.query;

      if (!companyId) {
        return res.status(400).json({
          success: false,
          message: "Company ID is required",
        });
      }

      const Purchase = require("../models/Purchase");

      const [
        totalSalesInvoices,
        purchaseInvoicesFromSalesInvoices,
        totalPurchaseInvoices,
        autoGeneratedSalesInvoices,
        salesInvoicesWithGeneratedPurchase,
      ] = await Promise.all([
        // Total sales invoices count
        Sale.countDocuments({companyId}),

        // Purchase invoices created from sales invoices
        Purchase.countDocuments({
          companyId,
          sourceInvoiceType: "sales_invoice",
          isAutoGenerated: true,
        }),

        // Total purchase invoices
        Purchase.countDocuments({companyId}),

        // Auto-generated sales invoices (from purchase invoices)
        Sale.countDocuments({
          companyId,
          isAutoGenerated: true,
          generatedFrom: "purchase_invoice",
        }),

        // Sales invoices that generated purchase invoices
        Sale.countDocuments({
          companyId,
          autoGeneratedPurchaseInvoice: true,
        }),
      ]);

      const analytics = {
        salesInvoices: {
          total: totalSalesInvoices,
          autoGenerated: autoGeneratedSalesInvoices,
          withGeneratedPurchase: salesInvoicesWithGeneratedPurchase,
          direct: totalSalesInvoices - autoGeneratedSalesInvoices,
        },
        purchaseInvoices: {
          total: totalPurchaseInvoices,
          fromSalesInvoices: purchaseInvoicesFromSalesInvoices,
          direct: totalPurchaseInvoices - purchaseInvoicesFromSalesInvoices,
        },
        bidirectionalCoverage: {
          percentage:
            totalSalesInvoices > 0
              ? (
                  ((autoGeneratedSalesInvoices +
                    salesInvoicesWithGeneratedPurchase) /
                    totalSalesInvoices) *
                  100
                ).toFixed(2)
              : 0,
          description:
            "Percentage of invoices using bidirectional invoice system",
        },
        conversionRates: {
          salesToPurchase:
            totalSalesInvoices > 0
              ? (
                  (salesInvoicesWithGeneratedPurchase / totalSalesInvoices) *
                  100
                ).toFixed(2)
              : 0,
          purchaseFromSales:
            totalPurchaseInvoices > 0
              ? (
                  (purchaseInvoicesFromSalesInvoices / totalPurchaseInvoices) *
                  100
                ).toFixed(2)
              : 0,
        },
      };

      res.status(200).json({
        success: true,
        data: analytics,
        message: "Bidirectional invoice analytics retrieved successfully",
      });
    } catch (error) {
      console.error("Error getting bidirectional invoice analytics:", error);
      res.status(500).json({
        success: false,
        message: "Failed to get bidirectional invoice analytics",
        error: error.message,
      });
    }
  },

  // ‚úÖ NEW: Get invoice conversion status
  getSalesInvoiceConversionStatus: async (req, res) => {
    try {
      const {companyId, salesInvoiceId} = req.query;

      if (!companyId || !salesInvoiceId) {
        return res.status(400).json({
          success: false,
          message: "Company ID and Sales Invoice ID are required",
        });
      }

      const salesInvoice = await Sale.findOne({
        _id: salesInvoiceId,
        companyId,
      }).populate("customer", "name mobile email");

      if (!salesInvoice) {
        return res.status(404).json({
          success: false,
          message: "Sales invoice not found",
        });
      }

      let purchaseInvoice = null;
      if (
        salesInvoice.autoGeneratedPurchaseInvoice &&
        salesInvoice.purchaseInvoiceRef
      ) {
        const Purchase = require("../models/Purchase");
        purchaseInvoice = await Purchase.findById(
          salesInvoice.purchaseInvoiceRef
        ).select("invoiceNumber invoiceDate totals payment status");
      }

      const conversionStatus = {
        salesInvoice: {
          id: salesInvoice._id,
          invoiceNumber: salesInvoice.invoiceNumber,
          invoiceDate: salesInvoice.invoiceDate,
          customer: salesInvoice.customer,
          totalAmount: salesInvoice.totals.finalTotal,
          status: salesInvoice.status,
        },
        conversion: {
          isConverted: salesInvoice.autoGeneratedPurchaseInvoice,
          convertedAt: salesInvoice.purchaseInvoiceGeneratedAt,
          convertedBy: salesInvoice.purchaseInvoiceGeneratedBy,
          canConvert:
            !salesInvoice.autoGeneratedPurchaseInvoice &&
            ["draft", "completed"].includes(salesInvoice.status),
        },
        purchaseInvoice: purchaseInvoice
          ? {
              id: purchaseInvoice._id,
              invoiceNumber: purchaseInvoice.invoiceNumber,
              invoiceDate: purchaseInvoice.invoiceDate,
              totalAmount: purchaseInvoice.totals.finalTotal,
              paymentStatus: purchaseInvoice.payment.status,
              status: purchaseInvoice.status,
            }
          : null,
      };

      res.status(200).json({
        success: true,
        data: conversionStatus,
        message: "Sales invoice conversion status retrieved successfully",
      });
    } catch (error) {
      console.error("Error getting sales invoice conversion status:", error);
      res.status(500).json({
        success: false,
        message: "Failed to get sales invoice conversion status",
        error: error.message,
      });
    }
  },

  // ‚úÖ NEW: Bulk convert sales invoices to purchase invoices
  bulkConvertSalesInvoicesToPurchaseInvoices: async (req, res) => {
    try {
      const {salesInvoiceIds, convertedBy, targetCompanyId} = req.body;

      if (
        !salesInvoiceIds ||
        !Array.isArray(salesInvoiceIds) ||
        salesInvoiceIds.length === 0
      ) {
        return res.status(400).json({
          success: false,
          message: "Sales invoice IDs array is required",
        });
      }

      const Purchase = require("../models/Purchase");
      const results = {
        successful: [],
        failed: [],
        skipped: [],
      };

      for (const salesInvoiceId of salesInvoiceIds) {
        try {
          if (!mongoose.Types.ObjectId.isValid(salesInvoiceId)) {
            results.failed.push({
              salesInvoiceId,
              error: "Invalid sales invoice ID",
            });
            continue;
          }

          const salesInvoice = await Sale.findById(salesInvoiceId);

          if (!salesInvoice) {
            results.failed.push({
              salesInvoiceId,
              error: "Sales invoice not found",
            });
            continue;
          }

          if (salesInvoice.autoGeneratedPurchaseInvoice) {
            results.skipped.push({
              salesInvoiceId,
              invoiceNumber: salesInvoice.invoiceNumber,
              reason: "Already converted",
              existingPurchaseInvoiceNumber: salesInvoice.purchaseInvoiceNumber,
            });
            continue;
          }

          // Create purchase invoice using the method we created above
          const response = await this.convertSalesInvoiceToPurchaseInvoice(
            {params: {salesInvoiceId}, body: {convertedBy, targetCompanyId}},
            {
              status: (code) => ({
                json: (data) => {
                  if (code === 201) {
                    results.successful.push({
                      salesInvoiceId,
                      invoiceNumber: salesInvoice.invoiceNumber,
                      purchaseInvoiceId: data.data.purchaseInvoice._id,
                      purchaseInvoiceNumber:
                        data.data.purchaseInvoice.invoiceNumber,
                      finalTotal: data.data.purchaseInvoice.totals.finalTotal,
                    });
                  } else {
                    results.failed.push({
                      salesInvoiceId,
                      error: data.message || "Conversion failed",
                    });
                  }
                  return data;
                },
              }),
            }
          );
        } catch (conversionError) {
          results.failed.push({
            salesInvoiceId,
            error: conversionError.message,
          });
        }
      }

      const summary = {
        total: salesInvoiceIds.length,
        successful: results.successful.length,
        failed: results.failed.length,
        skipped: results.skipped.length,
      };

      console.log("üìä Bulk invoice conversion summary:", summary);

      res.status(200).json({
        success: true,
        message: `Bulk conversion completed: ${summary.successful} successful, ${summary.failed} failed, ${summary.skipped} skipped`,
        data: {
          summary,
          results,
        },
      });
    } catch (error) {
      console.error("‚ùå Error in bulk invoice conversion:", error);
      res.status(500).json({
        success: false,
        message: "Failed to perform bulk invoice conversion",
        error: error.message,
      });
    }
  },

  // ‚úÖ NEW: Get invoice source tracking (enhanced)
  getSalesInvoiceSourceTracking: async (req, res) => {
    try {
      const {invoiceId} = req.params;

      if (!mongoose.Types.ObjectId.isValid(invoiceId)) {
        return res.status(400).json({
          success: false,
          message: "Invalid invoice ID",
        });
      }

      const salesInvoice = await Sale.findById(invoiceId).populate(
        "customer",
        "name mobile email"
      );

      if (!salesInvoice) {
        return res.status(404).json({
          success: false,
          message: "Sales invoice not found",
        });
      }

      // Get the complete tracking chain
      const trackingChain = await salesInvoice.getInvoiceTrackingChain();

      let sourceInfo = {
        salesInvoice: {
          id: salesInvoice._id,
          invoiceNumber: salesInvoice.invoiceNumber,
          invoiceDate: salesInvoice.invoiceDate,
          customer: salesInvoice.customer,
          totalAmount: salesInvoice.totals.finalTotal,
        },
        source: {
          type: "direct_sale",
          description: "Created directly as a sales invoice",
        },
        trackingChain,
        bidirectionalInfo: salesInvoice.invoiceTrackingInfo,
      };

      // Check if this invoice was created from a purchase invoice
      if (
        salesInvoice.sourceInvoiceId &&
        salesInvoice.sourceInvoiceType === "purchase_invoice"
      ) {
        const Purchase = require("../models/Purchase");
        const sourcePurchaseInvoice = await Purchase.findById(
          salesInvoice.sourceInvoiceId
        ).populate("supplier", "name mobile email");

        if (sourcePurchaseInvoice) {
          sourceInfo.source = {
            type: "purchase_invoice",
            description: "Auto-generated from purchase invoice",
            purchaseInvoice: {
              id: sourcePurchaseInvoice._id,
              invoiceNumber: sourcePurchaseInvoice.invoiceNumber,
              invoiceDate: sourcePurchaseInvoice.invoiceDate,
              supplier: sourcePurchaseInvoice.supplier,
              isAutoGenerated: sourcePurchaseInvoice.isAutoGenerated,
              sourceCompanyId: sourcePurchaseInvoice.sourceCompanyId,
            },
          };
        }
      }

      res.status(200).json({
        success: true,
        data: sourceInfo,
        message: "Sales invoice source tracking retrieved successfully",
      });
    } catch (error) {
      console.error("Error getting sales invoice source tracking:", error);
      res.status(500).json({
        success: false,
        message: "Failed to get sales invoice source tracking",
        error: error.message,
      });
    }
  },

  getPaymentSummaryWithOverdue: async (req, res) => {
    try {
      const {companyId, dateFrom, dateTo} = req.query;

      if (!companyId) {
        return res.status(400).json({
          success: false,
          message: "Company ID is required",
        });
      }

      // Build date filter
      const dateFilter = {companyId, status: {$ne: "cancelled"}};
      if (dateFrom || dateTo) {
        dateFilter.invoiceDate = {};
        if (dateFrom) dateFilter.invoiceDate.$gte = new Date(dateFrom);
        if (dateTo) dateFilter.invoiceDate.$lte = new Date(dateTo);
      }

      const today = new Date();
      today.setHours(23, 59, 59, 999);

      // Get comprehensive payment analysis
      const [salesData, overdueSummary, dueTodaySummary] = await Promise.all([
        // Regular sales summary
        Sale.aggregate([
          {$match: dateFilter},
          {
            $group: {
              _id: null,
              totalSales: {$sum: 1},
              totalAmount: {$sum: "$totals.finalTotal"},
              totalPaid: {$sum: "$payment.paidAmount"},
              totalPending: {$sum: "$payment.pendingAmount"},
              paidCount: {
                $sum: {$cond: [{$eq: ["$payment.status", "paid"]}, 1, 0]},
              },
              partialCount: {
                $sum: {$cond: [{$eq: ["$payment.status", "partial"]}, 1, 0]},
              },
              pendingCount: {
                $sum: {$cond: [{$eq: ["$payment.status", "pending"]}, 1, 0]},
              },
            },
          },
        ]),

        // Overdue summary
        Sale.aggregate([
          {
            $match: {
              ...dateFilter,
              "payment.pendingAmount": {$gt: 0},
              "payment.dueDate": {$lt: today},
            },
          },
          {
            $group: {
              _id: null,
              overdueCount: {$sum: 1},
              overdueAmount: {$sum: "$payment.pendingAmount"},
            },
          },
        ]),

        // Due today summary
        Sale.aggregate([
          {
            $match: {
              ...dateFilter,
              "payment.pendingAmount": {$gt: 0},
              "payment.dueDate": {
                $gte: new Date(
                  today.getFullYear(),
                  today.getMonth(),
                  today.getDate()
                ),
                $lt: new Date(
                  today.getFullYear(),
                  today.getMonth(),
                  today.getDate() + 1
                ),
              },
            },
          },
          {
            $group: {
              _id: null,
              dueTodayCount: {$sum: 1},
              dueTodayAmount: {$sum: "$payment.pendingAmount"},
            },
          },
        ]),
      ]);

      const summary = {
        ...(salesData[0] || {
          totalSales: 0,
          totalAmount: 0,
          totalPaid: 0,
          totalPending: 0,
          paidCount: 0,
          partialCount: 0,
          pendingCount: 0,
        }),
        overdueCount: overdueSummary[0]?.overdueCount || 0,
        overdueAmount: overdueSummary[0]?.overdueAmount || 0,
        dueTodayCount: dueTodaySummary[0]?.dueTodayCount || 0,
        dueTodayAmount: dueTodaySummary[0]?.dueTodayAmount || 0,
      };

      res.status(200).json({
        success: true,
        data: {summary},
        message: "Payment summary with overdue analysis retrieved successfully",
      });
    } catch (error) {
      console.error("Error getting payment summary with overdue:", error);
      res.status(500).json({
        success: false,
        message: "Failed to get payment summary",
        error: error.message,
      });
    }
  },

  // ‚úÖ NEW: Convert Sales Order to Invoice (enhanced with bidirectional tracking)
  convertSalesOrderToInvoice: async (req, res) => {
    try {
      const {salesOrderId} = req.params;
      const {convertedBy} = req.body;

      if (!mongoose.Types.ObjectId.isValid(salesOrderId)) {
        return res.status(400).json({
          success: false,
          message: "Invalid sales order ID",
        });
      }

      // Import SalesOrder model
      const SalesOrder = require("../models/SalesOrder");

      const salesOrder = await SalesOrder.findById(salesOrderId).populate(
        "customer",
        "name mobile email address"
      );

      if (!salesOrder) {
        return res.status(404).json({
          success: false,
          message: "Sales order not found",
        });
      }

      if (salesOrder.convertedToInvoice) {
        return res.status(400).json({
          success: false,
          message: "Sales order already converted to invoice",
          data: {
            invoiceNumber: salesOrder.invoiceNumber,
            invoiceId: salesOrder.invoiceRef,
          },
        });
      }

      // Set converter info
      salesOrder.convertedBy = convertedBy || req.user?.id || "system";

      // Convert to invoice using the model method
      const invoice = await salesOrder.convertToInvoice();

      console.log("‚úÖ Sales order converted to invoice successfully:", {
        salesOrderNumber: salesOrder.orderNumber,
        invoiceNumber: invoice.invoiceNumber,
        finalTotal: invoice.totals.finalTotal,
      });

      res.status(201).json({
        success: true,
        message: "Sales order converted to invoice successfully",
        data: {
          invoice,
          salesOrder: {
            id: salesOrder._id,
            orderNumber: salesOrder.orderNumber,
            convertedToInvoice: true,
            invoiceRef: invoice._id,
            invoiceNumber: invoice.invoiceNumber,
          },
        },
      });
    } catch (error) {
      console.error("‚ùå Error converting sales order to invoice:", error);
      res.status(500).json({
        success: false,
        message: "Failed to convert sales order to invoice",
        error: error.message,
      });
    }
  },

  // ‚úÖ NEW: Get invoices created from sales orders
  getInvoicesFromSalesOrders: async (req, res) => {
    try {
      const {companyId, page = 1, limit = 10} = req.query;

      if (!companyId) {
        return res.status(400).json({
          success: false,
          message: "Company ID is required",
        });
      }

      const skip = (parseInt(page) - 1) * parseInt(limit);

      // Find invoices that have notes indicating they were converted from sales orders
      const invoices = await Sale.find({
        companyId,
        notes: {$regex: /converted from.*sales.*order/i},
      })
        .populate("customer", "name mobile email")
        .sort({createdAt: -1})
        .skip(skip)
        .limit(parseInt(limit));

      const total = await Sale.countDocuments({
        companyId,
        notes: {$regex: /converted from.*sales.*order/i},
      });

      res.status(200).json({
        success: true,
        data: {
          invoices,
          pagination: {
            currentPage: parseInt(page),
            totalPages: Math.ceil(total / parseInt(limit)),
            totalItems: total,
            hasNext: parseInt(page) < Math.ceil(total / parseInt(limit)),
            hasPrev: parseInt(page) > 1,
          },
        },
        message: "Invoices from sales orders retrieved successfully",
      });
    } catch (error) {
      console.error("Error getting invoices from sales orders:", error);
      res.status(500).json({
        success: false,
        message: "Failed to get invoices from sales orders",
        error: error.message,
      });
    }
  },

  // ‚úÖ NEW: Get bidirectional sales analytics
  getBidirectionalSalesAnalytics: async (req, res) => {
    try {
      const {companyId} = req.query;

      if (!companyId) {
        return res.status(400).json({
          success: false,
          message: "Company ID is required",
        });
      }

      const SalesOrder = require("../models/SalesOrder");

      const [
        totalInvoices,
        invoicesFromSalesOrders,
        totalSalesOrders,
        convertedSalesOrders,
        autoGeneratedSalesOrders,
      ] = await Promise.all([
        // Total invoices count
        Sale.countDocuments({companyId}),

        // Invoices created from sales orders
        Sale.countDocuments({
          companyId,
          notes: {$regex: /converted from.*sales.*order/i},
        }),

        // Total sales orders
        SalesOrder.countDocuments({companyId}),

        // Sales orders converted to invoices
        SalesOrder.countDocuments({
          companyId,
          convertedToInvoice: true,
        }),

        // Auto-generated sales orders (from purchase orders)
        SalesOrder.countDocuments({
          companyId,
          isAutoGenerated: true,
        }),
      ]);

      const analytics = {
        invoices: {
          total: totalInvoices,
          fromSalesOrders: invoicesFromSalesOrders,
          directSales: totalInvoices - invoicesFromSalesOrders,
          conversionRate:
            totalSalesOrders > 0
              ? ((invoicesFromSalesOrders / totalSalesOrders) * 100).toFixed(2)
              : 0,
        },
        salesOrders: {
          total: totalSalesOrders,
          converted: convertedSalesOrders,
          autoGenerated: autoGeneratedSalesOrders,
          pending: totalSalesOrders - convertedSalesOrders,
          conversionRate:
            totalSalesOrders > 0
              ? ((convertedSalesOrders / totalSalesOrders) * 100).toFixed(2)
              : 0,
        },
        bidirectionalCoverage: {
          percentage:
            totalInvoices > 0
              ? (
                  ((invoicesFromSalesOrders + autoGeneratedSalesOrders) /
                    totalInvoices) *
                  100
                ).toFixed(2)
              : 0,
          description:
            "Percentage of transactions using bidirectional order system",
        },
      };

      res.status(200).json({
        success: true,
        data: analytics,
        message: "Bidirectional sales analytics retrieved successfully",
      });
    } catch (error) {
      console.error("Error getting bidirectional sales analytics:", error);
      res.status(500).json({
        success: false,
        message: "Failed to get bidirectional sales analytics",
        error: error.message,
      });
    }
  },

  // ‚úÖ NEW: Get sales order conversion status
  getSalesOrderConversionStatus: async (req, res) => {
    try {
      const {companyId, salesOrderId} = req.query;

      if (!companyId || !salesOrderId) {
        return res.status(400).json({
          success: false,
          message: "Company ID and Sales Order ID are required",
        });
      }

      const SalesOrder = require("../models/SalesOrder");

      const salesOrder = await SalesOrder.findOne({
        _id: salesOrderId,
        companyId,
      }).populate("customer", "name mobile email");

      if (!salesOrder) {
        return res.status(404).json({
          success: false,
          message: "Sales order not found",
        });
      }

      let invoice = null;
      if (salesOrder.convertedToInvoice && salesOrder.invoiceRef) {
        invoice = await Sale.findById(salesOrder.invoiceRef).select(
          "invoiceNumber invoiceDate totals payment status"
        );
      }

      const conversionStatus = {
        salesOrder: {
          id: salesOrder._id,
          orderNumber: salesOrder.orderNumber,
          orderDate: salesOrder.orderDate,
          customer: salesOrder.customer,
          totalAmount: salesOrder.totals.finalTotal,
          status: salesOrder.status,
        },
        conversion: {
          isConverted: salesOrder.convertedToInvoice,
          convertedAt: salesOrder.convertedAt,
          convertedBy: salesOrder.convertedBy,
          canConvert:
            !salesOrder.convertedToInvoice &&
            ["accepted", "confirmed"].includes(salesOrder.status),
        },
        invoice: invoice
          ? {
              id: invoice._id,
              invoiceNumber: invoice.invoiceNumber,
              invoiceDate: invoice.invoiceDate,
              totalAmount: invoice.totals.finalTotal,
              paymentStatus: invoice.payment.status,
              status: invoice.status,
            }
          : null,
      };

      res.status(200).json({
        success: true,
        data: conversionStatus,
        message: "Sales order conversion status retrieved successfully",
      });
    } catch (error) {
      console.error("Error getting sales order conversion status:", error);
      res.status(500).json({
        success: false,
        message: "Failed to get sales order conversion status",
        error: error.message,
      });
    }
  },

  // ‚úÖ NEW: Bulk convert sales orders to invoices
  bulkConvertSalesOrdersToInvoices: async (req, res) => {
    try {
      const {salesOrderIds, convertedBy} = req.body;

      if (
        !salesOrderIds ||
        !Array.isArray(salesOrderIds) ||
        salesOrderIds.length === 0
      ) {
        return res.status(400).json({
          success: false,
          message: "Sales order IDs array is required",
        });
      }

      const SalesOrder = require("../models/SalesOrder");
      const results = {
        successful: [],
        failed: [],
        skipped: [],
      };

      for (const salesOrderId of salesOrderIds) {
        try {
          if (!mongoose.Types.ObjectId.isValid(salesOrderId)) {
            results.failed.push({
              salesOrderId,
              error: "Invalid sales order ID",
            });
            continue;
          }

          const salesOrder = await SalesOrder.findById(salesOrderId);

          if (!salesOrder) {
            results.failed.push({
              salesOrderId,
              error: "Sales order not found",
            });
            continue;
          }

          if (salesOrder.convertedToInvoice) {
            results.skipped.push({
              salesOrderId,
              orderNumber: salesOrder.orderNumber,
              reason: "Already converted",
              existingInvoiceNumber: salesOrder.invoiceNumber,
            });
            continue;
          }

          // Set converter info
          salesOrder.convertedBy = convertedBy || "system";

          // Convert to invoice
          const invoice = await salesOrder.convertToInvoice();

          results.successful.push({
            salesOrderId,
            orderNumber: salesOrder.orderNumber,
            invoiceId: invoice._id,
            invoiceNumber: invoice.invoiceNumber,
            finalTotal: invoice.totals.finalTotal,
          });
        } catch (conversionError) {
          results.failed.push({
            salesOrderId,
            error: conversionError.message,
          });
        }
      }

      const summary = {
        total: salesOrderIds.length,
        successful: results.successful.length,
        failed: results.failed.length,
        skipped: results.skipped.length,
      };

      console.log("üìä Bulk conversion summary:", summary);

      res.status(200).json({
        success: true,
        message: `Bulk conversion completed: ${summary.successful} successful, ${summary.failed} failed, ${summary.skipped} skipped`,
        data: {
          summary,
          results,
        },
      });
    } catch (error) {
      console.error("‚ùå Error in bulk conversion:", error);
      res.status(500).json({
        success: false,
        message: "Failed to perform bulk conversion",
        error: error.message,
      });
    }
  },

  // ‚úÖ NEW: Get invoice source tracking
  getInvoiceSourceTracking: async (req, res) => {
    try {
      const {invoiceId} = req.params;

      if (!mongoose.Types.ObjectId.isValid(invoiceId)) {
        return res.status(400).json({
          success: false,
          message: "Invalid invoice ID",
        });
      }

      const invoice = await Sale.findById(invoiceId).populate(
        "customer",
        "name mobile email"
      );

      if (!invoice) {
        return res.status(404).json({
          success: false,
          message: "Invoice not found",
        });
      }

      let sourceInfo = {
        invoice: {
          id: invoice._id,
          invoiceNumber: invoice.invoiceNumber,
          invoiceDate: invoice.invoiceDate,
          customer: invoice.customer,
          totalAmount: invoice.totals.finalTotal,
        },
        source: {
          type: "direct_sale",
          description: "Created directly as an invoice",
        },
      };

      // Check if this invoice was created from a sales order
      if (invoice.notes && invoice.notes.includes("Converted from")) {
        const SalesOrder = require("../models/SalesOrder");

        // Try to find the source sales order
        const salesOrder = await SalesOrder.findOne({
          invoiceRef: invoice._id,
          convertedToInvoice: true,
        });

        if (salesOrder) {
          sourceInfo.source = {
            type: "sales_order",
            description: "Converted from sales order",
            salesOrder: {
              id: salesOrder._id,
              orderNumber: salesOrder.orderNumber,
              orderDate: salesOrder.orderDate,
              convertedAt: salesOrder.convertedAt,
              convertedBy: salesOrder.convertedBy,
              isAutoGenerated: salesOrder.isAutoGenerated,
            },
          };

          // Check if the sales order was auto-generated from a purchase order
          if (salesOrder.isAutoGenerated && salesOrder.sourceOrderId) {
            const PurchaseOrder = require("../models/PurchaseOrder");
            const sourcePurchaseOrder = await PurchaseOrder.findById(
              salesOrder.sourceOrderId
            ).populate("supplier", "name mobile");

            if (sourcePurchaseOrder) {
              sourceInfo.source.originalPurchaseOrder = {
                id: sourcePurchaseOrder._id,
                orderNumber: sourcePurchaseOrder.orderNumber,
                orderDate: sourcePurchaseOrder.orderDate,
                supplier: sourcePurchaseOrder.supplier,
                sourceCompany: sourcePurchaseOrder.sourceCompanyId,
              };
              sourceInfo.source.description =
                "Auto-generated from purchase order ‚Üí sales order ‚Üí invoice";
            }
          }
        }
      }

      res.status(200).json({
        success: true,
        data: sourceInfo,
        message: "Invoice source tracking retrieved successfully",
      });
    } catch (error) {
      console.error("Error getting invoice source tracking:", error);
      res.status(500).json({
        success: false,
        message: "Failed to get invoice source tracking",
        error: error.message,
      });
    }
  },
};

module.exports = saleController;
