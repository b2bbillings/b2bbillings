const mongoose = require("mongoose");

// Payment History Schema (shared with Purchase and Sale models)
const paymentHistorySchema = new mongoose.Schema({
  amount: {
    type: Number,
    required: true,
    min: 0,
  },
  method: {
    type: String,
    enum: [
      "cash",
      "card",
      "upi",
      "bank_transfer",
      "cheque",
      "credit",
      "online",
      "bank",
    ],
    default: "cash",
  },
  reference: {
    type: String,
    trim: true,
    default: "",
  },
  paymentDate: {
    type: Date,
    required: true,
    default: Date.now,
  },
  dueDate: {
    type: Date,
    default: null,
  },
  notes: {
    type: String,
    trim: true,
    default: "",
  },
  createdAt: {
    type: Date,
    default: Date.now,
  },
  createdBy: {
    type: String,
    default: "system",
  },
});

// Purchase Order Schema (streamlined for controller usage)
const purchaseOrderSchema = new mongoose.Schema(
  {
    // ✅ Core order fields (used in controller)
    orderNumber: {
      type: String,
      required: true,
      unique: true,
      trim: true,
      index: true,
    },
    orderDate: {
      type: Date,
      required: true,
      default: Date.now,
    },
    orderType: {
      type: String,
      enum: ["purchase_order", "purchase_quotation", "proforma_purchase"],
      default: "purchase_order",
      required: true,
    },

    // ✅ Date fields (used in controller)
    validUntil: {
      type: Date,
      default: null,
    },
    expectedDeliveryDate: {
      type: Date,
      default: null,
    },
    deliveryDate: {
      type: Date,
      default: null,
    },

    // ✅ Supplier info (used in controller)
    supplier: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "Party",
      required: true,
      index: true,
    },
    supplierMobile: {
      type: String,
      trim: true,
    },

    // ✅ GST settings (used in controller)
    gstEnabled: {
      type: Boolean,
      required: true,
      default: true,
    },
    gstType: {
      type: String,
      enum: ["gst", "non-gst"],
      default: "gst",
    },
    taxMode: {
      type: String,
      enum: ["with-tax", "without-tax", "inclusive", "exclusive"],
      default: "without-tax",
    },
    priceIncludesTax: {
      type: Boolean,
      default: false,
    },

    // ✅ Company reference (used in controller)
    companyId: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "Company",
      required: true,
      index: true,
    },

    // ✅ Numbering metadata (used in controller for tracking auto-generation)
    numberingInfo: {
      wasAutoGenerated: {
        type: Boolean,
        default: true,
      },
      generatedBy: {
        type: String,
        default: "model",
      },
      generationMethod: {
        type: String,
        enum: ["sequential", "pattern", "fallback"],
        default: "sequential",
      },
      sequenceNumber: {
        type: Number,
        default: null,
      },
      generatedAt: {
        type: Date,
        default: Date.now,
      },
    },

    // ✅ ENHANCED: Bidirectional tracking with targetCompanyId
    sourceOrderId: {
      type: mongoose.Schema.Types.ObjectId,
      default: null,
    },
    sourceOrderNumber: {
      type: String,
      default: null,
    },
    sourceOrderType: {
      type: String,
      enum: {
        values: ["sales-order", "quotation", "proforma-invoice", null],
        message:
          "sourceOrderType must be one of: sales-order, quotation, proforma-invoice, or null",
      },
      default: null,
    },
    sourceCompanyId: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "Company",
      default: null,
      index: true,
    },

    // ✅ NEW: Target Company ID (fixes populate error)
    targetCompanyId: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "Company",
      default: null,
      index: true,
    },

    // ✅ ENHANCED: Corresponding Sales Order tracking
    correspondingSalesOrderId: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "SalesOrder",
      default: null,
      index: true,
    },
    correspondingSalesOrderNumber: {
      type: String,
      default: null,
    },

    // ✅ Auto-generation tracking (used in controller)
    isAutoGenerated: {
      type: Boolean,
      default: false,
    },
    generatedFrom: {
      type: String,
      enum: ["sales_order", "manual", "import", "api"],
      default: "manual",
    },
    generatedBy: {
      type: String,
      default: null,
    },
    generatedAt: {
      type: Date,
      default: null,
    },

    // ✅ NEW: Sales Order generation tracking
    autoGeneratedSalesOrder: {
      type: Boolean,
      default: false,
    },
    salesOrderRef: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "SalesOrder",
      default: null,
    },
    salesOrderNumber: {
      type: String,
      default: null,
    },
    salesOrderGeneratedAt: {
      type: Date,
      default: null,
    },
    salesOrderGeneratedBy: {
      type: String,
      default: null,
    },

    // ✅ Items array (used extensively in controller)
    items: [
      {
        // Item Reference and Details
        itemRef: {
          type: mongoose.Schema.Types.ObjectId,
          ref: "Item",
          sparse: true,
        },
        selectedProduct: {
          type: String,
          default: "",
        },
        itemName: {
          type: String,
          required: true,
          trim: true,
        },
        productName: {
          type: String,
          trim: true,
        },
        itemCode: {
          type: String,
          trim: true,
          default: "",
        },
        productCode: {
          type: String,
          trim: true,
          default: "",
        },
        description: {
          type: String,
          trim: true,
          default: "",
        },
        hsnCode: {
          type: String,
          trim: true,
          default: "0000",
        },
        hsnNumber: {
          type: String,
          trim: true,
          default: "0000",
        },
        category: {
          type: String,
          trim: true,
          default: "",
        },

        // Quantity and Pricing
        quantity: {
          type: Number,
          required: true,
          min: 0.01,
        },
        unit: {
          type: String,
          enum: [
            "NONE",
            "KG",
            "GM",
            "LTR",
            "ML",
            "PCS",
            "BOX",
            "M",
            "CM",
            "BAG",
            "BTL",
            "BUN",
            "CAN",
            "CTN",
            "DOZ",
            "DRM",
            "FEW",
            "GMS",
            "GRS",
            "KGS",
            "KME",
            "MLS",
            "MTR",
            "NOS",
            "PAC",
            "QTL",
            "ROL",
            "SET",
            "SQF",
            "SQM",
            "TBS",
            "TGM",
            "THD",
            "TON",
            "TUB",
            "UGS",
            "UNT",
            "YDS",
            "OTH",
            "pcs",
          ],
          default: "PCS",
        },
        pricePerUnit: {
          type: Number,
          required: true,
          min: 0,
        },
        price: {
          type: Number,
          min: 0,
        },
        rate: {
          type: Number,
          min: 0,
        },

        // Tax Information
        taxRate: {
          type: Number,
          default: 18,
          min: 0,
          max: 100,
        },
        gstRate: {
          type: Number,
          default: 18,
          min: 0,
          max: 100,
        },
        taxMode: {
          type: String,
          enum: [
            "with-tax",
            "without-tax",
            "include",
            "exclude",
            "inclusive",
            "exclusive",
          ],
          default: "without-tax",
        },
        priceIncludesTax: {
          type: Boolean,
          default: false,
        },

        // Discounts
        discountPercent: {
          type: Number,
          default: 0,
          min: 0,
          max: 100,
        },
        discountAmount: {
          type: Number,
          default: 0,
          min: 0,
        },

        // Tax Amounts
        cgst: {type: Number, default: 0, min: 0},
        sgst: {type: Number, default: 0, min: 0},
        igst: {type: Number, default: 0, min: 0},
        cgstAmount: {type: Number, default: 0, min: 0},
        sgstAmount: {type: Number, default: 0, min: 0},
        igstAmount: {type: Number, default: 0, min: 0},

        // Calculated amounts
        subtotal: {type: Number, default: 0, min: 0},
        taxableAmount: {type: Number, default: 0, min: 0},
        totalTaxAmount: {type: Number, default: 0, min: 0},
        gstAmount: {type: Number, default: 0, min: 0},

        // Final amounts
        amount: {type: Number, default: 0, min: 0},
        itemAmount: {type: Number, required: true, min: 0},
        totalAmount: {type: Number, default: 0, min: 0},

        // Line ordering
        lineNumber: {type: Number, required: true, min: 1},
        availableStock: {type: Number, default: 0},
      },
    ],

    // ✅ Totals (used in controller)
    totals: {
      subtotal: {type: Number, required: true, default: 0},
      totalQuantity: {type: Number, default: 0},
      totalDiscount: {type: Number, default: 0},
      totalDiscountAmount: {type: Number, default: 0},
      totalTax: {type: Number, default: 0},
      totalCGST: {type: Number, default: 0},
      totalSGST: {type: Number, default: 0},
      totalIGST: {type: Number, default: 0},
      totalTaxableAmount: {type: Number, default: 0},
      finalTotal: {type: Number, required: true, min: 0},
      roundOff: {type: Number, default: 0},
      withTaxTotal: {type: Number, default: 0},
      withoutTaxTotal: {type: Number, default: 0},
    },

    // ✅ Payment (used in controller)
    payment: {
      method: {
        type: String,
        enum: [
          "cash",
          "card",
          "upi",
          "bank_transfer",
          "cheque",
          "credit",
          "online",
          "bank",
        ],
        default: "cash",
      },
      status: {
        type: String,
        enum: ["pending", "partial", "paid", "cancelled", "overdue"],
        default: "pending",
      },
      paidAmount: {type: Number, default: 0, min: 0},
      pendingAmount: {type: Number, default: 0, min: 0},
      advanceAmount: {type: Number, default: 0, min: 0},
      paymentDate: {type: Date, default: Date.now},
      dueDate: {type: Date, default: null, index: true},
      creditDays: {type: Number, default: 0, min: 0},
      reference: {type: String, trim: true, default: ""},
      notes: {type: String, trim: true, default: ""},
    },

    // ✅ Payment History (used in controller)
    paymentHistory: [paymentHistorySchema],

    // ✅ Status (used extensively in controller)
    status: {
      type: String,
      enum: [
        "draft",
        "sent",
        "confirmed",
        "received",
        "partially_received",
        "cancelled",
        "completed",
      ],
      default: "draft",
      index: true,
    },

    // ✅ Conversion tracking (used in controller)
    convertedToPurchaseInvoice: {
      type: Boolean,
      default: false,
      index: true,
    },
    purchaseInvoiceRef: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "Purchase",
      default: null,
    },
    purchaseInvoiceNumber: {
      type: String,
      default: null,
    },
    convertedAt: {
      type: Date,
      default: null,
    },
    convertedBy: {
      type: String,
      default: null,
    },

    // ✅ Priority (used in controller)
    priority: {
      type: String,
      enum: ["low", "normal", "high", "urgent"],
      default: "normal",
    },

    // ✅ Purchase-specific fields (used in controller)
    requiredBy: {
      type: Date,
      default: null,
    },
    departmentRef: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "Department",
      default: null,
    },
    approvedBy: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "User",
      default: null,
    },
    approvedAt: {
      type: Date,
      default: null,
    },

    // ✅ Additional info (used in controller)
    notes: {type: String, trim: true, default: ""},
    termsAndConditions: {type: String, trim: true, default: ""},
    supplierNotes: {type: String, trim: true, default: ""},
    internalNotes: {type: String, trim: true, default: ""},

    // ✅ Shipping (used in controller)
    shippingAddress: {
      street: {type: String, trim: true, default: ""},
      city: {type: String, trim: true, default: ""},
      state: {type: String, trim: true, default: ""},
      zipCode: {type: String, trim: true, default: ""},
      country: {type: String, trim: true, default: "India"},
    },

    // ✅ Round-off (used in controller)
    roundOff: {type: Number, default: 0},
    roundOffEnabled: {type: Boolean, default: false},

    // ✅ Metadata (used in controller)
    createdBy: {type: String, default: "system"},
    lastModifiedBy: {type: String, default: "system"},
  },
  {
    timestamps: true,
    toJSON: {virtuals: true},
    toObject: {virtuals: true},
  }
);

// ✅ ENHANCED INDEXES (including new fields)
purchaseOrderSchema.index({companyId: 1, orderNumber: 1}, {unique: true});
purchaseOrderSchema.index({companyId: 1, supplier: 1});
purchaseOrderSchema.index({companyId: 1, orderDate: 1});
purchaseOrderSchema.index({companyId: 1, status: 1});
purchaseOrderSchema.index({companyId: 1, orderDate: 1, orderType: 1});
purchaseOrderSchema.index({"numberingInfo.sequenceNumber": 1});
purchaseOrderSchema.index({companyId: 1, validUntil: 1});
purchaseOrderSchema.index({"payment.status": 1});
purchaseOrderSchema.index({"payment.dueDate": 1});
purchaseOrderSchema.index({requiredBy: 1});
purchaseOrderSchema.index({sourceOrderId: 1, sourceOrderType: 1});
purchaseOrderSchema.index({sourceCompanyId: 1}); // ✅ NEW
purchaseOrderSchema.index({targetCompanyId: 1}); // ✅ NEW
purchaseOrderSchema.index({correspondingSalesOrderId: 1}); // ✅ NEW
purchaseOrderSchema.index({salesOrderRef: 1}); // ✅ NEW
purchaseOrderSchema.index({isAutoGenerated: 1});
purchaseOrderSchema.index({
  convertedToPurchaseInvoice: 1,
  purchaseInvoiceRef: 1,
});

// ✅ ENHANCED VIRTUAL FIELDS
purchaseOrderSchema.virtual("balanceAmount").get(function () {
  const total = this.totals?.finalTotal || 0;
  const paid = this.payment?.paidAmount || 0;
  return Math.max(0, total - paid);
});

purchaseOrderSchema.virtual("isExpired").get(function () {
  if (!this.validUntil) return false;
  return new Date() > this.validUntil;
});

purchaseOrderSchema.virtual("isOverdue").get(function () {
  if (!this.payment?.dueDate || this.payment?.pendingAmount <= 0) return false;
  return new Date() > this.payment.dueDate;
});

purchaseOrderSchema.virtual("isRequiredDatePassed").get(function () {
  if (!this.requiredBy) return false;
  return new Date() > this.requiredBy;
});

purchaseOrderSchema.virtual("isFromSalesOrder").get(function () {
  return !!(this.sourceOrderId && this.sourceOrderType && this.sourceCompanyId);
});

// ✅ NEW: Enhanced tracking virtuals
purchaseOrderSchema.virtual("hasCorrespondingSalesOrder").get(function () {
  return !!(
    this.correspondingSalesOrderId && this.correspondingSalesOrderNumber
  );
});

purchaseOrderSchema.virtual("hasGeneratedSalesOrder").get(function () {
  return !!(this.autoGeneratedSalesOrder && this.salesOrderRef);
});

purchaseOrderSchema.virtual("trackingInfo").get(function () {
  return {
    hasSource: !!this.sourceOrderId,
    hasCorresponding: !!this.correspondingSalesOrderId,
    hasGenerated: !!this.salesOrderRef,
    hasConverted: !!this.purchaseInvoiceRef,
    isAutoGenerated: this.isAutoGenerated,
    sourceCompany: this.sourceCompanyId?.toString(),
    targetCompany: this.targetCompanyId?.toString(),
  };
});

// ✅ FIXED: Pre-validate middleware for automatic order number generation
purchaseOrderSchema.pre("validate", async function (next) {
  if (this.isNew && !this.orderNumber) {
    try {
      console.log("🔢 Generating purchase order number before validation...");

      const date = new Date();
      const year = date.getFullYear();
      const month = String(date.getMonth() + 1).padStart(2, "0");
      const day = String(date.getDate()).padStart(2, "0");
      const dateStr = `${year}${month}${day}`;

      // ✅ Get company details for prefix
      let companyPrefix = "PO";
      if (this.companyId) {
        try {
          const Company = require("./Company");
          const company = await Company.findById(this.companyId).select(
            "code businessName"
          );

          if (company?.code) {
            companyPrefix = company.code
              .toUpperCase()
              .replace(/[^A-Z0-9]/g, "")
              .substring(0, 6);
          } else if (company?.businessName) {
            companyPrefix = company.businessName
              .replace(/[^A-Za-z]/g, "")
              .substring(0, 3)
              .toUpperCase();
          }
        } catch (companyError) {
          console.warn("Could not fetch company details, using default prefix");
        }
      }

      // ✅ FIXED: Determine order type prefix
      let orderTypePrefix = "PO"; // Default Purchase Order
      if (this.orderType === "purchase_quotation") {
        orderTypePrefix = "QUO";
      } else if (this.orderType === "proforma_purchase") {
        orderTypePrefix = "PPO";
      }

      // ✅ RESTORED: GST prefix based on actual GST type
      const gstPrefix =
        this.gstEnabled || this.gstType === "gst" ? "GST-" : "NGST-";

      // ✅ FIXED: Base pattern WITH GST prefix for proper differentiation
      const basePattern = `${companyPrefix}-${orderTypePrefix}-${gstPrefix}${dateStr}`;

      // Enhanced: Find company-specific sequential number with better collision handling
      const todayStart = new Date(year, date.getMonth(), date.getDate());
      const todayEnd = new Date(year, date.getMonth(), date.getDate() + 1);

      const lastOrder = await this.constructor
        .findOne({
          companyId: this.companyId,
          orderDate: {$gte: todayStart, $lt: todayEnd},
          orderType: this.orderType,
          gstType: this.gstType, // ✅ CRITICAL: Filter by GST type for proper sequence
          orderNumber: {
            $exists: true,
            $ne: null,
            $ne: "",
            $regex: new RegExp(
              `^${basePattern.replace(/[.*+?^${}()|[\]\\]/g, "\\$&")}-\\d+$`
            ),
          },
          _id: {$ne: this._id},
        })
        .sort({orderNumber: -1, createdAt: -1});

      let sequenceNumber = 1;

      if (lastOrder && lastOrder.orderNumber) {
        const regex = new RegExp(
          `^${basePattern.replace(/[.*+?^${}()|[\]\\]/g, "\\$&")}-(\\d+)$`
        );
        const match = lastOrder.orderNumber.match(regex);

        if (match) {
          const lastSequence = parseInt(match[1]);
          if (!isNaN(lastSequence)) {
            sequenceNumber = lastSequence + 1;
          }
        }
      }

      // ✅ Enhanced: Check for collision and increment if necessary
      let attempts = 0;
      const maxAttempts = 10;
      let finalOrderNumber = null;

      while (attempts < maxAttempts) {
        const sequenceStr = sequenceNumber.toString().padStart(4, "0");
        const candidateNumber = `${basePattern}-${sequenceStr}`;

        // Check if this number already exists
        const existingOrder = await this.constructor.findOne({
          companyId: this.companyId,
          orderNumber: candidateNumber,
          _id: {$ne: this._id},
        });

        if (!existingOrder) {
          finalOrderNumber = candidateNumber;
          break;
        }

        sequenceNumber++;
        attempts++;
      }

      if (!finalOrderNumber) {
        // ✅ Fallback with timestamp
        const timestamp = Date.now().toString().slice(-6);
        finalOrderNumber = `${basePattern}-FALLBACK-${timestamp}`;
        console.warn(
          `⚠️ Using fallback order number after ${maxAttempts} attempts: ${finalOrderNumber}`
        );
      }

      this.orderNumber = finalOrderNumber;

      console.log(`✅ Generated purchase order number: ${this.orderNumber}`, {
        companyId: this.companyId.toString(),
        companyPrefix,
        orderTypePrefix,
        gstPrefix,
        dateStr,
        sequenceNumber: sequenceNumber - attempts,
        orderType: this.orderType,
        gstType: this.gstType,
        attempts,
        pattern: `${companyPrefix}-${orderTypePrefix}-${gstPrefix}YYYYMMDD-NNNN`,
      });
    } catch (error) {
      console.error("❌ Error generating purchase order number:", error);
      // ✅ Final fallback
      const timestamp = Date.now().toString().slice(-6);
      const orderTypePrefix =
        this.orderType === "purchase_quotation"
          ? "QUO"
          : this.orderType === "proforma_purchase"
          ? "PPO"
          : "PO";
      const gstPrefix =
        this.gstEnabled || this.gstType === "gst" ? "GST-" : "NGST-";
      this.orderNumber = `${orderTypePrefix}-${gstPrefix}ERROR-${timestamp}`;
      console.log(`⚠️ Using error fallback order number: ${this.orderNumber}`);
    }
  }

  next();
});
// ✅ ENHANCED: Pre-save middleware
purchaseOrderSchema.pre("save", function (next) {
  // ============================================================================
  // STEP 1: SET NUMBERING METADATA (after order number is generated)
  // ============================================================================
  if (this.isNew && this.orderNumber) {
    // Extract sequence number from order number for metadata
    const sequenceMatch = this.orderNumber.match(/-(\d+)$/);
    const sequenceNumber = sequenceMatch ? parseInt(sequenceMatch[1]) : null;

    this.numberingInfo = {
      wasAutoGenerated: true,
      generatedBy: "model",
      generationMethod:
        this.orderNumber.includes("FALLBACK") ||
        this.orderNumber.includes("ERROR")
          ? "fallback"
          : "sequential",
      sequenceNumber: sequenceNumber,
      generatedAt: new Date(),
    };
  }

  // ============================================================================
  // STEP 2: SYNC ESSENTIAL TAX FIELDS
  // ============================================================================
  if (this.gstType) {
    this.gstEnabled = this.gstType === "gst";
  }

  if (this.taxMode) {
    this.priceIncludesTax =
      this.taxMode === "with-tax" || this.taxMode === "inclusive";
  }

  // ============================================================================
  // STEP 3: PROCESS ITEMS (essential field syncing only)
  // ============================================================================
  this.items.forEach((item, index) => {
    if (!item.lineNumber) item.lineNumber = index + 1;

    // Sync essential fields only
    if (item.productName && !item.itemName) item.itemName = item.productName;
    if (item.itemName && !item.productName) item.productName = item.itemName;
    if (item.productCode && !item.itemCode) item.itemCode = item.productCode;
    if (item.itemCode && !item.productCode) item.productCode = item.itemCode;
    if (item.hsnNumber && !item.hsnCode) item.hsnCode = item.hsnNumber;
    if (item.hsnCode && !item.hsnNumber) item.hsnNumber = item.hsnCode;

    // Sync prices
    if (item.price && !item.pricePerUnit) item.pricePerUnit = item.price;
    if (item.pricePerUnit && !item.price) item.price = item.pricePerUnit;
    if (item.rate && !item.pricePerUnit) item.pricePerUnit = item.rate;
    if (item.pricePerUnit && !item.rate) item.rate = item.pricePerUnit;

    // Sync GST rates
    if (item.gstRate && !item.taxRate) item.taxRate = item.gstRate;
    if (item.taxRate && !item.gstRate) item.gstRate = item.taxRate;

    // Sync amounts
    if (item.totalAmount && !item.amount) item.amount = item.totalAmount;
    if (item.amount && !item.totalAmount) item.totalAmount = item.amount;
    if (item.itemAmount && !item.amount) item.amount = item.itemAmount;
    if (item.amount && !item.itemAmount) item.itemAmount = item.amount;

    // Sync tax amounts
    if (item.gstAmount && !item.totalTaxAmount)
      item.totalTaxAmount = item.gstAmount;
    if (item.totalTaxAmount && !item.gstAmount)
      item.gstAmount = item.totalTaxAmount;
  });

  // ============================================================================
  // STEP 4: UPDATE PAYMENT STATUS
  // ============================================================================
  if (this.payment && this.totals) {
    const paidAmount = this.payment.paidAmount || 0;
    const finalTotal = this.totals.finalTotal || 0;

    this.payment.pendingAmount = Math.max(0, finalTotal - paidAmount);

    if (paidAmount >= finalTotal && finalTotal > 0) {
      this.payment.status = "paid";
    } else if (paidAmount > 0) {
      this.payment.status = "partial";
    } else {
      this.payment.status = "pending";
    }
  }

  // ============================================================================
  // STEP 5: AUTO-GENERATION METADATA
  // ============================================================================
  if (this.isAutoGenerated && this.isNew) {
    if (!this.generatedAt) this.generatedAt = new Date();
    if (!this.generatedBy) this.generatedBy = "system";
  }

  next();
});

// ✅ ENHANCED: Instance method to create corresponding sales order
purchaseOrderSchema.methods.createCorrespondingSalesOrder = async function () {
  if (this.correspondingSalesOrderId) {
    throw new Error("Corresponding sales order already exists");
  }

  if (!this.targetCompanyId) {
    throw new Error(
      "Target company ID is required to create corresponding sales order"
    );
  }

  try {
    const SalesOrder = mongoose.model("SalesOrder");

    // Convert items with proper field mapping
    const convertedItems = this.items.map((item) => {
      const itemObj = item.toObject ? item.toObject() : {...item};
      delete itemObj._id;

      return {
        itemRef: itemObj.itemRef,
        itemName: itemObj.itemName || itemObj.productName,
        itemCode: itemObj.itemCode || itemObj.productCode,
        hsnCode: itemObj.hsnCode || itemObj.hsnNumber || "0000",
        description: itemObj.description || "",
        category: itemObj.category || "",
        quantity: itemObj.quantity,
        unit: itemObj.unit === "pcs" ? "PCS" : itemObj.unit,
        pricePerUnit: itemObj.pricePerUnit || itemObj.price || itemObj.rate,
        taxRate: itemObj.taxRate || itemObj.gstRate || 18,
        taxMode: itemObj.taxMode,
        priceIncludesTax: itemObj.priceIncludesTax,
        discountPercent: itemObj.discountPercent || 0,
        discountAmount: itemObj.discountAmount || 0,
        cgst: itemObj.cgst || 0,
        sgst: itemObj.sgst || 0,
        igst: itemObj.igst || 0,
        cgstAmount: itemObj.cgstAmount || 0,
        sgstAmount: itemObj.sgstAmount || 0,
        igstAmount: itemObj.igstAmount || 0,
        taxableAmount: itemObj.taxableAmount || itemObj.subtotal || 0,
        totalTaxAmount: itemObj.totalTaxAmount || itemObj.gstAmount || 0,
        amount: itemObj.amount || itemObj.totalAmount || itemObj.itemAmount,
        itemAmount: itemObj.itemAmount || itemObj.totalAmount || itemObj.amount,
        lineNumber: itemObj.lineNumber,
      };
    });

    // Create sales order data
    const salesOrderData = {
      // Will be auto-generated by SalesOrder model
      orderDate: new Date(),
      orderType:
        this.orderType === "purchase_quotation" ? "quotation" : "sales_order",
      validUntil: this.validUntil,
      expectedDeliveryDate: this.expectedDeliveryDate,
      customer: this.supplier, // The supplier becomes the customer
      customerMobile: this.supplierMobile,
      gstEnabled: this.gstEnabled,
      gstType: this.gstType,
      taxMode: this.taxMode,
      priceIncludesTax: this.priceIncludesTax,
      companyId: this.targetCompanyId, // Target company
      items: convertedItems,
      totals: {...this.totals},
      payment: {
        ...this.payment,
        status: "pending",
        paidAmount: 0,
        pendingAmount: this.totals?.finalTotal || 0,
      },
      sourceOrderId: this._id,
      sourceOrderNumber: this.orderNumber,
      sourceOrderType: this.orderType,
      sourceCompanyId: this.companyId, // Source company
      isAutoGenerated: true,
      generatedFrom: "purchase_order",
      generatedBy: this.createdBy || "system",
      notes: this.notes
        ? `${this.notes} | Generated from Purchase Order ${this.orderNumber}`
        : `Generated from Purchase Order ${this.orderNumber}`,
      termsAndConditions: this.termsAndConditions || "",
      status: "draft",
      priority: this.priority,
      roundOff: this.roundOff || 0,
      roundOffEnabled: this.roundOffEnabled || false,
      createdBy: this.createdBy || "system",
      lastModifiedBy: this.lastModifiedBy || "system",
    };

    // Create the sales order
    const salesOrder = new SalesOrder(salesOrderData);
    await salesOrder.save();

    // Update this purchase order
    this.correspondingSalesOrderId = salesOrder._id;
    this.correspondingSalesOrderNumber = salesOrder.orderNumber;

    await this.save();

    return salesOrder;
  } catch (error) {
    throw new Error(
      `Failed to create corresponding sales order: ${error.message}`
    );
  }
};

// ✅ ESSENTIAL INSTANCE METHODS (unchanged)

// Add payment method (used in controller)
purchaseOrderSchema.methods.addPayment = function (
  amount,
  method = "cash",
  reference = "",
  notes = ""
) {
  const currentPaid = this.payment?.paidAmount || 0;
  const newPaidAmount = currentPaid + parseFloat(amount);

  this.payment = {
    ...this.payment,
    paidAmount: newPaidAmount,
    method,
    reference,
    paymentDate: new Date(),
    notes,
  };

  // Add to payment history
  if (!this.paymentHistory) this.paymentHistory = [];

  this.paymentHistory.push({
    amount: parseFloat(amount),
    method,
    reference,
    paymentDate: new Date(),
    notes,
    createdAt: new Date(),
  });

  return this.save();
};

// Convert to Purchase Invoice (used in controller) - unchanged
purchaseOrderSchema.methods.convertToPurchaseInvoice = async function () {
  if (this.convertedToPurchaseInvoice) {
    throw new Error("Purchase order already converted to invoice");
  }

  try {
    // Import Purchase model
    const Purchase = mongoose.model("Purchase");

    // ✅ Generate purchase invoice number with company-specific pattern
    const generatePurchaseInvoiceNumber = async (companyId) => {
      const currentDate = new Date();
      const year = currentDate.getFullYear();
      const month = String(currentDate.getMonth() + 1).padStart(2, "0");
      const day = String(currentDate.getDate()).padStart(2, "0");
      const dateStr = `${year}${month}${day}`;

      // Get company details for prefix
      let companyPrefix = "PINV";
      try {
        const Company = require("./Company");
        const company = await Company.findById(companyId).select(
          "code businessName"
        );

        if (company?.code) {
          companyPrefix = company.code
            .toUpperCase()
            .replace(/[^A-Z0-9]/g, "")
            .substring(0, 6);
        } else if (company?.businessName) {
          companyPrefix = company.businessName
            .replace(/[^A-Za-z]/g, "")
            .substring(0, 3)
            .toUpperCase();
        }
        companyPrefix += "-PINV";
      } catch (error) {
        console.warn("Could not fetch company details for invoice number");
      }

      const todayStart = new Date(
        year,
        currentDate.getMonth(),
        currentDate.getDate()
      );
      const todayEnd = new Date(
        year,
        currentDate.getMonth(),
        currentDate.getDate() + 1
      );

      // Include GST prefix if enabled
      const gstPrefix = this.gstEnabled || this.gstType === "gst" ? "GST-" : "";

      const lastInvoice = await Purchase.findOne({
        companyId: companyId,
        invoiceDate: {$gte: todayStart, $lt: todayEnd},
        invoiceNumber: {
          $regex: new RegExp(`^${companyPrefix}-${gstPrefix}${dateStr}`),
        },
      }).sort({invoiceNumber: -1});

      let nextNumber = 1;
      if (lastInvoice && lastInvoice.invoiceNumber) {
        const regex = new RegExp(
          `^${companyPrefix}-${gstPrefix}${dateStr}-(\\d+)$`
        );
        const match = lastInvoice.invoiceNumber.match(regex);
        if (match) {
          const lastNumber = parseInt(match[1]);
          if (!isNaN(lastNumber)) {
            nextNumber = lastNumber + 1;
          }
        }
      }

      return `${companyPrefix}-${gstPrefix}${dateStr}-${nextNumber
        .toString()
        .padStart(4, "0")}`;
    };

    const invoiceNumber = await generatePurchaseInvoiceNumber(this.companyId);

    // Convert items with proper field mapping
    const convertedItems = this.items.map((item) => {
      const itemObj = item.toObject ? item.toObject() : {...item};
      delete itemObj._id;

      return {
        itemRef: itemObj.itemRef,
        itemName: itemObj.itemName || itemObj.productName,
        itemCode: itemObj.itemCode || itemObj.productCode,
        hsnCode: itemObj.hsnCode || itemObj.hsnNumber || "0000",
        description: itemObj.description || "",
        category: itemObj.category || "",
        quantity: itemObj.quantity,
        unit: itemObj.unit === "pcs" ? "PCS" : itemObj.unit,
        pricePerUnit: itemObj.pricePerUnit || itemObj.price || itemObj.rate,
        taxRate: itemObj.taxRate || itemObj.gstRate || 18,
        taxMode:
          itemObj.taxMode === "with-tax" || itemObj.taxMode === "inclusive"
            ? "with-tax"
            : "without-tax",
        priceIncludesTax:
          itemObj.taxMode === "with-tax" || itemObj.taxMode === "inclusive",
        discountPercent: itemObj.discountPercent || 0,
        discountAmount: itemObj.discountAmount || 0,
        cgst: itemObj.cgst || 0,
        sgst: itemObj.sgst || 0,
        igst: itemObj.igst || 0,
        cgstAmount: itemObj.cgstAmount || 0,
        sgstAmount: itemObj.sgstAmount || 0,
        igstAmount: itemObj.igstAmount || 0,
        taxableAmount: itemObj.taxableAmount || itemObj.subtotal || 0,
        totalTaxAmount: itemObj.totalTaxAmount || itemObj.gstAmount || 0,
        amount: itemObj.amount || itemObj.totalAmount || itemObj.itemAmount,
        itemAmount: itemObj.itemAmount || itemObj.totalAmount || itemObj.amount,
        lineNumber: itemObj.lineNumber,
      };
    });

    // Create purchase invoice data
    const purchaseInvoiceData = {
      invoiceNumber: invoiceNumber,
      invoiceDate: new Date(),
      invoiceType: this.gstEnabled ? "gst" : "non-gst",
      supplier: this.supplier,
      supplierMobile: this.supplierMobile,
      gstEnabled: this.gstEnabled,
      gstType: this.gstType,
      taxMode: this.taxMode,
      priceIncludesTax: this.priceIncludesTax,
      companyId: this.companyId,
      items: convertedItems,
      totals: {
        subtotal: this.totals?.subtotal || 0,
        totalQuantity: this.totals?.totalQuantity || 0,
        totalDiscount: this.totals?.totalDiscount || 0,
        totalDiscountAmount: this.totals?.totalDiscountAmount || 0,
        totalTax: this.totals?.totalTax || 0,
        totalCGST: this.totals?.totalCGST || 0,
        totalSGST: this.totals?.totalSGST || 0,
        totalIGST: this.totals?.totalIGST || 0,
        totalTaxableAmount: this.totals?.totalTaxableAmount || 0,
        finalTotal: this.totals?.finalTotal || 0,
        roundOff: this.totals?.roundOff || 0,
        withTaxTotal: this.totals?.withTaxTotal || 0,
        withoutTaxTotal: this.totals?.withoutTaxTotal || 0,
      },
      payment: {
        method: this.payment?.method || "credit",
        status:
          (this.payment?.advanceAmount || 0) >= (this.totals?.finalTotal || 0)
            ? "paid"
            : (this.payment?.advanceAmount || 0) > 0
            ? "partial"
            : "pending",
        paidAmount: this.payment?.advanceAmount || 0,
        pendingAmount: Math.max(
          0,
          (this.totals?.finalTotal || 0) - (this.payment?.advanceAmount || 0)
        ),
        paymentDate: this.payment?.paymentDate || new Date(),
        dueDate: this.payment?.dueDate,
        creditDays: this.payment?.creditDays || 0,
        reference:
          this.payment?.reference ||
          `Converted from ${this.orderType} ${this.orderNumber}`,
        notes:
          this.payment?.notes ||
          `Converted from ${this.orderType} ${this.orderNumber}`,
      },
      sourceOrderId: this._id,
      sourceOrderNumber: this.orderNumber,
      sourceOrderType: this.orderType,
      sourceCompanyId: this.companyId,
      isAutoGenerated: false,
      generatedFrom: "purchase_order",
      convertedBy: this.convertedBy || "system",
      notes: this.notes
        ? `${this.notes} | Converted from ${this.orderType} ${this.orderNumber}`
        : `Converted from ${this.orderType} ${this.orderNumber}`,
      termsAndConditions: this.termsAndConditions || "",
      status: "active",
      roundOff: this.roundOff || 0,
      roundOffEnabled: this.roundOffEnabled || false,
      createdBy: this.convertedBy || "system",
      lastModifiedBy: this.convertedBy || "system",
    };

    // Create the purchase invoice
    const invoice = new Purchase(purchaseInvoiceData);
    await invoice.save();

    // Update this purchase order
    this.convertedToPurchaseInvoice = true;
    this.purchaseInvoiceRef = invoice._id;
    this.purchaseInvoiceNumber = invoice.invoiceNumber;
    this.convertedAt = new Date();
    this.status = "completed";
    this.convertedBy = this.convertedBy || "system";

    await this.save();

    return invoice;
  } catch (error) {
    throw new Error(
      `Failed to convert purchase order to invoice: ${error.message}`
    );
  }
};

// ✅ ESSENTIAL STATIC METHODS (unchanged but enhanced)

// Get pending orders (used in controller)
purchaseOrderSchema.statics.getPendingOrders = function (companyId) {
  return this.find({
    companyId,
    status: {$in: ["draft", "sent", "confirmed"]},
    convertedToPurchaseInvoice: false,
  }).populate("supplier", "name mobile email");
};

// Get expired orders (used in controller)
purchaseOrderSchema.statics.getExpiredOrders = function (companyId) {
  return this.find({
    companyId,
    validUntil: {$lt: new Date()},
    status: {$nin: ["completed", "cancelled"]},
  }).populate("supplier", "name mobile email");
};

// Get orders by supplier (used in controller)
purchaseOrderSchema.statics.getOrdersBySupplier = function (supplierId) {
  return this.find({
    supplier: supplierId,
    status: {$ne: "cancelled"},
  }).sort({orderDate: -1});
};

// Get orders required by date (used in controller)
purchaseOrderSchema.statics.getOrdersRequiredByDate = function (
  companyId,
  date
) {
  return this.find({
    companyId,
    requiredBy: {$lte: date},
    status: {$nin: ["completed", "cancelled", "received"]},
  }).populate("supplier", "name mobile email");
};

// Get orders awaiting approval (used in controller)
purchaseOrderSchema.statics.getOrdersAwaitingApproval = function (companyId) {
  return this.find({
    companyId,
    status: "draft",
    approvedBy: null,
  }).populate("supplier", "name mobile email");
};

// ✅ NEW: Get orders with bidirectional tracking
purchaseOrderSchema.statics.getOrdersWithTracking = function (
  companyId,
  options = {}
) {
  const filter = {companyId};

  if (options.includeSourceOrders) {
    // Include orders that have source tracking
    filter.sourceOrderId = {$exists: true, $ne: null};
  }

  if (options.includeGeneratedOrders) {
    // Include orders that generated corresponding sales orders
    filter.salesOrderRef = {$exists: true, $ne: null};
  }

  return this.find(filter)
    .populate("supplier", "name mobile email")
    .populate("sourceCompanyId", "businessName email")
    .populate("targetCompanyId", "businessName email")
    .populate("salesOrderRef", "orderNumber status totals.finalTotal")
    .populate(
      "correspondingSalesOrderId",
      "orderNumber status totals.finalTotal"
    )
    .sort({orderDate: -1});
};

// Export the model
module.exports = mongoose.model("PurchaseOrder", purchaseOrderSchema);
