const mongoose = require("mongoose");

// Payment History Schema (shared with Sale model)
const paymentHistorySchema = new mongoose.Schema({
  amount: {
    type: Number,
    required: true,
    min: 0,
  },
  method: {
    type: String,
    enum: [
      "cash",
      "card",
      "upi",
      "bank_transfer",
      "cheque",
      "credit",
      "online",
      "bank",
    ],
    default: "cash",
  },
  reference: {
    type: String,
    trim: true,
    default: "",
  },
  paymentDate: {
    type: Date,
    required: true,
    default: Date.now,
  },
  dueDate: {
    type: Date,
    default: null,
  },
  notes: {
    type: String,
    trim: true,
    default: "",
  },
  createdAt: {
    type: Date,
    default: Date.now,
  },
  createdBy: {
    type: String,
    default: "system",
  },
});

// Sales Order Schema (Unified for Quotations, Sales Orders, and Proforma Invoices)
const salesOrderSchema = new mongoose.Schema(
  {
    // Order Details
    orderNumber: {
      type: String,
      required: true,
      unique: true,
      trim: true,
      index: true,
    },
    orderDate: {
      type: Date,
      required: true,
      default: Date.now,
    },
    orderType: {
      type: String,
      enum: ["quotation", "sales_order", "proforma_invoice"],
      default: "quotation",
      required: true,
    },

    // Validity and Delivery
    validUntil: {
      type: Date,
      default: null,
    },
    expectedDeliveryDate: {
      type: Date,
      default: null,
    },
    deliveryDate: {
      type: Date,
      default: null,
    },

    // Customer Information
    customer: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "Party",
      required: true,
      index: true,
    },
    customerMobile: {
      type: String,
      trim: true,
    },

    // GST and Tax Settings
    gstEnabled: {
      type: Boolean,
      required: true,
      default: true,
    },
    gstType: {
      type: String,
      enum: ["gst", "non-gst"],
      default: "gst",
    },
    taxMode: {
      type: String,
      enum: ["with-tax", "without-tax", "inclusive", "exclusive"],
      default: "without-tax",
    },
    priceIncludesTax: {
      type: Boolean,
      default: false,
    },

    // Company reference
    companyId: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "Company",
      required: true,
      index: true,
    },

    // Source tracking (when this order was created from another order)
    sourceOrderId: {
      type: mongoose.Schema.Types.ObjectId,
      default: null,
    },
    sourceOrderNumber: {
      type: String,
      default: null,
    },
    sourceOrderType: {
      type: String,
      enum: [
        "purchase_order",
        "purchase-order",
        "purchase_quotation",
        "purchase-quotation",
        "quotation",
        "proforma-invoice",
        "proforma_purchase",
        "proforma-purchase",
        "sales_order",
        "manual",
      ],
      default: "manual",
      required: function () {
        return this.sourceOrderId != null;
      },
    },
    sourceCompanyId: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "Company",
      default: null,
      sparse: true,
    },

    // Target company for bidirectional order generation
    targetCompanyId: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "Company",
      default: null,
      sparse: true,
      index: true,
    },

    // Auto-generation tracking
    isAutoGenerated: {
      type: Boolean,
      default: false,
    },
    generatedFrom: {
      type: String,
      enum: ["purchase_order", "manual", "import", "api"],
      default: "manual",
    },
    generatedBy: {
      type: String,
      default: null,
    },
    generatedAt: {
      type: Date,
      default: null,
    },

    // Purchase order generation tracking
    autoGeneratedPurchaseOrder: {
      type: Boolean,
      default: false,
      index: true,
    },
    purchaseOrderRef: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "PurchaseOrder",
      default: null,
    },
    purchaseOrderNumber: {
      type: String,
      default: null,
    },
    purchaseOrderGeneratedAt: {
      type: Date,
      default: null,
    },
    purchaseOrderGeneratedBy: {
      type: String,
      default: null,
    },
    hasGeneratedPurchaseOrder: {
      type: Boolean,
      default: false,
      index: true,
    },
    correspondingPurchaseOrderId: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "PurchaseOrder",
      default: null,
    },
    correspondingPurchaseOrderNumber: {
      type: String,
      default: null,
    },
    linkedSupplierId: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "Party",
      default: null,
    },

    // Items Array
    items: [
      {
        // Item Reference
        itemRef: {
          type: mongoose.Schema.Types.ObjectId,
          ref: "Item",
          sparse: true,
        },

        // Item Details
        itemName: {
          type: String,
          required: true,
          trim: true,
        },
        productName: {
          type: String,
          trim: true,
        },
        itemCode: {
          type: String,
          trim: true,
          default: "",
        },
        productCode: {
          type: String,
          trim: true,
          default: "",
        },
        description: {
          type: String,
          trim: true,
          default: "",
        },
        hsnCode: {
          type: String,
          trim: true,
          default: "0000",
        },
        hsnNumber: {
          type: String,
          trim: true,
          default: "0000",
        },
        category: {
          type: String,
          trim: true,
          default: "",
        },

        // Quantity and Unit
        quantity: {
          type: Number,
          required: true,
          min: 0.01,
        },
        unit: {
          type: String,
          enum: [
            "NONE",
            "KG",
            "GM",
            "LTR",
            "ML",
            "PCS",
            "BOX",
            "M",
            "CM",
            "BAG",
            "BTL",
            "BUN",
            "CAN",
            "CTN",
            "DOZ",
            "DRM",
            "FEW",
            "GMS",
            "GRS",
            "KGS",
            "KME",
            "MLS",
            "MTR",
            "NOS",
            "PAC",
            "QTL",
            "ROL",
            "SET",
            "SQF",
            "SQM",
            "TBS",
            "TGM",
            "THD",
            "TON",
            "TUB",
            "UGS",
            "UNT",
            "YDS",
            "OTH",
            "pcs",
          ],
          default: "PCS",
        },

        // Pricing Details
        pricePerUnit: {
          type: Number,
          required: true,
          min: 0,
        },
        price: {
          type: Number,
          min: 0,
        },
        rate: {
          type: Number,
          min: 0,
        },
        taxRate: {
          type: Number,
          default: 18,
          min: 0,
          max: 100,
        },
        gstRate: {
          type: Number,
          default: 18,
          min: 0,
          max: 100,
        },
        taxMode: {
          type: String,
          enum: [
            "with-tax",
            "without-tax",
            "include",
            "exclude",
            "inclusive",
            "exclusive",
          ],
          default: "without-tax",
        },
        gstMode: {
          type: String,
          enum: ["include", "exclude"],
          default: "exclude",
        },
        priceIncludesTax: {
          type: Boolean,
          default: false,
        },

        // Stock Info
        availableStock: {
          type: Number,
          default: 0,
        },

        // Discount Fields
        discountPercent: {
          type: Number,
          default: 0,
          min: 0,
          max: 100,
        },
        discountAmount: {
          type: Number,
          default: 0,
          min: 0,
        },
        discount: {
          type: Number,
          default: 0,
          min: 0,
        },
        discountType: {
          type: String,
          enum: ["percentage", "amount"],
          default: "percentage",
        },

        // Tax Amounts
        cgst: {type: Number, default: 0, min: 0},
        sgst: {type: Number, default: 0, min: 0},
        igst: {type: Number, default: 0, min: 0},
        cgstAmount: {type: Number, default: 0, min: 0},
        sgstAmount: {type: Number, default: 0, min: 0},
        igstAmount: {type: Number, default: 0, min: 0},

        // Calculated amounts
        subtotal: {type: Number, default: 0, min: 0},
        taxableAmount: {type: Number, default: 0, min: 0},
        totalTaxAmount: {type: Number, default: 0, min: 0},
        gstAmount: {type: Number, default: 0, min: 0},

        // Final amounts
        amount: {type: Number, default: 0, min: 0},
        itemAmount: {type: Number, required: true, min: 0},
        totalAmount: {type: Number, default: 0, min: 0},

        // Line ordering
        lineNumber: {type: Number, required: true, min: 1},
      },
    ],

    // Totals Section
    totals: {
      subtotal: {type: Number, required: true, default: 0},
      totalQuantity: {type: Number, default: 0},
      totalDiscount: {type: Number, default: 0},
      totalDiscountAmount: {type: Number, default: 0},
      totalTax: {type: Number, default: 0},
      totalCGST: {type: Number, default: 0},
      totalSGST: {type: Number, default: 0},
      totalIGST: {type: Number, default: 0},
      totalTaxableAmount: {type: Number, default: 0},
      finalTotal: {type: Number, required: true, min: 0},
      roundOff: {type: Number, default: 0},
      withTaxTotal: {type: Number, default: 0},
      withoutTaxTotal: {type: Number, default: 0},
    },

    // Payment Information
    payment: {
      method: {
        type: String,
        enum: [
          "cash",
          "card",
          "upi",
          "bank_transfer",
          "cheque",
          "credit",
          "online",
          "bank",
        ],
        default: "cash",
      },
      status: {
        type: String,
        enum: ["pending", "partial", "paid", "cancelled", "overdue"],
        default: "pending",
      },
      paidAmount: {type: Number, default: 0, min: 0},
      pendingAmount: {type: Number, default: 0, min: 0},
      advanceAmount: {type: Number, default: 0, min: 0},
      paymentDate: {type: Date, default: Date.now},
      dueDate: {type: Date, default: null, index: true},
      creditDays: {type: Number, default: 0, min: 0},
      reference: {type: String, trim: true, default: ""},
      notes: {type: String, trim: true, default: ""},
    },

    // Payment History
    paymentHistory: [paymentHistorySchema],

    // ✅ UNIFIED STATUS (works for all order types)
    status: {
      type: String,
      enum: [
        "draft", // Initial creation (manual orders)
        "sent", // Sent to customer/company (auto-generated or manual)
        "accepted", // Customer accepted (quotation) OR Order confirmed (sales_order)
        "rejected", // Customer rejected OR Order cancelled
        "confirmed", // Order confirmed and ready for processing
        "approved", // Internally approved (if needed)
        "processing", // Being processed/prepared
        "shipped", // Shipped to customer
        "delivered", // Delivered to customer
        "completed", // Fully completed
        "converted", // Quotation converted to sales order
        "cancelled", // Cancelled at any stage
        "expired", // Validity expired (quotations)
        "on_hold", // Temporarily on hold
        "received", // For backward compatibility
      ],
      default: null, // Will be set in pre-save based on context
      index: true,
    },

    // Conversion tracking
    convertedToInvoice: {
      type: Boolean,
      default: false,
      index: true,
    },
    invoiceRef: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "Sale",
      default: null,
    },
    invoiceNumber: {
      type: String,
      default: null,
    },
    convertedAt: {
      type: Date,
      default: null,
    },
    convertedBy: {
      type: String,
      default: null,
    },

    // Priority and urgency
    priority: {
      type: String,
      enum: ["low", "normal", "high", "urgent"],
      default: "normal",
    },

    // Order-specific fields
    requiredBy: {
      type: Date,
      default: null,
    },
    departmentRef: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "Department",
      default: null,
    },
    approvedBy: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "User",
      default: null,
    },
    approvedAt: {
      type: Date,
      default: null,
    },

    // Additional Information
    notes: {type: String, trim: true, default: ""},
    termsAndConditions: {type: String, trim: true, default: ""},
    customerNotes: {type: String, trim: true, default: ""},
    internalNotes: {type: String, trim: true, default: ""},

    // Shipping and Delivery
    shippingAddress: {
      street: {type: String, trim: true, default: ""},
      city: {type: String, trim: true, default: ""},
      state: {type: String, trim: true, default: ""},
      zipCode: {type: String, trim: true, default: ""},
      country: {type: String, trim: true, default: "India"},
    },

    // Round-off settings
    roundOff: {type: Number, default: 0},
    roundOffEnabled: {type: Boolean, default: false},

    // Metadata
    createdBy: {type: String, default: "system"},
    lastModifiedBy: {type: String, default: "system"},
  },
  {
    timestamps: true,
    toJSON: {virtuals: true},
    toObject: {virtuals: true},
  }
);

// ✅ ENHANCED INDEXES for better performance
salesOrderSchema.index({companyId: 1, orderNumber: 1}, {unique: true});
salesOrderSchema.index({companyId: 1, customer: 1});
salesOrderSchema.index({companyId: 1, orderDate: 1});
salesOrderSchema.index({companyId: 1, status: 1});
salesOrderSchema.index({companyId: 1, orderType: 1});
salesOrderSchema.index({companyId: 1, validUntil: 1});
salesOrderSchema.index({"payment.status": 1});
salesOrderSchema.index({"payment.dueDate": 1});
salesOrderSchema.index({requiredBy: 1});
salesOrderSchema.index({sourceOrderId: 1, sourceOrderType: 1});
salesOrderSchema.index({sourceCompanyId: 1});
salesOrderSchema.index({targetCompanyId: 1});
salesOrderSchema.index({isAutoGenerated: 1});
salesOrderSchema.index({generatedFrom: 1});
salesOrderSchema.index({convertedToInvoice: 1, invoiceRef: 1});
salesOrderSchema.index({autoGeneratedPurchaseOrder: 1});
salesOrderSchema.index({hasGeneratedPurchaseOrder: 1});
salesOrderSchema.index({purchaseOrderRef: 1});

// ✅ UNIFIED VIRTUAL FIELDS (work for all order types)
salesOrderSchema.virtual("balanceAmount").get(function () {
  const total = this.totals?.finalTotal || 0;
  const paid = this.payment?.paidAmount || 0;
  return Math.max(0, total - paid);
});

salesOrderSchema.virtual("isExpired").get(function () {
  if (!this.validUntil) return false;
  return new Date() > this.validUntil;
});

salesOrderSchema.virtual("isOverdue").get(function () {
  if (!this.payment?.dueDate || this.payment?.pendingAmount <= 0) return false;
  return new Date() > this.payment.dueDate;
});

salesOrderSchema.virtual("isRequiredDatePassed").get(function () {
  if (!this.requiredBy) return false;
  return new Date() > this.requiredBy;
});

salesOrderSchema.virtual("isFromPurchaseOrder").get(function () {
  return !!(this.sourceOrderId && this.sourceOrderType && this.sourceCompanyId);
});

salesOrderSchema.virtual("isBidirectionalOrder").get(function () {
  return !!(this.sourceCompanyId && this.targetCompanyId);
});

salesOrderSchema.virtual("hasPurchaseOrderGenerated").get(function () {
  return !!(this.autoGeneratedPurchaseOrder && this.purchaseOrderRef);
});

// ✅ UNIFIED ORDER TYPE VIRTUALS
salesOrderSchema.virtual("isQuotation").get(function () {
  return this.orderType === "quotation";
});

salesOrderSchema.virtual("isSalesOrder").get(function () {
  return this.orderType === "sales_order";
});

salesOrderSchema.virtual("isProformaInvoice").get(function () {
  return this.orderType === "proforma_invoice";
});

// ✅ UNIFIED STATUS CHECKING VIRTUALS
salesOrderSchema.virtual("isDraft").get(function () {
  return this.status === "draft";
});

salesOrderSchema.virtual("isSent").get(function () {
  return this.status === "sent";
});

salesOrderSchema.virtual("isAccepted").get(function () {
  return this.status === "accepted";
});

salesOrderSchema.virtual("isConfirmed").get(function () {
  return this.status === "confirmed";
});

salesOrderSchema.virtual("isCompleted").get(function () {
  return this.status === "completed";
});

salesOrderSchema.virtual("isCancelled").get(function () {
  return this.status === "cancelled";
});

salesOrderSchema.virtual("isExpiredStatus").get(function () {
  return (
    this.status === "expired" ||
    (this.validUntil && new Date() > this.validUntil)
  );
});

// ✅ UNIFIED ACTION CHECKING VIRTUALS
salesOrderSchema.virtual("canBeAccepted").get(function () {
  return this.status === "sent";
});

salesOrderSchema.virtual("canBeConfirmed").get(function () {
  return ["accepted", "sent"].includes(this.status);
});

salesOrderSchema.virtual("canBeProcessed").get(function () {
  return ["confirmed", "approved"].includes(this.status);
});

salesOrderSchema.virtual("canBeShipped").get(function () {
  return ["processing", "approved"].includes(this.status);
});

salesOrderSchema.virtual("canBeDelivered").get(function () {
  return this.status === "shipped";
});

salesOrderSchema.virtual("canBeCompleted").get(function () {
  return this.status === "delivered";
});

salesOrderSchema.virtual("canBeConvertedToInvoice").get(function () {
  return (
    this.orderType === "sales_order" &&
    ["confirmed", "approved", "processing"].includes(this.status)
  );
});

salesOrderSchema.virtual("canBeConvertedToSalesOrder").get(function () {
  return this.orderType === "quotation" && this.status === "accepted";
});

salesOrderSchema.virtual("needsConfirmation").get(function () {
  return this.status === "sent" && this.isAutoGenerated;
});

// ✅ UNIFIED PRE-VALIDATE MIDDLEWARE
salesOrderSchema.pre("validate", async function (next) {
  // Generate order number if new
  if (this.isNew && !this.orderNumber) {
    try {
      console.log("🔢 Generating order number...");

      const date = new Date();
      const year = date.getFullYear();
      const month = String(date.getMonth() + 1).padStart(2, "0");
      const day = String(date.getDate()).padStart(2, "0");
      const dateStr = `${year}${month}${day}`;

      // Get company details for prefix
      let companyPrefix = "SO";
      if (this.companyId) {
        try {
          const Company = require("./Company");
          const company = await Company.findById(this.companyId).select(
            "code businessName"
          );

          if (company?.code) {
            companyPrefix = company.code
              .toUpperCase()
              .replace(/[^A-Z0-9]/g, "")
              .substring(0, 6);
          } else if (company?.businessName) {
            companyPrefix = company.businessName
              .replace(/[^A-Za-z]/g, "")
              .substring(0, 3)
              .toUpperCase();
          }
        } catch (companyError) {
          console.warn("Could not fetch company details, using default prefix");
        }
      }

      // Determine order type prefix
      let orderTypePrefix = "SO";
      if (this.orderType === "quotation") {
        orderTypePrefix = "QUO";
      } else if (this.orderType === "proforma_invoice") {
        orderTypePrefix = "PI";
      }

      // Find last order for today
      const todayStart = new Date(year, date.getMonth(), date.getDate());
      const todayEnd = new Date(year, date.getMonth(), date.getDate() + 1);

      const lastOrder = await this.constructor
        .findOne({
          companyId: this.companyId,
          orderDate: {$gte: todayStart, $lt: todayEnd},
          orderType: this.orderType,
          orderNumber: {
            $exists: true,
            $ne: null,
            $ne: "",
            $regex: new RegExp(
              `^${companyPrefix}-${orderTypePrefix}-(GST-)?${dateStr}`
            ),
          },
          _id: {$ne: this._id},
        })
        .sort({orderNumber: -1, createdAt: -1});

      let sequenceNumber = 1;

      if (lastOrder && lastOrder.orderNumber) {
        const regex = new RegExp(
          `^${companyPrefix}-${orderTypePrefix}-(GST-)?${dateStr}-(\\d+)$`
        );
        const match = lastOrder.orderNumber.match(regex);

        if (match) {
          const lastSequence = parseInt(match[2] || match[3]);
          if (!isNaN(lastSequence)) {
            sequenceNumber = lastSequence + 1;
          }
        }
      }

      // Generate order number
      const gstPrefix = this.gstEnabled || this.gstType === "gst" ? "GST-" : "";
      const sequenceStr = sequenceNumber.toString().padStart(4, "0");
      this.orderNumber = `${companyPrefix}-${orderTypePrefix}-${gstPrefix}${dateStr}-${sequenceStr}`;

      console.log(`✅ Generated order number: ${this.orderNumber}`);
    } catch (error) {
      console.error("❌ Error generating order number:", error);
      // Fallback
      const timestamp = Date.now().toString().slice(-6);
      const orderTypePrefix =
        this.orderType === "quotation"
          ? "QUO"
          : this.orderType === "proforma_invoice"
          ? "PI"
          : "SO";
      const gstPrefix = this.gstEnabled || this.gstType === "gst" ? "GST-" : "";
      this.orderNumber = `${orderTypePrefix}-${gstPrefix}${timestamp}`;
    }
  }

  next();
});

// ✅ UNIFIED PRE-SAVE MIDDLEWARE
salesOrderSchema.pre("save", function (next) {
  // ============================================================================
  // STEP 1: SET APPROPRIATE INITIAL STATUS BASED ON CONTEXT (UNIFIED)
  // ============================================================================
  if (this.isNew && (!this.status || this.status === null)) {
    // Auto-generated orders (from purchase orders)
    if (this.isAutoGenerated && this.generatedFrom === "purchase_order") {
      this.status = "sent"; // Sent to target company for confirmation
      console.log(`✅ Auto-generated ${this.orderType} → Status: sent`);
    }

    // Converted orders (from quotations to sales orders)
    else if (this.sourceOrderType === "quotation" && this.sourceOrderId) {
      this.status = "confirmed"; // Quotation was accepted, now confirmed
      console.log(`✅ ${this.orderType} from quotation → Status: confirmed`);
    }

    // Bidirectional orders (between companies)
    else if (this.sourceOrderType === "sales_order" && this.targetCompanyId) {
      this.status = "sent"; // Sent to target company
      console.log(`✅ Bidirectional ${this.orderType} → Status: sent`);
    }

    // Manual creation (default)
    else {
      this.status = "draft"; // Manual creation starts as draft
      console.log(`✅ Manual ${this.orderType} → Status: draft`);
    }
  }

  // ============================================================================
  // STEP 2: SYNC GLOBAL TAX MODE FIELDS
  // ============================================================================
  if (this.gstType) {
    this.gstEnabled = this.gstType === "gst";
  }

  if (this.taxMode) {
    this.priceIncludesTax =
      this.taxMode === "with-tax" || this.taxMode === "inclusive";
  }

  // Set generation metadata for auto-generated orders
  if (this.isAutoGenerated && this.isNew) {
    if (!this.generatedAt) {
      this.generatedAt = new Date();
    }
    if (!this.generatedBy) {
      this.generatedBy = "system";
    }
  }

  // ============================================================================
  // STEP 3: PROCESS ITEMS WITH UNIFIED FIELD MAPPING
  // ============================================================================
  this.items.forEach((item, index) => {
    if (!item.lineNumber) item.lineNumber = index + 1;

    // Sync product/item names
    if (item.productName && !item.itemName) {
      item.itemName = item.productName;
    }
    if (item.itemName && !item.productName) {
      item.productName = item.itemName;
    }

    // Sync product/item codes
    if (item.productCode && !item.itemCode) {
      item.itemCode = item.productCode;
    }
    if (item.itemCode && !item.productCode) {
      item.productCode = item.itemCode;
    }

    // Sync HSN numbers
    if (item.hsnNumber && !item.hsnCode) {
      item.hsnCode = item.hsnNumber;
    }
    if (item.hsnCode && !item.hsnNumber) {
      item.hsnNumber = item.hsnCode;
    }

    // Sync core prices
    if (item.price && !item.pricePerUnit) {
      item.pricePerUnit = item.price;
    }
    if (item.pricePerUnit && !item.price) {
      item.price = item.pricePerUnit;
    }
    if (item.rate && !item.pricePerUnit) {
      item.pricePerUnit = item.rate;
    }
    if (item.pricePerUnit && !item.rate) {
      item.rate = item.pricePerUnit;
    }

    // Sync GST rates
    if (item.gstRate && !item.taxRate) {
      item.taxRate = item.gstRate;
    }
    if (item.taxRate && !item.gstRate) {
      item.gstRate = item.taxRate;
    }

    // Sync GST modes
    if (item.gstMode) {
      item.taxMode = item.gstMode === "include" ? "with-tax" : "without-tax";
      item.priceIncludesTax = item.gstMode === "include";
    }
    if (item.taxMode && !item.gstMode) {
      item.gstMode =
        item.taxMode === "with-tax" || item.taxMode === "inclusive"
          ? "include"
          : "exclude";
    }

    // Sync item tax mode with parent
    if (!item.taxMode) {
      item.taxMode = this.taxMode || "without-tax";
      item.priceIncludesTax =
        item.taxMode === "with-tax" || item.taxMode === "inclusive";
    }

    // Sync discount fields
    if (item.discountPercent && !item.discount) {
      item.discount = item.discountPercent;
    }
    if (item.discount && !item.discountPercent) {
      item.discountPercent = item.discount;
    }

    // Sync amounts
    if (item.totalAmount && !item.amount) item.amount = item.totalAmount;
    if (item.amount && !item.totalAmount) item.totalAmount = item.amount;
    if (item.itemAmount && !item.amount) item.amount = item.itemAmount;
    if (item.amount && !item.itemAmount) item.itemAmount = item.amount;

    // Sync tax amounts
    if (item.gstAmount && !item.totalTaxAmount)
      item.totalTaxAmount = item.gstAmount;
    if (item.totalTaxAmount && !item.gstAmount)
      item.gstAmount = item.totalTaxAmount;
  });

  // ============================================================================
  // STEP 4: UPDATE PAYMENT STATUS
  // ============================================================================
  if (this.payment && this.totals) {
    const paidAmount = this.payment.paidAmount || 0;
    const finalTotal = this.totals.finalTotal || 0;

    this.payment.pendingAmount = Math.max(0, finalTotal - paidAmount);

    if (paidAmount >= finalTotal && finalTotal > 0) {
      this.payment.status = "paid";
    } else if (paidAmount > 0) {
      this.payment.status = "partial";
    } else {
      this.payment.status = "pending";
    }
  }

  // ============================================================================
  // STEP 5: UPDATE NOTES WITH TRACKING INFO
  // ============================================================================
  if (this.isNew) {
    let trackingNotes = [];

    if (this.sourceOrderId && this.sourceOrderNumber) {
      trackingNotes.push(
        `Converted from ${this.sourceOrderType.replace("_", " ")} ${
          this.sourceOrderNumber
        }`
      );
    }

    if (this.autoGeneratedPurchaseOrder && this.purchaseOrderNumber) {
      trackingNotes.push(
        `Generated purchase order ${this.purchaseOrderNumber}`
      );
    }

    if (trackingNotes.length > 0) {
      const existingNotes = this.notes ? this.notes.trim() : "";
      const newTrackingInfo = trackingNotes.join(". ");

      if (existingNotes && !existingNotes.includes(newTrackingInfo)) {
        this.notes = `${existingNotes}. ${newTrackingInfo}`;
      } else if (!existingNotes) {
        this.notes = newTrackingInfo;
      }
    }
  }

  next();
});

// ✅ UNIFIED METHODS (work for all order types)

// Accept/Confirm Order (unified method)
salesOrderSchema.methods.acceptOrder = function (acceptedBy = "system") {
  if (this.orderType === "quotation") {
    this.status = "accepted"; // Quotation accepted
    console.log(`✅ Quotation ${this.orderNumber} accepted`);
  } else {
    this.status = "confirmed"; // Sales order confirmed
    console.log(`✅ Sales order ${this.orderNumber} confirmed`);
  }

  this.lastModifiedBy = acceptedBy;
  return this.save();
};

// Reject Order (unified method)
salesOrderSchema.methods.rejectOrder = function (
  rejectedBy = "system",
  reason = ""
) {
  this.status = "rejected";
  this.lastModifiedBy = rejectedBy;

  if (reason) {
    this.notes = this.notes
      ? `${this.notes} | Rejected: ${reason}`
      : `Rejected: ${reason}`;
  }

  console.log(`✅ ${this.orderType} ${this.orderNumber} rejected`);
  return this.save();
};

// Confirm Order (unified method)
salesOrderSchema.methods.confirmOrder = function (confirmedBy = "system") {
  this.status = "confirmed";
  this.lastModifiedBy = confirmedBy;

  console.log(`✅ ${this.orderType} ${this.orderNumber} confirmed`);
  return this.save();
};

// Approve Order (unified method)
salesOrderSchema.methods.approveOrder = function (approvedBy = "system") {
  this.status = "approved";
  this.approvedBy = approvedBy;
  this.approvedAt = new Date();
  this.lastModifiedBy = approvedBy;

  console.log(`✅ ${this.orderType} ${this.orderNumber} approved`);
  return this.save();
};

// Start Processing (unified method)
salesOrderSchema.methods.startProcessing = function (processedBy = "system") {
  this.status = "processing";
  this.lastModifiedBy = processedBy;

  console.log(`✅ ${this.orderType} ${this.orderNumber} processing started`);
  return this.save();
};

// Ship Order (unified method)
salesOrderSchema.methods.shipOrder = function (shippedBy = "system") {
  this.status = "shipped";
  this.lastModifiedBy = shippedBy;

  console.log(`✅ ${this.orderType} ${this.orderNumber} shipped`);
  return this.save();
};

// Deliver Order (unified method)
salesOrderSchema.methods.deliverOrder = function (deliveredBy = "system") {
  this.status = "delivered";
  this.deliveryDate = new Date();
  this.lastModifiedBy = deliveredBy;

  console.log(`✅ ${this.orderType} ${this.orderNumber} delivered`);
  return this.save();
};

// Complete Order (unified method)
salesOrderSchema.methods.completeOrder = function (completedBy = "system") {
  this.status = "completed";
  this.lastModifiedBy = completedBy;

  console.log(`✅ ${this.orderType} ${this.orderNumber} completed`);
  return this.save();
};

// Cancel Order (unified method)
salesOrderSchema.methods.cancelOrder = function (
  cancelledBy = "system",
  reason = ""
) {
  this.status = "cancelled";
  this.lastModifiedBy = cancelledBy;

  if (reason) {
    this.notes = this.notes
      ? `${this.notes} | Cancelled: ${reason}`
      : `Cancelled: ${reason}`;
  }

  console.log(`✅ ${this.orderType} ${this.orderNumber} cancelled`);
  return this.save();
};

// Convert Quotation to Sales Order (unified method)
salesOrderSchema.methods.convertToSalesOrder = async function (
  convertedBy = "system"
) {
  if (this.orderType !== "quotation") {
    throw new Error("Can only convert quotations to sales orders");
  }

  if (this.status !== "accepted") {
    throw new Error("Can only convert accepted quotations to sales orders");
  }

  try {
    // Create new sales order from this quotation
    const salesOrderData = {
      ...this.toObject(),
      _id: undefined,
      orderNumber: undefined, // Will be auto-generated
      orderType: "sales_order",
      status: "confirmed",
      sourceOrderId: this._id,
      sourceOrderNumber: this.orderNumber,
      sourceOrderType: "quotation",
      sourceCompanyId: this.companyId,
      convertedBy,
      convertedAt: new Date(),
      notes: this.notes
        ? `${this.notes} | Converted from quotation ${this.orderNumber}`
        : `Converted from quotation ${this.orderNumber}`,
    };

    const salesOrder = new this.constructor(salesOrderData);
    await salesOrder.save();

    // Update quotation status
    this.status = "converted";
    this.convertedAt = new Date();
    this.convertedBy = convertedBy;
    await this.save();

    console.log(
      `✅ Quotation ${this.orderNumber} converted to sales order ${salesOrder.orderNumber}`
    );
    return salesOrder;
  } catch (error) {
    throw new Error(
      `Failed to convert quotation to sales order: ${error.message}`
    );
  }
};

// Add Payment (unified method)
salesOrderSchema.methods.addPayment = function (
  amount,
  method = "cash",
  reference = "",
  notes = ""
) {
  const currentPaid = this.payment?.paidAmount || 0;
  const newPaidAmount = currentPaid + parseFloat(amount);

  this.payment = {
    ...this.payment,
    paidAmount: newPaidAmount,
    method,
    reference,
    paymentDate: new Date(),
    notes,
  };

  // Add to payment history
  if (!this.paymentHistory) this.paymentHistory = [];

  this.paymentHistory.push({
    amount: parseFloat(amount),
    method,
    reference,
    paymentDate: new Date(),
    notes,
    createdAt: new Date(),
  });

  return this.save();
};

// Mark Purchase Order as Generated (unified method)
salesOrderSchema.methods.markPurchaseOrderGenerated = function (
  purchaseOrderId,
  purchaseOrderNumber,
  targetCompanyId,
  linkedSupplierId,
  generatedBy = "system"
) {
  this.autoGeneratedPurchaseOrder = true;
  this.hasGeneratedPurchaseOrder = true;
  this.purchaseOrderRef = purchaseOrderId;
  this.purchaseOrderNumber = purchaseOrderNumber;
  this.purchaseOrderGeneratedAt = new Date();
  this.purchaseOrderGeneratedBy = generatedBy;
  this.correspondingPurchaseOrderId = purchaseOrderId;
  this.correspondingPurchaseOrderNumber = purchaseOrderNumber;
  this.targetCompanyId = targetCompanyId;
  this.linkedSupplierId = linkedSupplierId;
  this.lastModifiedBy = generatedBy;

  return this.save();
};

// Convert to Invoice (unified method)
salesOrderSchema.methods.convertToInvoice = async function () {
  if (this.convertedToInvoice) {
    throw new Error("Order already converted to invoice");
  }

  try {
    const Sale = mongoose.model("Sale");

    // Generate invoice number
    const generateInvoiceNumber = async (companyId) => {
      const currentDate = new Date();
      const year = currentDate.getFullYear();
      const month = String(currentDate.getMonth() + 1).padStart(2, "0");
      const day = String(currentDate.getDate()).padStart(2, "0");

      const dateStr = `${year}${month}${day}`;
      const prefix = `INV-${dateStr}-`;

      const lastInvoice = await Sale.findOne({
        companyId: companyId,
        invoiceNumber: {$regex: `^${prefix}`},
      }).sort({invoiceNumber: -1});

      let nextNumber = 1;
      if (lastInvoice && lastInvoice.invoiceNumber) {
        const lastNumber = parseInt(lastInvoice.invoiceNumber.split("-").pop());
        if (!isNaN(lastNumber)) {
          nextNumber = lastNumber + 1;
        }
      }

      return `${prefix}${nextNumber.toString().padStart(4, "0")}`;
    };

    const invoiceNumber = await generateInvoiceNumber(this.companyId);

    // Map items
    const convertedItems = this.items.map((item) => {
      const itemObj = item.toObject ? item.toObject() : {...item};
      delete itemObj._id;

      return {
        itemRef: itemObj.itemRef,
        itemName: itemObj.itemName || itemObj.productName,
        itemCode: itemObj.itemCode || itemObj.productCode,
        hsnCode: itemObj.hsnCode || itemObj.hsnNumber || "0000",
        description: itemObj.description || "",
        category: itemObj.category || "",
        quantity: itemObj.quantity,
        unit: itemObj.unit === "pcs" ? "PCS" : itemObj.unit,
        pricePerUnit: itemObj.pricePerUnit || itemObj.price || itemObj.rate,
        taxRate: itemObj.taxRate || itemObj.gstRate || 18,
        taxMode:
          itemObj.gstMode === "include" ||
          itemObj.taxMode === "with-tax" ||
          itemObj.taxMode === "inclusive"
            ? "with-tax"
            : "without-tax",
        priceIncludesTax:
          itemObj.gstMode === "include" ||
          itemObj.taxMode === "with-tax" ||
          itemObj.taxMode === "inclusive",
        discountPercent: itemObj.discountPercent || itemObj.discount || 0,
        discountAmount: itemObj.discountAmount || 0,
        cgst: itemObj.cgst || 0,
        sgst: itemObj.sgst || 0,
        igst: itemObj.igst || 0,
        cgstAmount: itemObj.cgstAmount || 0,
        sgstAmount: itemObj.sgstAmount || 0,
        igstAmount: itemObj.igstAmount || 0,
        taxableAmount: itemObj.taxableAmount || itemObj.subtotal || 0,
        totalTaxAmount: itemObj.totalTaxAmount || itemObj.gstAmount || 0,
        amount: itemObj.amount || itemObj.totalAmount || itemObj.itemAmount,
        itemAmount: itemObj.itemAmount || itemObj.totalAmount || itemObj.amount,
        lineNumber: itemObj.lineNumber,
      };
    });

    // Create invoice data
    const invoiceData = {
      invoiceNumber: invoiceNumber,
      invoiceDate: new Date(),
      invoiceType: this.gstEnabled ? "gst" : "non-gst",
      customer: this.customer,
      customerMobile: this.customerMobile,
      gstEnabled: this.gstEnabled,
      gstType: this.gstType,
      taxMode: this.taxMode,
      priceIncludesTax: this.priceIncludesTax,
      companyId: this.companyId,
      items: convertedItems,
      totals: {
        subtotal: this.totals?.subtotal || 0,
        totalQuantity: this.totals?.totalQuantity || 0,
        totalDiscount: this.totals?.totalDiscount || 0,
        totalDiscountAmount: this.totals?.totalDiscountAmount || 0,
        totalTax: this.totals?.totalTax || 0,
        totalCGST: this.totals?.totalCGST || 0,
        totalSGST: this.totals?.totalSGST || 0,
        totalIGST: this.totals?.totalIGST || 0,
        totalTaxableAmount: this.totals?.totalTaxableAmount || 0,
        finalTotal: this.totals?.finalTotal || 0,
        roundOff: this.totals?.roundOff || 0,
        withTaxTotal: this.totals?.withTaxTotal || 0,
        withoutTaxTotal: this.totals?.withoutTaxTotal || 0,
      },
      payment: {
        method: this.payment?.method || "credit",
        status:
          (this.payment?.advanceAmount || 0) >= (this.totals?.finalTotal || 0)
            ? "paid"
            : (this.payment?.advanceAmount || 0) > 0
            ? "partial"
            : "pending",
        paidAmount: this.payment?.advanceAmount || 0,
        pendingAmount: Math.max(
          0,
          (this.totals?.finalTotal || 0) - (this.payment?.advanceAmount || 0)
        ),
        paymentDate: this.payment?.paymentDate || new Date(),
        dueDate: this.payment?.dueDate,
        creditDays: this.payment?.creditDays || 0,
        reference:
          this.payment?.reference ||
          `Converted from ${this.orderType} ${this.orderNumber}`,
        notes:
          this.payment?.notes ||
          `Converted from ${this.orderType} ${this.orderNumber}`,
      },
      sourceOrderId: this._id,
      sourceOrderNumber: this.orderNumber,
      sourceOrderType: this.orderType,
      sourceCompanyId: this.companyId,
      isAutoGenerated: false,
      generatedFrom: "sales_order",
      convertedBy: this.convertedBy || "system",
      notes: this.notes
        ? `${this.notes} | Converted from ${this.orderType} ${this.orderNumber}`
        : `Converted from ${this.orderType} ${this.orderNumber}`,
      termsAndConditions: this.termsAndConditions || "",
      status: "active",
      roundOff: this.roundOff || 0,
      roundOffEnabled: this.roundOffEnabled || false,
      createdBy: this.convertedBy || "system",
      lastModifiedBy: this.convertedBy || "system",
    };

    console.log("🔄 Creating invoice from order:", {
      orderId: this._id,
      orderNumber: this.orderNumber,
      orderType: this.orderType,
      invoiceNumber: invoiceNumber,
    });

    const invoice = new Sale(invoiceData);
    await invoice.save();

    // Update this order with conversion info
    this.convertedToInvoice = true;
    this.invoiceRef = invoice._id;
    this.invoiceNumber = invoice.invoiceNumber;
    this.convertedAt = new Date();
    this.status = "converted";
    this.convertedBy = this.convertedBy || "system";

    await this.save();

    console.log("✅ Order converted to invoice successfully");
    return invoice;
  } catch (error) {
    console.error("❌ Error converting order to invoice:", error);
    throw new Error(`Failed to convert order to invoice: ${error.message}`);
  }
};

// Set Due Date (unified method)
salesOrderSchema.methods.setDueDate = function (creditDays) {
  if (!creditDays || creditDays <= 0) return this;

  const dueDate = new Date();
  dueDate.setDate(dueDate.getDate() + parseInt(creditDays));

  this.payment.dueDate = dueDate;
  this.payment.creditDays = parseInt(creditDays);

  return this;
};

// ✅ UNIFIED STATIC METHODS

// Get orders by type and status
salesOrderSchema.statics.getOrdersByTypeAndStatus = function (
  companyId,
  orderType,
  status
) {
  const query = {companyId};

  if (orderType && orderType !== "all") {
    query.orderType = orderType;
  }

  if (status && status !== "all") {
    if (Array.isArray(status)) {
      query.status = {$in: status};
    } else {
      query.status = status;
    }
  }

  return this.find(query)
    .populate("customer", "name mobile email")
    .sort({orderDate: -1});
};

// Get pending orders
salesOrderSchema.statics.getPendingOrders = function (
  companyId,
  orderType = null
) {
  const query = {
    companyId,
    status: {$in: ["draft", "sent", "accepted", "confirmed"]},
  };

  if (orderType) {
    query.orderType = orderType;
  }

  return this.find(query)
    .populate("customer", "name mobile email")
    .sort({orderDate: -1});
};

// Get orders needing confirmation
salesOrderSchema.statics.getOrdersNeedingConfirmation = function (companyId) {
  return this.find({
    companyId,
    status: "sent",
    isAutoGenerated: true,
  })
    .populate("customer", "name mobile email")
    .sort({orderDate: -1});
};

// Get orders by status
salesOrderSchema.statics.getOrdersByStatus = function (companyId, status) {
  return this.find({
    companyId,
    status,
  })
    .populate("customer", "name mobile email")
    .sort({orderDate: -1});
};

// Get auto-generated orders
salesOrderSchema.statics.getAutoGeneratedOrders = function (
  companyId,
  orderType = null
) {
  const query = {
    companyId,
    isAutoGenerated: true,
  };

  if (orderType) {
    query.orderType = orderType;
  }

  return this.find(query)
    .populate("customer", "name mobile email")
    .populate("sourceCompanyId", "businessName")
    .sort({orderDate: -1});
};

// Get expired orders
salesOrderSchema.statics.getExpiredOrders = function (companyId) {
  return this.find({
    companyId,
    validUntil: {$lt: new Date()},
    status: {$nin: ["converted", "cancelled", "expired"]},
  }).populate("customer", "name mobile email");
};

// Get orders by customer
salesOrderSchema.statics.getOrdersByCustomer = function (customerId) {
  return this.find({
    customer: customerId,
    status: {$ne: "cancelled"},
  }).sort({orderDate: -1});
};

// Get orders required by date
salesOrderSchema.statics.getOrdersRequiredByDate = function (companyId, date) {
  return this.find({
    companyId,
    requiredBy: {$lte: date},
    status: {$nin: ["completed", "cancelled", "received"]},
  }).populate("customer", "name mobile email");
};

// Get orders awaiting approval
salesOrderSchema.statics.getOrdersAwaitingApproval = function (companyId) {
  return this.find({
    companyId,
    status: "draft",
    approvedBy: null,
  }).populate("customer", "name mobile email");
};

// Get orders with generated purchase orders
salesOrderSchema.statics.getOrdersWithGeneratedPO = function (
  companyId,
  filters = {}
) {
  const query = {
    companyId,
    autoGeneratedPurchaseOrder: true,
    hasGeneratedPurchaseOrder: true,
    ...filters,
  };

  return this.find(query)
    .populate("customer", "name mobile email")
    .populate("purchaseOrderRef", "orderNumber status totals")
    .populate("targetCompanyId", "businessName")
    .sort({purchaseOrderGeneratedAt: -1});
};

// Get bidirectional orders
salesOrderSchema.statics.getBidirectionalOrders = function (companyId) {
  return this.find({
    $or: [
      {companyId, sourceCompanyId: {$exists: true, $ne: null}},
      {companyId, targetCompanyId: {$exists: true, $ne: null}},
    ],
  })
    .populate("customer", "name mobile email")
    .populate("sourceCompanyId", "businessName")
    .populate("targetCompanyId", "businessName")
    .sort({orderDate: -1});
};

// BACKWARD COMPATIBILITY METHODS (for existing code)
salesOrderSchema.methods.markAsAccepted = function () {
  return this.acceptOrder();
};

salesOrderSchema.methods.markAsRejected = function () {
  return this.rejectOrder();
};

salesOrderSchema.methods.markAsConfirmed = function () {
  return this.confirmOrder();
};

salesOrderSchema.methods.markAsReceived = function () {
  this.status = "received";
  this.deliveryDate = new Date();
  return this.save();
};

salesOrderSchema.methods.approve = function (approvedBy) {
  return this.approveOrder(approvedBy);
};

module.exports = mongoose.model("SalesOrder", salesOrderSchema);
