const mongoose = require("mongoose");

// Payment History Schema
const paymentHistorySchema = new mongoose.Schema({
  amount: {
    type: Number,
    required: true,
    min: 0,
  },
  method: {
    type: String,
    enum: [
      "cash",
      "card",
      "upi",
      "bank_transfer",
      "cheque",
      "credit",
      "online",
      "bank",
    ],
    default: "cash",
  },
  reference: {
    type: String,
    trim: true,
    default: "",
  },
  paymentDate: {
    type: Date,
    required: true,
    default: Date.now,
  },
  dueDate: {
    type: Date,
    default: null,
  },
  notes: {
    type: String,
    trim: true,
    default: "",
  },
  createdAt: {
    type: Date,
    default: Date.now,
  },
  createdBy: {
    type: String,
    default: "system",
  },
});

// Main Sale Schema
const saleSchema = new mongoose.Schema(
  {
    // Invoice Details
    invoiceNumber: {
      type: String,
      required: true,
      unique: true,
      trim: true,
      index: true,
    },
    invoiceDate: {
      type: Date,
      required: true,
      default: Date.now,
    },
    invoiceType: {
      type: String,
      enum: ["gst", "non-gst"],
      default: "gst",
      required: true,
    },

    // Customer Information
    customer: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "Party",
      required: true,
      index: true,
    },
    customerMobile: {
      type: String,
      trim: true,
    },

    // GST and Tax Settings - FIXED WITH BOTH FIELDS
    gstEnabled: {
      type: Boolean,
      required: true,
      default: true,
    },
    taxMode: {
      type: String,
      enum: ["with-tax", "without-tax"],
      default: "without-tax",
    },
    priceIncludesTax: {
      type: Boolean,
      default: false,
    },

    // Company reference
    companyId: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "Company",
      required: true,
      index: true,
    },

    // ✅ NEW: Bidirectional Invoice Relationship Fields
    // When this sales invoice creates a corresponding purchase invoice in customer's system
    correspondingPurchaseInvoiceId: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "Purchase", // Assuming you have a Purchase model for purchase invoices
      default: null,
      index: true,
    },
    correspondingPurchaseInvoiceNumber: {
      type: String,
      default: null,
      index: true,
    },
    correspondingPurchaseInvoiceCompany: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "Company",
      default: null,
      index: true,
    },

    // ✅ NEW: When this sales invoice was created from a purchase invoice (source tracking)
    sourceInvoiceId: {
      type: mongoose.Schema.Types.ObjectId,
      default: null,
      index: true,
    },
    sourceInvoiceNumber: {
      type: String,
      default: null,
      index: true,
    },
    sourceInvoiceType: {
      type: String,
      enum: [
        "purchase_invoice",
        "purchase-invoice",
        "sales_invoice",
        "sales-invoice",
        "sales_order",
        "purchase_order",
        "manual",
      ],
      default: "manual",
      required: function () {
        return this.sourceInvoiceId != null;
      },
    },
    sourceCompanyId: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "Company",
      default: null,
      sparse: true,
      index: true,
    },

    // ✅ NEW: Auto-generation tracking for invoices
    isAutoGenerated: {
      type: Boolean,
      default: false,
      index: true,
    },
    generatedFrom: {
      type: String,
      enum: ["sales_order", "purchase_invoice", "manual", "import", "api"],
      default: "manual",
      index: true,
    },
    generatedBy: {
      type: String,
      default: null,
    },
    generatedAt: {
      type: Date,
      default: null,
      index: true,
    },

    // ✅ NEW: Purchase invoice generation tracking (when this sales invoice generates a purchase invoice)
    autoGeneratedPurchaseInvoice: {
      type: Boolean,
      default: false,
      index: true,
    },
    purchaseInvoiceRef: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "Purchase",
      default: null,
      index: true,
    },
    purchaseInvoiceNumber: {
      type: String,
      default: null,
      index: true,
    },
    purchaseInvoiceGeneratedAt: {
      type: Date,
      default: null,
      index: true,
    },
    purchaseInvoiceGeneratedBy: {
      type: String,
      default: null,
    },
    targetCompanyId: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "Company",
      default: null,
      index: true,
    },

    // ✅ NEW: Sales Order Conversion Tracking (enhanced)
    convertedFromSalesOrder: {
      type: Boolean,
      default: false,
      index: true,
    },
    salesOrderRef: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "SalesOrder",
      default: null,
      index: true,
    },
    salesOrderNumber: {
      type: String,
      default: null,
      index: true,
    },
    convertedFromSalesOrderAt: {
      type: Date,
      default: null,
    },
    convertedFromSalesOrderBy: {
      type: String,
      default: null,
    },

    // Sales Items Array - COMPLETE WITH ALL FIELDS
    items: [
      {
        // Item Reference (optional - for inventory items)
        itemRef: {
          type: mongoose.Schema.Types.ObjectId,
          ref: "Item",
          sparse: true,
        },

        // Item Details
        itemName: {
          type: String,
          required: true,
          trim: true,
        },
        itemCode: {
          type: String,
          trim: true,
          default: "",
        },
        hsnCode: {
          type: String,
          trim: true,
          default: "0000",
        },
        category: {
          type: String,
          trim: true,
          default: "",
        },
        description: {
          type: String,
          trim: true,
          default: "",
        },

        // Quantity and Unit
        quantity: {
          type: Number,
          required: true,
          min: 0.01,
        },
        unit: {
          type: String,
          enum: [
            "NONE",
            "KG",
            "GM",
            "LTR",
            "ML",
            "PCS",
            "BOX",
            "M",
            "CM",
            "BAG",
            "BTL",
            "BUN",
            "CAN",
            "CTN",
            "DOZ",
            "DRM",
            "FEW",
            "GMS",
            "GRS",
            "KGS",
            "KME",
            "MLS",
            "MTR",
            "NOS",
            "PAC",
            "QTL",
            "ROL",
            "SET",
            "SQF",
            "SQM",
            "TBS",
            "TGM",
            "THD",
            "TON",
            "TUB",
            "UGS",
            "UNT",
            "YDS",
            "OTH",
          ],
          default: "PCS",
        },

        // Pricing Details - COMPLETE WITH TAX MODE FIELDS
        pricePerUnit: {
          type: Number,
          required: true,
          min: 0,
        },
        taxRate: {
          type: Number,
          default: 18,
          min: 0,
          max: 100,
        },
        // FIXED: Item-level tax mode compatibility
        taxMode: {
          type: String,
          enum: ["with-tax", "without-tax"],
          default: "without-tax",
        },
        priceIncludesTax: {
          type: Boolean,
          default: false,
        },

        // Discount Fields
        discountPercent: {
          type: Number,
          default: 0,
          min: 0,
          max: 100,
        },
        discountAmount: {
          type: Number,
          default: 0,
          min: 0,
        },

        // Tax Amounts - COMPLETE WITH ALL VARIANTS
        // Backend fields (original)
        cgst: {
          type: Number,
          default: 0,
          min: 0,
        },
        sgst: {
          type: Number,
          default: 0,
          min: 0,
        },
        igst: {
          type: Number,
          default: 0,
          min: 0,
        },

        // Frontend compatibility fields
        cgstAmount: {
          type: Number,
          default: 0,
          min: 0,
        },
        sgstAmount: {
          type: Number,
          default: 0,
          min: 0,
        },
        igstAmount: {
          type: Number,
          default: 0,
          min: 0,
        },

        // Calculated amounts
        taxableAmount: {
          type: Number,
          default: 0,
          min: 0,
        },
        totalTaxAmount: {
          type: Number,
          default: 0,
          min: 0,
        },

        // Final amounts - BOTH FIELDS FOR COMPATIBILITY
        amount: {
          type: Number,
          default: 0,
          min: 0,
        },
        itemAmount: {
          type: Number,
          required: true,
          min: 0,
        },

        // Stock tracking
        currentStock: {
          type: Number,
          default: 0,
          min: 0,
        },
        minStockLevel: {
          type: Number,
          default: 0,
          min: 0,
        },

        // Line ordering
        lineNumber: {
          type: Number,
          required: true,
          min: 1,
        },
      },
    ],

    // Totals Section - COMPLETE
    totals: {
      subtotal: {
        type: Number,
        required: true,
        default: 0,
      },
      totalQuantity: {
        type: Number,
        default: 0,
      },
      totalDiscount: {
        type: Number,
        default: 0,
      },
      totalDiscountAmount: {
        type: Number,
        default: 0,
      },
      totalTax: {
        type: Number,
        default: 0,
      },
      totalCGST: {
        type: Number,
        default: 0,
      },
      totalSGST: {
        type: Number,
        default: 0,
      },
      totalIGST: {
        type: Number,
        default: 0,
      },
      totalTaxableAmount: {
        type: Number,
        default: 0,
      },
      finalTotal: {
        type: Number,
        required: true,
        min: 0,
      },
      roundOff: {
        type: Number,
        default: 0,
      },
      // Additional total fields for compatibility
      withTaxTotal: {
        type: Number,
        default: 0,
      },
      withoutTaxTotal: {
        type: Number,
        default: 0,
      },
    },

    // Payment Information - COMPLETE WITH DUE DATE SUPPORT
    payment: {
      method: {
        type: String,
        enum: [
          "cash",
          "card",
          "upi",
          "bank_transfer",
          "cheque",
          "credit",
          "online",
          "bank",
        ],
        default: "cash",
      },
      status: {
        type: String,
        enum: ["paid", "pending", "partial", "cancelled", "overdue"],
        default: "pending",
      },
      paidAmount: {
        type: Number,
        default: 0,
        min: 0,
      },
      pendingAmount: {
        type: Number,
        default: 0,
        min: 0,
      },
      paymentDate: {
        type: Date,
        default: Date.now,
      },
      dueDate: {
        type: Date,
        default: null,
        index: true,
      },
      creditDays: {
        type: Number,
        default: 0,
        min: 0,
      },
      reference: {
        type: String,
        trim: true,
        default: "",
      },
      notes: {
        type: String,
        trim: true,
        default: "",
      },
    },

    // Payment History
    paymentHistory: [paymentHistorySchema],

    // Additional Information
    notes: {
      type: String,
      trim: true,
      default: "",
    },
    termsAndConditions: {
      type: String,
      trim: true,
      default: "",
    },

    // Status Management
    status: {
      type: String,
      enum: ["draft", "completed", "cancelled"],
      default: "draft",
    },

    // Metadata
    createdBy: {
      type: String,
      default: "system",
    },
    lastModifiedBy: {
      type: String,
      default: "system",
    },
  },
  {
    timestamps: true,
    toJSON: {virtuals: true},
    toObject: {virtuals: true},
  }
);

// ✅ UPDATED: Enhanced indexes for bidirectional invoice relationships
saleSchema.index({companyId: 1, invoiceNumber: 1}, {unique: true});
saleSchema.index({companyId: 1, customer: 1});
saleSchema.index({companyId: 1, invoiceDate: 1});
saleSchema.index({companyId: 1, status: 1});
saleSchema.index({"payment.status": 1});
saleSchema.index({"payment.dueDate": 1});
saleSchema.index({companyId: 1, "payment.dueDate": 1});

// ✅ NEW: Bidirectional relationship indexes
saleSchema.index({sourceInvoiceId: 1, sourceInvoiceType: 1});
saleSchema.index({correspondingPurchaseInvoiceId: 1});
saleSchema.index({sourceCompanyId: 1});
saleSchema.index({isAutoGenerated: 1});
saleSchema.index({generatedFrom: 1});
saleSchema.index({autoGeneratedPurchaseInvoice: 1});
saleSchema.index({purchaseInvoiceRef: 1});
saleSchema.index({targetCompanyId: 1});
saleSchema.index({convertedFromSalesOrder: 1});
saleSchema.index({salesOrderRef: 1});

// ✅ NEW: Compound indexes for complex queries
saleSchema.index({companyId: 1, isAutoGenerated: 1, generatedFrom: 1});
saleSchema.index({companyId: 1, autoGeneratedPurchaseInvoice: 1});
saleSchema.index({companyId: 1, convertedFromSalesOrder: 1});
saleSchema.index({sourceCompanyId: 1, sourceInvoiceType: 1});

// EXISTING VIRTUAL FIELDS
saleSchema.virtual("balanceAmount").get(function () {
  const total = this.totals?.finalTotal || 0;
  const paid = this.payment?.paidAmount || 0;
  return Math.max(0, total - paid);
});

saleSchema.virtual("isOverdue").get(function () {
  if (!this.payment?.dueDate || this.payment?.pendingAmount <= 0) {
    return false;
  }
  return new Date() > this.payment.dueDate;
});

saleSchema.virtual("daysOverdue").get(function () {
  if (!this.isOverdue) {
    return 0;
  }
  const today = new Date();
  const dueDate = this.payment.dueDate;
  const timeDiff = today.getTime() - dueDate.getTime();
  return Math.ceil(timeDiff / (1000 * 3600 * 24));
});

// ✅ NEW: Virtual fields for bidirectional invoice relationships
saleSchema.virtual("hasCorrespondingPurchaseInvoice").get(function () {
  return !!(
    this.correspondingPurchaseInvoiceId &&
    this.correspondingPurchaseInvoiceNumber
  );
});

saleSchema.virtual("isFromPurchaseInvoice").get(function () {
  return !!(
    this.sourceInvoiceId &&
    this.sourceInvoiceType === "purchase_invoice" &&
    this.sourceCompanyId
  );
});

saleSchema.virtual("isFromSalesOrder").get(function () {
  return !!(this.convertedFromSalesOrder && this.salesOrderRef);
});

saleSchema.virtual("hasGeneratedPurchaseInvoice").get(function () {
  return !!(this.autoGeneratedPurchaseInvoice && this.purchaseInvoiceRef);
});

// ✅ NEW: Virtual for comprehensive invoice tracking info
saleSchema.virtual("invoiceTrackingInfo").get(function () {
  return {
    hasSource: this.isFromPurchaseInvoice || this.isFromSalesOrder,
    hasCorresponding: this.hasCorrespondingPurchaseInvoice,
    hasGeneratedPurchaseInvoice: this.hasGeneratedPurchaseInvoice,
    isAutoGenerated: this.isAutoGenerated,
    generatedFrom: this.generatedFrom,
    sourceChain: this.sourceInvoiceId
      ? {
          sourceInvoiceId: this.sourceInvoiceId,
          sourceInvoiceNumber: this.sourceInvoiceNumber,
          sourceInvoiceType: this.sourceInvoiceType,
          sourceCompanyId: this.sourceCompanyId,
        }
      : this.salesOrderRef
      ? {
          salesOrderRef: this.salesOrderRef,
          salesOrderNumber: this.salesOrderNumber,
          convertedFromSalesOrderAt: this.convertedFromSalesOrderAt,
          convertedFromSalesOrderBy: this.convertedFromSalesOrderBy,
        }
      : null,
    downstreamChain: this.correspondingPurchaseInvoiceId
      ? {
          correspondingPurchaseInvoiceId: this.correspondingPurchaseInvoiceId,
          correspondingPurchaseInvoiceNumber:
            this.correspondingPurchaseInvoiceNumber,
          correspondingPurchaseInvoiceCompany:
            this.correspondingPurchaseInvoiceCompany,
        }
      : null,
    generatedPurchaseInvoice: this.autoGeneratedPurchaseInvoice
      ? {
          purchaseInvoiceRef: this.purchaseInvoiceRef,
          purchaseInvoiceNumber: this.purchaseInvoiceNumber,
          targetCompanyId: this.targetCompanyId,
          generatedAt: this.purchaseInvoiceGeneratedAt,
          generatedBy: this.purchaseInvoiceGeneratedBy,
        }
      : null,
  };
});

// ✅ CRITICAL FIX: Pre-validate middleware to generate invoice number BEFORE validation
saleSchema.pre("validate", async function (next) {
  // ============================================================================
  // STEP 1: GENERATE COMPANY-SPECIFIC SEQUENTIAL INVOICE NUMBER (IF NEW)
  // ============================================================================
  if (this.isNew && !this.invoiceNumber) {
    try {
      console.log("🔢 Generating invoice number before validation...");

      const date = new Date();
      const year = date.getFullYear();
      const month = String(date.getMonth() + 1).padStart(2, "0");
      const day = String(date.getDate()).padStart(2, "0");

      // ✅ Get company details for prefix
      let companyPrefix = "INV";
      if (this.companyId) {
        try {
          const Company = require("./Company");
          const company = await Company.findById(this.companyId).select(
            "code businessName"
          );

          if (company?.code) {
            companyPrefix = company.code
              .toUpperCase()
              .replace(/[^A-Z0-9]/g, "")
              .substring(0, 6);
          } else if (company?.businessName) {
            companyPrefix = company.businessName
              .replace(/[^A-Za-z]/g, "")
              .substring(0, 3)
              .toUpperCase();
          }
        } catch (companyError) {
          console.warn("Could not fetch company details, using default prefix");
        }
      }

      // ✅ Find company-specific sequential number
      const todayStart = new Date(year, date.getMonth(), date.getDate());
      const todayEnd = new Date(year, date.getMonth(), date.getDate() + 1);

      const lastInvoice = await this.constructor
        .findOne({
          companyId: this.companyId, // ✅ Company-specific filter
          invoiceDate: {$gte: todayStart, $lt: todayEnd},
          invoiceNumber: {
            $exists: true,
            $ne: null,
            $ne: "",
            $regex: new RegExp(
              `^${companyPrefix}-(GST-)?${year}${month}${day}`
            ),
          },
          _id: {$ne: this._id}, // ✅ Exclude current document
        })
        .sort({invoiceNumber: -1, createdAt: -1});

      let sequenceNumber = 1;

      if (lastInvoice && lastInvoice.invoiceNumber) {
        const regex = new RegExp(
          `^${companyPrefix}-(GST-)?${year}${month}${day}-(\\d+)$`
        );
        const match = lastInvoice.invoiceNumber.match(regex);

        if (match) {
          const lastSequence = parseInt(match[2] || match[3]);
          if (!isNaN(lastSequence)) {
            sequenceNumber = lastSequence + 1;
          }
        }
      }

      // ✅ Generate company-specific invoice number
      const gstPrefix =
        this.gstEnabled || this.invoiceType === "gst" ? "GST-" : "";
      const sequenceStr = sequenceNumber.toString().padStart(4, "0");

      this.invoiceNumber = `${companyPrefix}-${gstPrefix}${year}${month}${day}-${sequenceStr}`;

      console.log(
        `✅ Generated invoice number before validation: ${this.invoiceNumber}`,
        {
          companyId: this.companyId.toString(),
          companyPrefix,
          dateStr: `${year}${month}${day}`,
          sequenceNumber,
          gstEnabled: this.gstEnabled,
          invoiceType: this.invoiceType,
        }
      );
    } catch (error) {
      console.error("❌ Error generating invoice number:", error);
      // ✅ Fallback with timestamp
      const timestamp = Date.now().toString().slice(-6);
      const gstPrefix =
        this.gstEnabled || this.invoiceType === "gst" ? "GST-" : "";
      this.invoiceNumber = `INV-${gstPrefix}${timestamp}`;
      console.log(`⚠️ Using fallback invoice number: ${this.invoiceNumber}`);
    }
  }

  next();
});

// ✅ UPDATED: Combined pre-save middleware (runs AFTER validation)
saleSchema.pre("save", async function (next) {
  // ============================================================================
  // STEP 2: SYNC GLOBAL TAX MODE FIELDS (after invoice number is set)
  // ============================================================================
  if (this.taxMode) {
    this.priceIncludesTax = this.taxMode === "with-tax";
  } else if (this.priceIncludesTax !== undefined) {
    this.taxMode = this.priceIncludesTax ? "with-tax" : "without-tax";
  }

  // ============================================================================
  // STEP 3: PROCESS ITEMS
  // ============================================================================
  this.items.forEach((item, index) => {
    // Set line numbers
    if (!item.lineNumber) {
      item.lineNumber = index + 1;
    }

    // Sync item-level tax mode fields
    if (item.taxMode) {
      item.priceIncludesTax = item.taxMode === "with-tax";
    } else if (item.priceIncludesTax !== undefined) {
      item.taxMode = item.priceIncludesTax ? "with-tax" : "without-tax";
    } else {
      // Use global tax mode if item doesn't have its own
      item.taxMode = this.taxMode || "without-tax";
      item.priceIncludesTax = item.taxMode === "with-tax";
    }

    // Sync calculated amounts for compatibility
    if (item.itemAmount && !item.amount) {
      item.amount = item.itemAmount;
    } else if (item.amount && !item.itemAmount) {
      item.itemAmount = item.amount;
    }

    // Sync tax amounts
    if (item.cgst !== undefined && item.cgstAmount === undefined) {
      item.cgstAmount = item.cgst;
    } else if (item.cgstAmount !== undefined && item.cgst === undefined) {
      item.cgst = item.cgstAmount;
    }

    if (item.sgst !== undefined && item.sgstAmount === undefined) {
      item.sgstAmount = item.sgst;
    } else if (item.sgstAmount !== undefined && item.sgst === undefined) {
      item.sgst = item.sgstAmount;
    }

    if (item.igst !== undefined && item.igstAmount === undefined) {
      item.igstAmount = item.igst;
    } else if (item.igstAmount !== undefined && item.igst === undefined) {
      item.igst = item.igstAmount;
    }

    // Calculate total tax amount
    item.totalTaxAmount =
      (item.cgstAmount || item.cgst || 0) +
      (item.sgstAmount || item.sgst || 0) +
      (item.igstAmount || item.igst || 0);
  });

  // ============================================================================
  // STEP 4: UPDATE PAYMENT STATUS
  // ============================================================================
  if (this.payment && this.totals) {
    const paidAmount = this.payment.paidAmount || 0;
    const finalTotal = this.totals.finalTotal || 0;

    this.payment.pendingAmount = Math.max(0, finalTotal - paidAmount);

    if (paidAmount >= finalTotal && finalTotal > 0) {
      this.payment.status = "paid";
      this.payment.pendingAmount = 0;
      this.payment.dueDate = null;
    } else if (paidAmount > 0) {
      if (this.payment.dueDate && new Date() > this.payment.dueDate) {
        this.payment.status = "overdue";
      } else {
        this.payment.status = "partial";
      }
    } else {
      if (this.payment.dueDate && new Date() > this.payment.dueDate) {
        this.payment.status = "overdue";
      } else {
        this.payment.status = "pending";
      }
    }
  }

  // ============================================================================
  // STEP 5: SET GENERATION METADATA FOR AUTO-GENERATED INVOICES
  // ============================================================================
  if (this.isAutoGenerated && this.isNew) {
    if (!this.generatedAt) {
      this.generatedAt = new Date();
    }
    if (!this.generatedBy) {
      this.generatedBy = "system";
    }
  }

  // ============================================================================
  // STEP 6: UPDATE NOTES WITH BIDIRECTIONAL TRACKING INFO
  // ============================================================================
  if (this.isNew) {
    let trackingNotes = [];

    if (this.sourceInvoiceId && this.sourceInvoiceNumber) {
      trackingNotes.push(
        `Converted from ${this.sourceInvoiceType.replace("_", " ")} ${
          this.sourceInvoiceNumber
        }`
      );
    }

    if (this.salesOrderRef && this.salesOrderNumber) {
      trackingNotes.push(`Converted from Sales Order ${this.salesOrderNumber}`);
    }

    if (trackingNotes.length > 0) {
      const existingNotes = this.notes ? this.notes.trim() : "";
      const newTrackingInfo = trackingNotes.join(". ");

      if (existingNotes && !existingNotes.includes(newTrackingInfo)) {
        this.notes = `${existingNotes}. ${newTrackingInfo}`;
      } else if (!existingNotes) {
        this.notes = newTrackingInfo;
      }
    }
  }

  next();
});

// ✅ NEW: Post-save middleware for bidirectional invoice creation
saleSchema.post("save", async function (doc) {
  // Only create corresponding invoice for new sales invoices that are not auto-generated
  if (doc.isNew && !doc.isAutoGenerated && doc.status !== "draft") {
    try {
      await doc.createCorrespondingPurchaseInvoice();
    } catch (error) {
      console.error(
        "❌ Failed to create corresponding purchase invoice:",
        error
      );
      // Don't throw error to avoid breaking the sales invoice save
    }
  }
});

// EXISTING INSTANCE METHODS
saleSchema.methods.addPayment = function (
  amount,
  method = "cash",
  reference = "",
  paymentDate = null,
  dueDate = null,
  notes = ""
) {
  const currentPaid = this.payment?.paidAmount || 0;
  const newPaidAmount = currentPaid + parseFloat(amount);

  // Update main payment record
  this.payment = {
    ...this.payment,
    paidAmount: newPaidAmount,
    method,
    reference,
    paymentDate: paymentDate ? new Date(paymentDate) : new Date(),
    dueDate: dueDate ? new Date(dueDate) : this.payment.dueDate,
    notes,
  };

  // Add to payment history
  if (!this.paymentHistory) {
    this.paymentHistory = [];
  }

  this.paymentHistory.push({
    amount: parseFloat(amount),
    method,
    reference,
    paymentDate: paymentDate ? new Date(paymentDate) : new Date(),
    dueDate: dueDate ? new Date(dueDate) : null,
    notes,
    createdAt: new Date(),
    createdBy: "system",
  });

  return this.save();
};

saleSchema.methods.setDueDate = function (creditDays) {
  if (!creditDays || creditDays <= 0) return this;

  const dueDate = new Date();
  dueDate.setDate(dueDate.getDate() + parseInt(creditDays));

  this.payment.dueDate = dueDate;
  this.payment.creditDays = parseInt(creditDays);

  return this;
};

saleSchema.methods.markAsCompleted = function () {
  this.status = "completed";
  return this.save();
};

saleSchema.methods.markAsCancelled = function () {
  this.status = "cancelled";
  return this.save();
};

// ✅ NEW: Create corresponding purchase invoice in customer's system
saleSchema.methods.createCorrespondingPurchaseInvoice = async function () {
  try {
    console.log(
      "🔄 Creating corresponding purchase invoice for sales invoice:",
      this.invoiceNumber
    );

    // Import models
    const Company = mongoose.model("Company");
    const Purchase = mongoose.model("Purchase"); // Assuming you have this model
    const Party = mongoose.model("Party");

    // Check if customer has their own company account in the system
    const customerCompany = await Company.findOne({
      $or: [{owner: this.customer}, {"users.user": this.customer}],
    });

    if (!customerCompany) {
      console.log("ℹ️ Customer does not have a company account in the system");
      return null;
    }

    // Generate purchase invoice number for customer
    const purchaseInvoiceNumber = await this.generatePurchaseInvoiceNumber(
      customerCompany._id
    );

    // Transform sales invoice items to purchase invoice format
    const purchaseInvoiceItems = this.items.map((item) => ({
      itemRef: item.itemRef,
      itemName: item.itemName,
      itemCode: item.itemCode,
      description: item.description || "",
      quantity: item.quantity,
      pricePerUnit: item.pricePerUnit,
      unit: item.unit,
      discountPercent: item.discountPercent || 0,
      discountAmount: item.discountAmount || 0,
      taxRate: item.taxRate || 0,
      taxMode: item.taxMode || "without-tax",
      priceIncludesTax: item.priceIncludesTax || false,
      cgst: item.cgst || 0,
      sgst: item.sgst || 0,
      igst: item.igst || 0,
      cgstAmount: item.cgstAmount || 0,
      sgstAmount: item.sgstAmount || 0,
      igstAmount: item.igstAmount || 0,
      taxableAmount: item.taxableAmount || 0,
      totalTaxAmount: item.totalTaxAmount || 0,
      amount: item.amount || item.itemAmount,
      itemAmount: item.itemAmount || item.amount,
      lineNumber: item.lineNumber,
    }));

    // Get or create supplier party (representing our company in customer's system)
    const supplierParty = await this.getOrCreateSupplierInCustomerSystem(
      customerCompany._id
    );

    // ✅ Create purchase invoice data with bidirectional tracking
    const purchaseInvoiceData = {
      invoiceNumber: purchaseInvoiceNumber,
      invoiceDate: this.invoiceDate,
      invoiceType: this.invoiceType,

      // Supplier is our company
      supplier: supplierParty._id,
      supplierMobile: "",

      // Company is the customer's company
      companyId: customerCompany._id,

      // Copy items and totals
      items: purchaseInvoiceItems,
      totals: {
        subtotal: this.totals.subtotal,
        totalQuantity: this.totals.totalQuantity,
        totalDiscount: this.totals.totalDiscount,
        totalDiscountAmount: this.totals.totalDiscountAmount,
        totalTax: this.totals.totalTax,
        totalCGST: this.totals.totalCGST,
        totalSGST: this.totals.totalSGST,
        totalIGST: this.totals.totalIGST,
        totalTaxableAmount: this.totals.totalTaxableAmount,
        finalTotal: this.totals.finalTotal,
        roundOff: this.totals.roundOff || 0,
        withTaxTotal: this.totals.withTaxTotal,
        withoutTaxTotal: this.totals.withoutTaxTotal,
      },

      // Payment information
      payment: {
        method: this.payment.method,
        status: "pending",
        paidAmount: 0,
        pendingAmount: this.totals.finalTotal,
        dueDate: this.payment.dueDate,
        creditDays: this.payment.creditDays,
      },

      // GST and tax settings
      gstEnabled: this.gstEnabled,
      taxMode: this.taxMode,
      priceIncludesTax: this.priceIncludesTax,

      // ✅ Bidirectional reference to original sales invoice
      sourceInvoiceId: this._id,
      sourceInvoiceNumber: this.invoiceNumber,
      sourceInvoiceType: "sales_invoice",
      sourceCompanyId: this.companyId,

      // Other details
      notes: `Auto-generated from Sales Invoice ${this.invoiceNumber}`,
      termsAndConditions: this.termsAndConditions,
      status: "received", // Set as received since it came from supplier

      // System fields
      createdBy: "system",
      lastModifiedBy: "system",
      isAutoGenerated: true,
      generatedFrom: "sales_invoice",
      generatedBy: "system",
      generatedAt: new Date(),
    };

    const purchaseInvoice = new Purchase(purchaseInvoiceData);
    await purchaseInvoice.save();

    // ✅ Update this sales invoice with reference to purchase invoice
    this.correspondingPurchaseInvoiceId = purchaseInvoice._id;
    this.correspondingPurchaseInvoiceNumber = purchaseInvoice.invoiceNumber;
    this.correspondingPurchaseInvoiceCompany = customerCompany._id;
    await this.save();

    console.log(
      "✅ Corresponding purchase invoice created:",
      purchaseInvoice.invoiceNumber
    );
    return purchaseInvoice;
  } catch (error) {
    console.error("❌ Error creating corresponding purchase invoice:", error);
    throw error;
  }
};

// ✅ NEW: Generate purchase invoice number for customer's company
saleSchema.methods.generatePurchaseInvoiceNumber = async function (
  customerCompanyId
) {
  try {
    const Purchase = mongoose.model("Purchase");

    const date = new Date();
    const year = date.getFullYear();
    const month = String(date.getMonth() + 1).padStart(2, "0");
    const day = String(date.getDate()).padStart(2, "0");

    const prefix = this.gstEnabled ? "PGST" : "PINV";

    const todayStart = new Date(year, date.getMonth(), date.getDate());
    const todayEnd = new Date(year, date.getMonth(), date.getDate() + 1);

    const lastInvoice = await Purchase.findOne({
      companyId: customerCompanyId,
      invoiceDate: {$gte: todayStart, $lt: todayEnd},
      invoiceNumber: new RegExp(`^${prefix}-${year}${month}${day}`),
    }).sort({invoiceNumber: -1});

    let sequence = 1;
    if (lastInvoice && lastInvoice.invoiceNumber) {
      const lastSequence = parseInt(lastInvoice.invoiceNumber.split("-").pop());
      if (!isNaN(lastSequence)) {
        sequence = lastSequence + 1;
      }
    }

    return `${prefix}-${year}${month}${day}-${String(sequence).padStart(
      4,
      "0"
    )}`;
  } catch (error) {
    console.error("Error generating purchase invoice number:", error);
    return `PINV-${Date.now()}`;
  }
};

// ✅ NEW: Get or create supplier party in customer's system
saleSchema.methods.getOrCreateSupplierInCustomerSystem = async function (
  customerCompanyId
) {
  try {
    const Party = mongoose.model("Party");
    const Company = mongoose.model("Company");

    // Get our company information
    const ourCompany = await Company.findById(this.companyId);
    if (!ourCompany) {
      throw new Error("Source company not found");
    }

    // Try to find existing supplier party for our company in customer's system
    let supplierParty = await Party.findOne({
      companyId: customerCompanyId,
      name: ourCompany.businessName,
      type: "supplier",
    });

    if (!supplierParty) {
      // Create new supplier based on our company information
      supplierParty = new Party({
        name: ourCompany.businessName,
        mobile: ourCompany.phoneNumber || "",
        email: ourCompany.email || "",
        type: "supplier",
        partyType: "supplier",
        address: ourCompany.address || "",
        gstNumber: ourCompany.gstin || "",
        companyId: customerCompanyId,
        status: "active",
        creditLimit: 0,
        creditDays: 30,
        currentBalance: 0,
        openingBalance: 0,
        sourceCompanyId: this.companyId,
        linkedCompanyId: this.companyId,
        isLinkedSupplier: true,
        enableBidirectionalInvoices: true,
        notes: `Auto-created from Sales Invoice ${this.invoiceNumber}`,
      });
      await supplierParty.save();
    }

    return supplierParty;
  } catch (error) {
    console.error("Error creating supplier in customer system:", error);
    throw error;
  }
};

// ✅ NEW: Get complete bidirectional invoice tracking chain
saleSchema.methods.getInvoiceTrackingChain = async function () {
  try {
    const chain = [];

    // Add source information if exists
    if (this.isFromPurchaseInvoice) {
      const Purchase = mongoose.model("Purchase");
      const sourcePurchaseInvoice = await Purchase.findById(
        this.sourceInvoiceId
      ).populate("supplier", "name mobile email");

      if (sourcePurchaseInvoice) {
        chain.push({
          step: 1,
          type: "purchase_invoice",
          document: sourcePurchaseInvoice,
          description: `Source Purchase Invoice: ${sourcePurchaseInvoice.invoiceNumber}`,
          companyId: sourcePurchaseInvoice.companyId,
        });
      }
    }

    // Add sales order source if exists
    if (this.isFromSalesOrder) {
      const SalesOrder = mongoose.model("SalesOrder");
      const sourceSalesOrder = await SalesOrder.findById(
        this.salesOrderRef
      ).populate("customer", "name mobile email");

      if (sourceSalesOrder) {
        chain.push({
          step: 1,
          type: "sales_order",
          document: sourceSalesOrder,
          description: `Source Sales Order: ${sourceSalesOrder.orderNumber}`,
          companyId: sourceSalesOrder.companyId,
        });
      }
    }

    // Add current sales invoice
    chain.push({
      step: chain.length + 1,
      type: "sales_invoice",
      document: this,
      description: `Sales Invoice: ${this.invoiceNumber}`,
      companyId: this.companyId,
    });

    // Add corresponding purchase invoice if exists
    if (this.hasCorrespondingPurchaseInvoice) {
      const Purchase = mongoose.model("Purchase");
      const correspondingPurchaseInvoice = await Purchase.findById(
        this.correspondingPurchaseInvoiceId
      ).populate("supplier", "name mobile email");

      if (correspondingPurchaseInvoice) {
        chain.push({
          step: chain.length + 1,
          type: "purchase_invoice",
          document: correspondingPurchaseInvoice,
          description: `Generated Purchase Invoice: ${correspondingPurchaseInvoice.invoiceNumber}`,
          companyId: correspondingPurchaseInvoice.companyId,
        });
      }
    }

    return chain;
  } catch (error) {
    console.error("Error getting invoice tracking chain:", error);
    return [];
  }
};

// EXISTING STATIC METHODS
saleSchema.statics.getTodaysSales = function (companyId) {
  const today = new Date();
  const startOfDay = new Date(
    today.getFullYear(),
    today.getMonth(),
    today.getDate()
  );
  const endOfDay = new Date(
    today.getFullYear(),
    today.getMonth(),
    today.getDate() + 1
  );

  return this.find({
    companyId,
    invoiceDate: {$gte: startOfDay, $lt: endOfDay},
    status: {$ne: "cancelled"},
  });
};

saleSchema.statics.getOverdueSales = function (companyId) {
  const today = new Date();
  return this.find({
    companyId,
    "payment.status": {$in: ["pending", "partial", "overdue"]},
    "payment.dueDate": {$lt: today},
    "payment.pendingAmount": {$gt: 0},
    status: {$ne: "cancelled"},
  }).populate("customer", "name mobile email");
};

saleSchema.statics.getSalesDueToday = function (companyId) {
  const today = new Date();
  const startOfDay = new Date(
    today.getFullYear(),
    today.getMonth(),
    today.getDate()
  );
  const endOfDay = new Date(
    today.getFullYear(),
    today.getMonth(),
    today.getDate() + 1
  );

  return this.find({
    companyId,
    "payment.status": {$in: ["pending", "partial"]},
    "payment.dueDate": {$gte: startOfDay, $lt: endOfDay},
    "payment.pendingAmount": {$gt: 0},
    status: {$ne: "cancelled"},
  }).populate("customer", "name mobile email");
};

saleSchema.statics.getPaymentSummaryWithOverdue = function (
  companyId,
  dateFrom,
  dateTo
) {
  const matchFilter = {companyId, status: {$ne: "cancelled"}};

  if (dateFrom || dateTo) {
    matchFilter.invoiceDate = {};
    if (dateFrom) matchFilter.invoiceDate.$gte = new Date(dateFrom);
    if (dateTo) matchFilter.invoiceDate.$lte = new Date(dateTo);
  }

  return this.aggregate([
    {$match: matchFilter},
    {
      $addFields: {
        isOverdue: {
          $and: [
            {$gt: ["$payment.pendingAmount", 0]},
            {$ne: ["$payment.dueDate", null]},
            {$lt: ["$payment.dueDate", new Date()]},
          ],
        },
      },
    },
    {
      $group: {
        _id: null,
        totalSales: {$sum: "$totals.finalTotal"},
        totalPaid: {$sum: "$payment.paidAmount"},
        totalPending: {$sum: "$payment.pendingAmount"},
        totalOverdue: {
          $sum: {
            $cond: ["$isOverdue", "$payment.pendingAmount", 0],
          },
        },
        overdueCount: {
          $sum: {
            $cond: ["$isOverdue", 1, 0],
          },
        },
        paymentBreakdown: {
          $push: {
            status: "$payment.status",
            amount: "$payment.pendingAmount",
            isOverdue: "$isOverdue",
          },
        },
      },
    },
  ]);
};

saleSchema.statics.getPaymentSummary = function (companyId, dateFrom, dateTo) {
  const matchFilter = {companyId, status: {$ne: "cancelled"}};

  if (dateFrom || dateTo) {
    matchFilter.invoiceDate = {};
    if (dateFrom) matchFilter.invoiceDate.$gte = new Date(dateFrom);
    if (dateTo) matchFilter.invoiceDate.$lte = new Date(dateTo);
  }

  return this.aggregate([
    {$match: matchFilter},
    {
      $group: {
        _id: "$payment.status",
        totalAmount: {$sum: "$totals.finalTotal"},
        paidAmount: {$sum: "$payment.paidAmount"},
        pendingAmount: {$sum: "$payment.pendingAmount"},
        count: {$sum: 1},
      },
    },
  ]);
};

// ✅ NEW: Static methods for bidirectional invoice analytics
saleSchema.statics.getInvoicesWithCorrespondingPurchaseInvoices = function (
  companyId
) {
  return this.find({
    companyId,
    correspondingPurchaseInvoiceId: {$exists: true, $ne: null},
  })
    .populate("customer", "name mobile email")
    .sort({invoiceDate: -1});
};

saleSchema.statics.getInvoicesFromPurchaseInvoices = function (companyId) {
  return this.find({
    companyId,
    sourceInvoiceType: "purchase_invoice",
  }).populate("customer", "name mobile email");
};

saleSchema.statics.getInvoicesFromSalesOrders = function (companyId) {
  return this.find({
    companyId,
    convertedFromSalesOrder: true,
  }).populate("customer", "name mobile email");
};

saleSchema.statics.getSalesInvoicesWithGeneratedPurchaseInvoices = function (
  companyId
) {
  return this.find({
    companyId,
    autoGeneratedPurchaseInvoice: true,
    purchaseInvoiceRef: {$exists: true, $ne: null},
  })
    .populate("customer", "name mobile email")
    .sort({purchaseInvoiceGeneratedAt: -1});
};

// ✅ NEW: Get bidirectional invoice analytics for company
saleSchema.statics.getBidirectionalInvoiceAnalytics = async function (
  companyId
) {
  try {
    const [
      totalSalesInvoices,
      autoGeneratedSalesInvoices,
      salesInvoicesWithCorrespondingPurchase,
      salesInvoicesWithGeneratedPurchase,
      salesInvoicesFromPurchaseInvoices,
      salesInvoicesFromSalesOrders,
    ] = await Promise.all([
      this.countDocuments({companyId}),
      this.countDocuments({companyId, isAutoGenerated: true}),
      this.countDocuments({
        companyId,
        correspondingPurchaseInvoiceId: {$exists: true, $ne: null},
      }),
      this.countDocuments({
        companyId,
        autoGeneratedPurchaseInvoice: true,
      }),
      this.countDocuments({companyId, sourceInvoiceType: "purchase_invoice"}),
      this.countDocuments({companyId, convertedFromSalesOrder: true}),
    ]);

    return {
      totalSalesInvoices,
      autoGeneratedSalesInvoices,
      salesInvoicesWithCorrespondingPurchase,
      salesInvoicesWithGeneratedPurchase,
      salesInvoicesFromPurchaseInvoices,
      salesInvoicesFromSalesOrders,
      bidirectionalCoverage:
        totalSalesInvoices > 0
          ? (
              ((autoGeneratedSalesInvoices +
                salesInvoicesWithCorrespondingPurchase +
                salesInvoicesWithGeneratedPurchase +
                salesInvoicesFromSalesOrders) /
                totalSalesInvoices) *
              100
            ).toFixed(2)
          : 0,
      purchaseInvoiceGenerationRate:
        totalSalesInvoices > 0
          ? (
              (salesInvoicesWithGeneratedPurchase / totalSalesInvoices) *
              100
            ).toFixed(2)
          : 0,
      salesOrderConversionRate:
        totalSalesInvoices > 0
          ? ((salesInvoicesFromSalesOrders / totalSalesInvoices) * 100).toFixed(
              2
            )
          : 0,
    };
  } catch (error) {
    console.error("Error getting bidirectional invoice analytics:", error);
    throw error;
  }
};

module.exports = mongoose.model("Sale", saleSchema);
